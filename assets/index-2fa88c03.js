function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE$1 = /^on[^a-z]/;
const isOn$1 = (key) => onRE$1.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$1(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console";
const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props2) {
  if (!props2)
    return null;
  let { class: klass, style: style3 } = props2;
  if (klass && !isString(klass)) {
    props2.class = normalizeClass(klass);
  }
  if (style3) {
    props2.style = normalizeStyle(style3);
  }
  return props2;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol(a);
  bValidType = isSymbol(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$1(a);
  bValidType = isArray$1(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$1(a);
  bValidType = isObject$1(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$1(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$1(val) && !isArray$1(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l2;
      for (i = 0, l2 = this.effects.length; i < l2; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l2 = this.cleanups.length; i < l2; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l2 = this.scopes.length; i < l2; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn, options) {
  if (fn.effect instanceof ReactiveEffect) {
    fn = fn.effect.fn;
  }
  const _effect = new ReactiveEffect(fn);
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$1(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a;
  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l2 = this.length; i < l2; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _shallow = false) {
    this._isReadonly = _isReadonly;
    this._shallow = _shallow;
  }
  get(target, key, receiver) {
    const isReadonly2 = this._isReadonly, shallow = this._shallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(false, shallow);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!this._shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$1(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(shallow = false) {
    super(true, shallow);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
  true
);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (hasChanged(key, rawKey)) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(
      method,
      false,
      false
    );
    readonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      false
    );
    shallowInstrumentations2[method] = createIterableMethod(
      method,
      false,
      true
    );
    shallowReadonlyInstrumentations2[method] = createIterableMethod(
      method,
      true,
      true
    );
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [
  mutableInstrumentations,
  readonlyInstrumentations,
  shallowInstrumentations,
  shallowReadonlyInstrumentations
] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
function toValue(source) {
  return isFunction(source) ? source() : unref(source);
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(
      () => trackRefValue(this),
      () => triggerRefValue(this)
    );
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray$1(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this.__v_isRef = true;
    this.__v_isReadonly = true;
  }
  get value() {
    return this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$1(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this["__v_isReadonly"] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function assertNumber(val, type) {
  return;
}
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(
        appErrorHandler,
        null,
        10,
        [err, exposedInstance, errorInfo]
      );
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.pre) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(
    job,
    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
  )) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(
      cb,
      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
    )) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i = isFlushing ? flushIndex + 1 : 0) {
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let devtools;
let buffer = [];
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props2 = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props2) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props2[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props2[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props2[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props2[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props2[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$1(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn$1(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    props: props2,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render: render2,
    renderCache,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(
        render2.call(
          proxyToUse,
          proxyToUse,
          renderCache,
          props2,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render22 = Component;
      if (false)
        ;
      result = normalizeVNode(
        render22.length > 1 ? render22(
          props2,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return attrs;
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render22(
          props2,
          null
          /* we know it doesn't need it */
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn$1(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props2) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props2)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component) {
  if (isString(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    } else {
      patchSuspense(
        n1,
        n2,
        container,
        anchor,
        parentComponent,
        isSVG,
        slotScopeIds,
        optimized,
        rendererInternals
      );
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const {
    p: patch,
    o: { createElement }
  } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    container,
    hiddenContainer,
    anchor,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals
  );
  patch(
    null,
    suspense.pendingBranch = vnode.ssContent,
    hiddenContainer,
    null,
    parentComponent,
    suspense,
    isSVG,
    slotScopeIds
  );
  if (suspense.deps > 0) {
    triggerEvent(vnode, "onPending");
    triggerEvent(vnode, "onFallback");
    patch(
      null,
      vnode.ssFallback,
      container,
      anchor,
      parentComponent,
      null,
      // fallback tree will not have suspense context
      isSVG,
      slotScopeIds
    );
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve(false, true);
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(
        pendingBranch,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(
          activeBranch,
          newFallback,
          container,
          anchor,
          parentComponent,
          null,
          // fallback tree will not have suspense context
          isSVG,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(
            activeBranch,
            newFallback,
            container,
            anchor,
            parentComponent,
            null,
            // fallback tree will not have suspense context
            isSVG,
            slotScopeIds,
            optimized
          );
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(
          activeBranch,
          newBranch,
          container,
          anchor,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        suspense.resolve(true);
      } else {
        patch(
          null,
          newBranch,
          suspense.hiddenContainer,
          null,
          parentComponent,
          suspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(
        activeBranch,
        newBranch,
        container,
        anchor,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(
        null,
        newBranch,
        suspense.hiddenContainer,
        null,
        parentComponent,
        suspense,
        isSVG,
        slotScopeIds,
        optimized
      );
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const {
    p: patch,
    m: move,
    um: unmount,
    n: next,
    o: { parentNode, remove: remove2 }
  } = rendererInternals;
  let parentSuspenseId;
  const isSuspensible = isVNodeSuspensible(vnode);
  if (isSuspensible) {
    if (parentSuspense == null ? void 0 : parentSuspense.pendingBranch) {
      parentSuspenseId = parentSuspense.pendingId;
      parentSuspense.deps++;
    }
  }
  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;
  const suspense = {
    vnode,
    parent: parentSuspense,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false, sync = false) {
      const {
        vnode: vnode2,
        activeBranch,
        pendingBranch,
        pendingId,
        effects,
        parentComponent: parentComponent2,
        container: container2
      } = suspense;
      let delayEnter = false;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
              queuePostFlushCb(effects);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent) {
        if (parent.pendingBranch) {
          parent.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent = parent.parent;
      }
      if (!hasUnresolvedAncestor && !delayEnter) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      if (isSuspensible) {
        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0 && !sync) {
            parentSuspense.resolve();
          }
        }
      }
      triggerEvent(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(
          null,
          fallbackVNode,
          container2,
          anchor2,
          parentComponent2,
          null,
          // fallback tree will not have suspense context
          isSVG2,
          slotScopeIds,
          optimized
        );
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(
        activeBranch,
        parentComponent2,
        null,
        // no suspense so unmount hooks fire now
        true
        // shouldRemove
      );
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(
          instance,
          vnode2,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          parentNode(hydratedEl || instance.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          hydratedEl ? null : next(instance.subTree),
          suspense,
          isSVG,
          optimized
        );
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense2, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(
          suspense.activeBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
      if (suspense.pendingBranch) {
        unmount(
          suspense.pendingBranch,
          parentComponent,
          parentSuspense2,
          doRemove
        );
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(
    vnode,
    parentSuspense,
    parentComponent,
    node.parentNode,
    document.createElement("div"),
    null,
    isSVG,
    slotScopeIds,
    optimized,
    rendererInternals,
    true
    /* hydrating */
  );
  const result = hydrateNode(
    node,
    suspense.pendingBranch = vnode.ssContent,
    parentComponent,
    suspense,
    slotScopeIds,
    optimized
  );
  if (suspense.deps === 0) {
    suspense.resolve(false, true);
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(
    isSlotChildren ? children.default : children
  );
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block2;
  if (isFunction(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block2 = currentBlock;
      closeBlock();
    }
  }
  if (isArray$1(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block2 && !s.dynamicChildren) {
    s.dynamicChildren = block2.filter((c2) => c2 !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function isVNodeSuspensible(vnode) {
  var _a;
  return ((_a = vnode.props) == null ? void 0 : _a.suspensible) != null && vnode.props.suspensible !== false;
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "post" }
  );
}
function watchSyncEffect(effect2, options) {
  return doWatch(
    effect2,
    null,
    { flush: "sync" }
  );
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  var _a;
  const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(
          source,
          instance,
          3,
          [onCleanup]
        );
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(
      effect2.run.bind(effect2),
      instance && instance.suspense
    );
  } else {
    effect2.run();
  }
  const unwatch = () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$1(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (dir) {
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey$1 = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props2, { slots }) {
    const instance = getCurrentInstance$1();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props2);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance
      );
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props2, state, instance) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props2;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey$1] = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey$1] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey$1]) {
        el[enterCbKey$1](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props2, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent$1(options, extraOptions) {
  return isFunction(options) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineAsyncComponent(source) {
  if (isFunction(source)) {
    source = { loader: source };
  }
  const {
    loader: loader2,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    // undefined = never times out
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader2().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return /* @__PURE__ */ defineComponent$1({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(
          err,
          instance,
          13,
          !errorComponent
          /* do not throw in dev if user provided error component */
        );
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(
              `Async component timed out after ${timeout}ms.`
            );
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, parent) {
  const { ref: ref2, props: props2, children, ce: ce2 } = parent.vnode;
  const vnode = createVNode(comp, props2, children);
  vnode.ref = ref2;
  vnode.ce = ce2;
  delete parent.vnode.ce;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props2, { slots }) {
    const instance = getCurrentInstance$1();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const {
      renderer: {
        p: patch,
        m: move,
        um: _unmount,
        o: { createElement }
      }
    } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(
        instance2.vnode,
        vnode,
        container,
        anchor,
        instance2,
        parentSuspense,
        isSVG,
        vnode.slotScopeIds,
        optimized
      );
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || !isSameVNodeType(cached, current)) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys.delete(key);
    }
    watch(
      () => [props2.include, props2.exclude],
      ([include, exclude]) => {
        include && pruneCache((name) => matches(include, name));
        exclude && pruneCache((name) => !matches(exclude, name));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: true }
    );
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type && cached.key === vnode.key) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(
        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp
      );
      const { include, exclude, max } = props2;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys.delete(key);
        keys.add(key);
      } else {
        keys.add(key);
        if (max && keys.size > parseInt(max, 10)) {
          pruneCacheEntry(keys.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$1(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString(pattern)) {
    return pattern.split(",").includes(name);
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  vnode.shapeFlag &= ~256;
  vnode.shapeFlag &= ~512;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook(
  "rtg"
);
const onRenderTracked = createHook(
  "rtc"
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$1(source) || isString(source)) {
    ret = new Array(source.length);
    for (let i = 0, l2 = source.length; i < l2; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i) => renderItem(item, i, void 0, cached && cached[i])
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l2 = keys.length; i < l2; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$1(slot)) {
      for (let j2 = 0; j2 < slot.length; j2++) {
        slots[slot[j2].name] = slot[j2].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props2 = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name !== "default")
      props2.name = name;
    return createVNode("slot", props2, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode$1(slot(props2));
  const rendered = createBlock(
    Fragment,
    {
      key: props2.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      validSlotContent && validSlotContent.key || `_${name}`
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode$1(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode$1(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => i.props,
    $attrs: (i) => i.attrs,
    $slots: (i) => i.slots,
    $refs: (i) => i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props: props2, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props2[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props2[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(
  {},
  PublicInstanceProxyHandlers,
  {
    get(target, key) {
      if (key === Symbol.unscopables) {
        return;
      }
      return PublicInstanceProxyHandlers.get(target, key, target);
    },
    has(_, key) {
      const has2 = key[0] !== "_" && !isGloballyAllowed(key);
      return has2;
    }
  }
);
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function defineOptions(options) {
}
function defineSlots() {
  return null;
}
function defineModel() {
}
function withDefaults(props2, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs() {
  return getContext().attrs;
}
function useModel(props2, name, options) {
  const i = getCurrentInstance$1();
  if (options && options.local) {
    const proxy = ref(props2[name]);
    watch(
      () => props2[name],
      (v) => proxy.value = v
    );
    watch(proxy, (value) => {
      if (value !== props2[name]) {
        i.emit(`update:${name}`, value);
      }
    });
    return proxy;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return props2[name];
      },
      set value(value) {
        i.emit(`update:${name}`, value);
      }
    };
  }
}
function getContext() {
  const i = getCurrentInstance$1();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function normalizePropsOrEmits(props2) {
  return isArray$1(props2) ? props2.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props2;
}
function mergeDefaults(raw, defaults) {
  const props2 = normalizePropsOrEmits(raw);
  for (const key in defaults) {
    if (key.startsWith("__skip"))
      continue;
    let opt = props2[key];
    if (opt) {
      if (isArray$1(opt) || isFunction(opt)) {
        opt = props2[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      opt = props2[key] = { default: defaults[key] };
    } else
      ;
    if (opt && defaults[`__skip_${key}`]) {
      opt.skipFactory = true;
    }
  }
  return props2;
}
function mergeModels(a, b) {
  if (!a || !b)
    return a || b;
  if (isArray$1(a) && isArray$1(b))
    return a.concat(b);
  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));
}
function createPropsRestProxy(props2, excludedKeys) {
  const ret = {};
  for (const key in props2) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props2[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance$1();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount: beforeMount2,
    mounted: mounted2,
    beforeUpdate,
    updated: updated2,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted: unmounted2,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount2);
  registerLifecycleHook(onMounted, mounted2);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated2);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted2);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject$1(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v) => injected.value = v
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$1(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m) => mergeOptions$1(resolved, m, optionMergeStrategies, true)
      );
    }
    mergeOptions$1(resolved, base, optionMergeStrategies);
  }
  if (isObject$1(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions$1(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions$1(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m) => mergeOptions$1(to, m, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction(to) ? to.call(this, this) : to,
      isFunction(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$1(to) && isArray$1(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app2, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app2;
      },
      directive(name, directive2) {
        if (!directive2) {
          return context.directives[name];
        }
        context.directives[name] = directive2;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      },
      runWithContext(fn) {
        currentApp = app2;
        try {
          return fn();
        } finally {
          currentApp = null;
        }
      }
    };
    return app2;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else
      ;
  }
}
function hasInjectionContext() {
  return !!(currentInstance || currentRenderingInstance || currentApp);
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props2 = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props2, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props2)) {
      props2[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props2 : shallowReactive(props2);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props2;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props: props2,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props2);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props2[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props2, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props2[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props2[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props2, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props2[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props2);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props2[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props2, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props2
          );
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props2, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props2);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$1(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$1(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot$1 = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot$1(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(
        children,
        instance.slots = {}
      );
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r2, i) => setRef(
        r2,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const {
    mt: mountComponent,
    p: patch,
    o: {
      patchProp: patchProp2,
      createText,
      nextSibling,
      parentNode,
      remove: remove2,
      insert,
      createComment
    }
  } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(
      node,
      vnode,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      isFragmentStart
    );
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    let domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (isTemplateNode(node)) {
          nextNode = nextSibling(node);
          replaceNode(
            vnode.el = node.content.firstChild,
            node,
            parentComponent
          );
        } else if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (isFragmentStart) {
          node = nextSibling(node);
          domType = node.nodeType;
        }
        if (domType === 1 || domType === 3) {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return isFragmentStart ? nextSibling(nextNode) : nextNode;
        } else {
          onMismatch();
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
        break;
      default:
        if (shapeFlag & 1) {
          if ((domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          if (isFragmentStart) {
            nextNode = locateClosingAnchor(node);
          } else if (isComment(node) && node.data === "teleport start") {
            nextNode = locateClosingAnchor(node, node.data, "teleport end");
          } else {
            nextNode = nextSibling(node);
          }
          mountComponent(
            vnode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVGContainer(container),
            optimized
          );
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(
              node,
              vnode,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized,
              rendererInternals,
              hydrateChildren
            );
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(
            node,
            vnode,
            parentComponent,
            parentSuspense,
            isSVGContainer(parentNode(node)),
            slotScopeIds,
            optimized,
            rendererInternals,
            hydrateNode
          );
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props: props2, patchFlag, shapeFlag, dirs, transition } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props2) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props2) {
            if (forcePatchValue && key.endsWith("value") || isOn$1(key) && !isReservedProp(key)) {
              patchProp2(
                el,
                key,
                null,
                props2[key],
                false,
                void 0,
                parentComponent
              );
            }
          }
        } else if (props2.onClick) {
          patchProp2(
            el,
            "onClick",
            null,
            props2.onClick,
            false,
            void 0,
            parentComponent
          );
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props2 && props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      let needCallTransitionHooks = false;
      if (isTemplateNode(el)) {
        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;
        const content = el.content.firstChild;
        if (needCallTransitionHooks) {
          transition.beforeEnter(content);
        }
        replaceNode(content, el, parentComponent);
        vnode.el = el = content;
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props2 && props2.onVnodeMounted) || dirs || needCallTransitionHooks) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && // skip if element has innerHTML / textContent
      !(props2 && (props2.innerHTML || props2.textContent))) {
        let next = hydrateChildren(
          el.firstChild,
          vnode,
          el,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l2 = children.length;
    for (let i = 0; i < l2; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(
          node,
          vnode,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(
          null,
          vnode,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVGContainer(container),
          slotScopeIds
        );
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(
      nextSibling(node),
      vnode,
      container,
      parentComponent,
      parentSuspense,
      slotScopeIds,
      optimized
    );
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(
      null,
      vnode,
      container,
      next,
      parentComponent,
      parentSuspense,
      isSVGContainer(container),
      slotScopeIds
    );
    return next;
  };
  const locateClosingAnchor = (node, open = "[", close = "]") => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === open)
          match++;
        if (node.data === close) {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  const replaceNode = (newNode, oldNode, parentComponent) => {
    const parentNode2 = oldNode.parentNode;
    if (parentNode2) {
      parentNode2.replaceChild(newNode, oldNode);
    }
    let parent = parentComponent;
    while (parent) {
      if (parent.vnode.el === oldNode) {
        parent.vnode.el = parent.subTree.el = newNode;
      }
      parent = parent.parent;
    }
  };
  const isTemplateNode = (node) => {
    return node.nodeType === 1 && node.tagName.toLowerCase() === "template";
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          );
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      isSVG,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props: props2, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      isSVG,
      props2 && props2.is,
      props2
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        isSVG && type !== "foreignObject",
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props2) {
      for (const key in props2) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(
            el,
            key,
            null,
            props2[key],
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in props2) {
        hostPatchProp(el, "value", null, props2.value);
      }
      if (vnodeHook = props2.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        areChildrenSVG,
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          isSVG
        );
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                n1.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(
        el,
        n2,
        oldProps,
        newProps,
        parentComponent,
        parentSuspense,
        isSVG
      );
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              isSVG,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(
            el,
            key,
            prev,
            next,
            isSVG,
            vnode.children,
            parentComponent,
            parentSuspense,
            unmountChildren
          );
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        n2.children,
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          isSVG,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(
      instance,
      initialVNode,
      container,
      anchor,
      parentSuspense,
      isSVG,
      optimized
    );
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props: props2 } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(
              el,
              instance.subTree,
              instance,
              parentSuspense,
              null
            );
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            isSVG
          );
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(
        c1[i],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        isSVG,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(
            null,
            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j2;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j2 = s2; j2 <= e2; j2++) {
            if (newIndexToOldIndexMap[j2 - s2] === 0 && isSameVNodeType(prevChild, c2[j2])) {
              newIndex = j2;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j2 = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j2 < 0 || i !== increasingNewIndexSequence[j2]) {
            move(nextChild, container, anchor, 2);
          } else {
            j2--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props: props2,
      ref: ref2,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs
    } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          optimized,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(
      internals
    );
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j2, u, v, c2;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j2 = result[result.length - 1];
      if (arr[j2] < arrI) {
        p2[i] = j2;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c2 = u + v >> 1;
        if (arr[result[c2]] < arrI) {
          u = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props2, select) => {
  const targetSelector = props2 && props2.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props: props2 } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props2);
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props: props2 } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props2)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(
          children[i],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(
          targetNode,
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node && node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props2, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props2,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
      /* isBlock */
    )
  );
}
function createBlock(type, props2, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props2,
      children,
      patchFlag,
      dynamicProps,
      true
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref2,
  ref_key,
  ref_for
}) => {
  if (typeof ref2 === "number") {
    ref2 = "" + ref2;
  }
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props: props2,
    key: props2 && normalizeKey(props2),
    ref: props2 && normalizeRef(props2),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props2,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props2) {
    props2 = guardReactiveProps(props2);
    let { class: klass, style: style3 } = props2;
    if (klass && !isString(klass)) {
      props2.class = normalizeClass(klass);
    }
    if (isObject$1(style3)) {
      if (isProxy(style3) && !isArray$1(style3)) {
        style3 = extend({}, style3);
      }
      props2.style = normalizeStyle(style3);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props2,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props2) {
  if (!props2)
    return null;
  return isProxy(props2) || InternalObjectKey in props2 ? extend({}, props2) : props2;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props: props2, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray$1(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn$1(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$2 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$2++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance$1 = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let globalCurrentInstanceSetters;
let settersKey = "__VUE_INSTANCE_SETTERS__";
{
  if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
    globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
  }
  globalCurrentInstanceSetters.push((i) => currentInstance = i);
  internalSetCurrentInstance = (instance) => {
    if (globalCurrentInstanceSetters.length > 1) {
      globalCurrentInstanceSetters.forEach((s) => s(instance));
    } else {
      globalCurrentInstanceSetters[0](instance);
    }
  };
}
const setCurrentInstance = (instance) => {
  internalSetCurrentInstance(instance);
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props: props2, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props2, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [instance.props, setupContext]
    );
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(
          extend(
            {
              isCustomElement,
              delimiters
            },
            compilerOptions
          ),
          componentCompilerOptions
        );
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      unsetCurrentInstance();
    }
  }
}
function getAttrsProxy(instance) {
  return instance.attrsProxy || (instance.attrsProxy = new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      }
    }
  ));
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      get attrs() {
        return getAttrsProxy(instance);
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function h(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$1(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index2) {
  const cached = cache[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index2] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version$1 = "3.3.8";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props2) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props2 && props2.multiple != null) {
      el.setAttribute("multiple", props2.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const Transition = (props2, { slots }) => h(BaseTransition, resolveTransitionProps(props2), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  if (s === "auto")
    return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOldKey = Symbol("_vod");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOldKey] : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
function patchStyle(el, prev, next) {
  const style3 = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style3, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style3, key, next[key]);
    }
  } else {
    const currentDisplay = style3.display;
    if (isCssString) {
      if (prev !== next) {
        style3.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if (vShowOldKey in el) {
      style3.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style3, name, val) {
  if (isArray$1(val)) {
    val.forEach((v) => setStyle(style3, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style3.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style3, name);
      if (importantRE.test(val)) {
        style3.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style3[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style3, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style3) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style3) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean = isSpecialBooleanAttr(key);
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    el._value = value;
    const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
    const newValue = value == null ? "" : value;
    if (oldValue !== newValue) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$1(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn$1(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(
      el,
      key,
      nextValue,
      prevChildren,
      parentComponent,
      parentSuspense,
      unmountChildren
    );
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineCustomElement(options, hydrate2) {
  const Comp = /* @__PURE__ */ defineComponent$1(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
/*! #__NO_SIDE_EFFECTS__ */
const defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {
  return /* @__PURE__ */ defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    this._ob = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
      if (!this._def.__asyncLoader) {
        this._resolveProps(this._def);
      }
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      if (this._resolved) {
        this._update();
      } else {
        this._resolveDef();
      }
    }
  }
  disconnectedCallback() {
    this._connected = false;
    if (this._ob) {
      this._ob.disconnect();
      this._ob = null;
    }
    nextTick(() => {
      if (!this._connected) {
        render$2(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    this._ob = new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    });
    this._ob.observe(this, { attributes: true });
    const resolve2 = (def2, isAsync = false) => {
      const { props: props2, styles } = def2;
      let numberProps;
      if (props2 && !isArray$1(props2)) {
        for (const key in props2) {
          const opt = props2[key];
          if (opt === Number || opt && opt.type === Number) {
            if (key in this._props) {
              this._props[key] = toNumber(this._props[key]);
            }
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize(key)] = true;
          }
        }
      }
      this._numberProps = numberProps;
      if (isAsync) {
        this._resolveProps(def2);
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then((def2) => resolve2(def2, true));
    } else {
      resolve2(this._def);
    }
  }
  _resolveProps(def2) {
    const { props: props2 } = def2;
    const declaredPropKeys = isArray$1(props2) ? props2 : Object.keys(props2 || {});
    for (const key of Object.keys(this)) {
      if (key[0] !== "_" && declaredPropKeys.includes(key)) {
        this._setProp(key, this[key], true, false);
      }
    }
    for (const key of declaredPropKeys.map(camelize)) {
      Object.defineProperty(this, key, {
        get() {
          return this._getProp(key);
        },
        set(val) {
          this._setProp(key, val);
        }
      });
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    const camelKey = camelize(key);
    if (this._numberProps && this._numberProps[camelKey]) {
      value = toNumber(value);
    }
    this._setProp(camelKey, value, false);
  }
  /**
   * @internal
   */
  _getProp(key) {
    return this._props[key];
  }
  /**
   * @internal
   */
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render$2(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        const dispatch = (event, args) => {
          this.dispatchEvent(
            new CustomEvent(event, {
              detail: args
            })
          );
        };
        instance.emit = (event, ...args) => {
          dispatch(event, args);
          if (hyphenate(event) !== event) {
            dispatch(hyphenate(event), args);
          }
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            instance.provides = parent._instance.provides;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance$1();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance$1();
  if (!instance) {
    return;
  }
  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
    ).forEach((node) => setVarsOnNode(node, vars));
  };
  const setVars = () => {
    const vars = getter(instance.proxy);
    setVarsOnVNode(instance.subTree, vars);
    updateTeleports(vars);
  };
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c2) => setVarsOnVNode(c2, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style3 = el.style;
    for (const key in vars) {
      style3.setProperty(`--${key}`, vars[key]);
    }
  }
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const moveCbKey = Symbol("_moveCb");
const enterCbKey = Symbol("_enterCb");
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props2, { slots }) {
    const instance = getCurrentInstance$1();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
      if (!hasCSSTransform(
        prevChildren[0].el,
        instance.vnode.el,
        moveClass
      )) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el = c2.el;
        const style3 = el.style;
        addTransitionClass(el, moveClass);
        style3.transform = style3.webkitTransform = style3.transitionDuration = "";
        const cb = el[moveCbKey] = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el[moveCbKey] = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props2);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(
            child,
            resolveTransitionHooks(child, cssTransitionProps, state, instance)
          );
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props2) => delete props2.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el = c2.el;
  if (el[moveCbKey]) {
    el[moveCbKey]();
  }
  if (el[enterCbKey]) {
    el[enterCbKey]();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c2.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el, root, moveClass) {
  const clone = el.cloneNode();
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && looseToNumber(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  // #4096 array checkboxes need to be deep traversed
  deep: true,
  created(el, _, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue(el);
      const checked = el.checked;
      const assign2 = el[assignKey];
      if (isArray$1(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign2(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign2(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign2(cloned);
      } else {
        assign2(getCheckboxValue(el, checked));
      }
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$1(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el[assignKey] = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el[assignKey](getValue(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  // <select multiple> value need to be deep traversed
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(
        (o) => number ? looseToNumber(getValue(o)) : getValue(o)
      );
      el[assignKey](
        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]
      );
    });
    el[assignKey] = getModelAssigner(vnode);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el[assignKey] = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$1(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l2 = el.options.length; i < l2; i++) {
    const option = el.options[i];
    const optionValue = getValue(option);
    if (isMultiple) {
      if (isArray$1(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(
    el.tagName,
    vnode.props && vnode.props.type
  );
  const fn = modelToUse[hook];
  fn && fn(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$1(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      vnode.type.toUpperCase(),
      vnode.props && vnode.props.type
    );
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn(event);
    }
  };
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render$2 = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
const createSSRApp = (...args) => {
  const app2 = ensureHydrationRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const compile = () => {
};
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  EffectScope,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  Transition,
  TransitionGroup,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent: defineComponent$1,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  get devtools() {
    return devtools;
  },
  effect,
  effectScope,
  getCurrentInstance: getCurrentInstance$1,
  getCurrentScope,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  initCustomFormatter,
  initDirectivesForSSR,
  inject: inject$1,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$2,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs,
  toValue,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useModel,
  useSSRContext,
  useSlots,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version: version$1,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
const main = "";
function useToggleScope(source, fn) {
  let scope;
  function start() {
    scope = effectScope();
    scope.run(() => fn.length ? fn(() => {
      scope?.stop();
      start();
    }) : fn());
  }
  watch(source, (active) => {
    if (active && !scope) {
      start();
    } else if (!active) {
      scope?.stop();
      scope = void 0;
    }
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    scope?.stop();
  });
}
const IN_BROWSER = typeof window !== "undefined";
const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}
function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}
function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
function getNestedValue(obj, path, fallback) {
  const last = path.length - 1;
  if (last < 0)
    return obj === void 0 ? fallback : obj;
  for (let i = 0; i < last; i++) {
    if (obj == null) {
      return fallback;
    }
    obj = obj[path[i]];
  }
  if (obj == null)
    return fallback;
  return obj[path[last]] === void 0 ? fallback : obj[path[last]];
}
function deepEqual$1(a, b) {
  if (a === b)
    return true;
  if (a instanceof Date && b instanceof Date && a.getTime() !== b.getTime()) {
    return false;
  }
  if (a !== Object(a) || b !== Object(b)) {
    return false;
  }
  const props2 = Object.keys(a);
  if (props2.length !== Object.keys(b).length) {
    return false;
  }
  return props2.every((p2) => deepEqual$1(a[p2], b[p2]));
}
function getObjectValueByPath(obj, path, fallback) {
  if (obj == null || !path || typeof path !== "string")
    return fallback;
  if (obj[path] !== void 0)
    return obj[path];
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  return getNestedValue(obj, path.split("."), fallback);
}
function getPropertyFromItem(item, property, fallback) {
  if (property === true)
    return item === void 0 ? fallback : item;
  if (property == null || typeof property === "boolean")
    return fallback;
  if (item !== Object(item)) {
    if (typeof property !== "function")
      return fallback;
    const value2 = property(item, fallback);
    return typeof value2 === "undefined" ? fallback : value2;
  }
  if (typeof property === "string")
    return getObjectValueByPath(item, property, fallback);
  if (Array.isArray(property))
    return getNestedValue(item, property, fallback);
  if (typeof property !== "function")
    return fallback;
  const value = property(item, fallback);
  return typeof value === "undefined" ? fallback : value;
}
function createRange(length) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length
  }, (v, k2) => start + k2);
}
function convertToUnit(str) {
  let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (str == null || str === "") {
    return void 0;
  } else if (isNaN(+str)) {
    return String(str);
  } else if (!isFinite(+str)) {
    return void 0;
  } else {
    return `${Number(str)}${unit}`;
  }
}
function isObject(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
function refElement(obj) {
  if (obj && "$el" in obj) {
    const el = obj.$el;
    if (el?.nodeType === Node.TEXT_NODE) {
      return el.nextElementSibling;
    }
    return el;
  }
  return obj;
}
const keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
const keyValues = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function has(obj, key) {
  return key.every((k2) => obj.hasOwnProperty(k2));
}
function pick(obj, paths) {
  const found = {};
  const keys = new Set(Object.keys(obj));
  for (const path of paths) {
    if (keys.has(path)) {
      found[path] = obj[path];
    }
  }
  return found;
}
function pickWithRest(obj, paths, exclude) {
  const found = /* @__PURE__ */ Object.create(null);
  const rest = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    if (paths.some((path) => path instanceof RegExp ? path.test(key) : path === key) && !exclude?.some((path) => path === key)) {
      found[key] = obj[key];
    } else {
      rest[key] = obj[key];
    }
  }
  return [found, rest];
}
function omit(obj, exclude) {
  const clone = {
    ...obj
  };
  exclude.forEach((prop) => delete clone[prop]);
  return clone;
}
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const bubblingEvents = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"];
const compositionIgnoreKeys = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function isComposingIgnoreKey(e) {
  return e.isComposing && compositionIgnoreKeys.includes(e.key);
}
function filterInputAttrs(attrs) {
  const [events, props2] = pickWithRest(attrs, [onRE]);
  const inputEvents = omit(events, bubblingEvents);
  const [rootAttrs, inputAttrs] = pickWithRest(props2, ["class", "style", "id", /^data-/]);
  Object.assign(rootAttrs, events);
  Object.assign(inputAttrs, inputEvents);
  return [rootAttrs, inputAttrs];
}
function wrapInArray(v) {
  return v == null ? [] : Array.isArray(v) ? v : [v];
}
function debounce(fn, delay) {
  let timeoutId = 0;
  const wrap = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), unref(delay));
  };
  wrap.clear = () => {
    clearTimeout(timeoutId);
  };
  wrap.immediate = fn;
  return wrap;
}
function clamp(value) {
  let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(min, Math.min(max, value));
}
function padEnd(str, length) {
  let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return str + char.repeat(Math.max(0, length - str.length));
}
function padStart(str, length) {
  let char = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return char.repeat(Math.max(0, length - str.length)) + str;
}
function chunk(str) {
  let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const chunked = [];
  let index2 = 0;
  while (index2 < str.length) {
    chunked.push(str.substr(index2, size2));
    index2 += size2;
  }
  return chunked;
}
function humanReadableFileSize(bytes) {
  let base = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (bytes < base) {
    return `${bytes} B`;
  }
  const prefix = base === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let unit = -1;
  while (Math.abs(bytes) >= base && unit < prefix.length - 1) {
    bytes /= base;
    ++unit;
  }
  return `${bytes.toFixed(1)} ${prefix[unit]}B`;
}
function mergeDeep() {
  let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
  const out = {};
  for (const key in source) {
    out[key] = source[key];
  }
  for (const key in target) {
    const sourceProperty = source[key];
    const targetProperty = target[key];
    if (isObject(sourceProperty) && isObject(targetProperty)) {
      out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
      continue;
    }
    if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
      out[key] = arrayFn(sourceProperty, targetProperty);
      continue;
    }
    out[key] = targetProperty;
  }
  return out;
}
function flattenFragments(nodes) {
  return nodes.map((node) => {
    if (node.type === Fragment) {
      return flattenFragments(node.children);
    } else {
      return node;
    }
  }).flat();
}
function toKebabCase() {
  let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (toKebabCase.cache.has(str))
    return toKebabCase.cache.get(str);
  const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  toKebabCase.cache.set(str, kebab);
  return kebab;
}
toKebabCase.cache = /* @__PURE__ */ new Map();
function findChildrenWithProvide(key, vnode) {
  if (!vnode || typeof vnode !== "object")
    return [];
  if (Array.isArray(vnode)) {
    return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
  } else if (Array.isArray(vnode.children)) {
    return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
  } else if (vnode.component) {
    if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
      return [vnode.component];
    } else if (vnode.component.subTree) {
      return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
    }
  }
  return [];
}
var _arr = /* @__PURE__ */ new WeakMap();
var _pointer = /* @__PURE__ */ new WeakMap();
class CircularBuffer {
  constructor(size2) {
    _classPrivateFieldInitSpec(this, _arr, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec(this, _pointer, {
      writable: true,
      value: 0
    });
    this.size = size2;
  }
  push(val) {
    _classPrivateFieldGet(this, _arr)[_classPrivateFieldGet(this, _pointer)] = val;
    _classPrivateFieldSet(this, _pointer, (_classPrivateFieldGet(this, _pointer) + 1) % this.size);
  }
  values() {
    return _classPrivateFieldGet(this, _arr).slice(_classPrivateFieldGet(this, _pointer)).concat(_classPrivateFieldGet(this, _arr).slice(0, _classPrivateFieldGet(this, _pointer)));
  }
}
function destructComputed(getter) {
  const refs = reactive({});
  const base = computed(getter);
  watchEffect(() => {
    for (const key in base.value) {
      refs[key] = base.value[key];
    }
  }, {
    flush: "sync"
  });
  return toRefs(refs);
}
function includes(arr, val) {
  return arr.includes(val);
}
function eventName(propName) {
  return propName[2].toLowerCase() + propName.slice(3);
}
const EventProp = () => [Function, Array];
function hasEvent(props2, name) {
  name = "on" + capitalize(name);
  return !!(props2[name] || props2[`${name}Once`] || props2[`${name}Capture`] || props2[`${name}OnceCapture`] || props2[`${name}CaptureOnce`]);
}
function callEvent(handler) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  if (Array.isArray(handler)) {
    for (const h2 of handler) {
      h2(...args);
    }
  } else if (typeof handler === "function") {
    handler(...args);
  }
}
function focusableChildren(el) {
  let filterByTabIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  const targets = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((s) => `${s}${filterByTabIndex ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...el.querySelectorAll(targets)];
}
function getNextElement(elements, location2, condition) {
  let _el;
  let idx = elements.indexOf(document.activeElement);
  const inc = location2 === "next" ? 1 : -1;
  do {
    idx += inc;
    _el = elements[idx];
  } while ((!_el || _el.offsetParent == null || !(condition?.(_el) ?? true)) && idx < elements.length && idx >= 0);
  return _el;
}
function focusChild(el, location2) {
  const focusable = focusableChildren(el);
  if (!location2) {
    if (el === document.activeElement || !el.contains(document.activeElement)) {
      focusable[0]?.focus();
    }
  } else if (location2 === "first") {
    focusable[0]?.focus();
  } else if (location2 === "last") {
    focusable.at(-1)?.focus();
  } else if (typeof location2 === "number") {
    focusable[location2]?.focus();
  } else {
    const _el = getNextElement(focusable, location2);
    if (_el)
      _el.focus();
    else
      focusChild(el, location2 === "next" ? "first" : "last");
  }
}
function isEmpty(val) {
  return val === null || val === void 0 || typeof val === "string" && val.trim() === "";
}
function noop$1() {
}
function matchesSelector(el, selector) {
  const supportsSelector = IN_BROWSER && typeof CSS !== "undefined" && typeof CSS.supports !== "undefined" && CSS.supports(`selector(${selector})`);
  if (!supportsSelector)
    return null;
  try {
    return !!el && el.matches(selector);
  } catch (err) {
    return null;
  }
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    return child.type !== Fragment || ensureValidVNode(child.children);
  }) ? vnodes : null;
}
function defer(timeout, cb) {
  if (!IN_BROWSER || timeout === 0) {
    cb();
    return () => {
    };
  }
  const timeoutId = window.setTimeout(cb, timeout);
  return () => window.clearTimeout(timeoutId);
}
const block = ["top", "bottom"];
const inline = ["start", "end", "left", "right"];
function parseAnchor(anchor, isRtl) {
  let [side, align] = anchor.split(" ");
  if (!align) {
    align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
  }
  return {
    side: toPhysical(side, isRtl),
    align: toPhysical(align, isRtl)
  };
}
function toPhysical(str, isRtl) {
  if (str === "start")
    return isRtl ? "right" : "left";
  if (str === "end")
    return isRtl ? "left" : "right";
  return str;
}
function flipSide(anchor) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.side],
    align: anchor.align
  };
}
function flipAlign(anchor) {
  return {
    side: anchor.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.align]
  };
}
function flipCorner(anchor) {
  return {
    side: anchor.align,
    align: anchor.side
  };
}
function getAxis(anchor) {
  return includes(block, anchor.side) ? "y" : "x";
}
class Box {
  constructor(_ref) {
    let {
      x: x2,
      y,
      width,
      height
    } = _ref;
    this.x = x2;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function getOverflow(a, b) {
  return {
    x: {
      before: Math.max(0, b.left - a.left),
      after: Math.max(0, a.right - b.right)
    },
    y: {
      before: Math.max(0, b.top - a.top),
      after: Math.max(0, a.bottom - b.bottom)
    }
  };
}
function getTargetBox(target) {
  if (Array.isArray(target)) {
    return new Box({
      x: target[0],
      y: target[1],
      width: 0,
      height: 0
    });
  } else {
    return target.getBoundingClientRect();
  }
}
function nullifyTransforms(el) {
  const rect = el.getBoundingClientRect();
  const style3 = getComputedStyle(el);
  const tx = style3.transform;
  if (tx) {
    let ta, sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return new Box(rect);
    }
    const to = style3.transformOrigin;
    const x2 = rect.x - dx - (1 - sx) * parseFloat(to);
    const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    const w = sx ? rect.width / sx : el.offsetWidth + 1;
    const h2 = sy ? rect.height / sy : el.offsetHeight + 1;
    return new Box({
      x: x2,
      y,
      width: w,
      height: h2
    });
  } else {
    return new Box(rect);
  }
}
function animate(el, keyframes, options) {
  if (typeof el.animate === "undefined")
    return {
      finished: Promise.resolve()
    };
  let animation;
  try {
    animation = el.animate(keyframes, options);
  } catch (err) {
    return {
      finished: Promise.resolve()
    };
  }
  if (typeof animation.finished === "undefined") {
    animation.finished = new Promise((resolve2) => {
      animation.onfinish = () => {
        resolve2(animation);
      };
    });
  }
  return animation;
}
const handlers = /* @__PURE__ */ new WeakMap();
function bindProps(el, props2) {
  Object.keys(props2).forEach((k2) => {
    if (isOn(k2)) {
      const name = eventName(k2);
      const handler = handlers.get(el);
      if (props2[k2] == null) {
        handler?.forEach((v) => {
          const [n, fn] = v;
          if (n === name) {
            el.removeEventListener(name, fn);
            handler.delete(v);
          }
        });
      } else if (!handler || ![...handler]?.some((v) => v[0] === name && v[1] === props2[k2])) {
        el.addEventListener(name, props2[k2]);
        const _handler = handler || /* @__PURE__ */ new Set();
        _handler.add([name, props2[k2]]);
        if (!handlers.has(el))
          handlers.set(el, _handler);
      }
    } else {
      if (props2[k2] == null) {
        el.removeAttribute(k2);
      } else {
        el.setAttribute(k2, props2[k2]);
      }
    }
  });
}
function unbindProps(el, props2) {
  Object.keys(props2).forEach((k2) => {
    if (isOn(k2)) {
      const name = eventName(k2);
      const handler = handlers.get(el);
      handler?.forEach((v) => {
        const [n, fn] = v;
        if (n === name) {
          el.removeEventListener(name, fn);
          handler.delete(v);
        }
      });
    } else {
      el.removeAttribute(k2);
    }
  });
}
const mainTRC = 2.4;
const Rco = 0.2126729;
const Gco = 0.7151522;
const Bco = 0.072175;
const normBG = 0.55;
const normTXT = 0.58;
const revTXT = 0.57;
const revBG = 0.62;
const blkThrs = 0.03;
const blkClmp = 1.45;
const deltaYmin = 5e-4;
const scaleBoW = 1.25;
const scaleWoB = 1.25;
const loConThresh = 0.078;
const loConFactor = 12.82051282051282;
const loConOffset = 0.06;
const loClip = 1e-3;
function APCAcontrast(text, background) {
  const Rtxt = (text.r / 255) ** mainTRC;
  const Gtxt = (text.g / 255) ** mainTRC;
  const Btxt = (text.b / 255) ** mainTRC;
  const Rbg = (background.r / 255) ** mainTRC;
  const Gbg = (background.g / 255) ** mainTRC;
  const Bbg = (background.b / 255) ** mainTRC;
  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
  if (Ytxt <= blkThrs)
    Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs)
    Ybg += (blkThrs - Ybg) ** blkClmp;
  if (Math.abs(Ybg - Ytxt) < deltaYmin)
    return 0;
  let outputContrast;
  if (Ybg > Ytxt) {
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
    outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }
  return outputContrast * 100;
}
function consoleWarn(message) {
}
function consoleError(message) {
}
function deprecate(original, replacement) {
  replacement = Array.isArray(replacement) ? replacement.slice(0, -1).map((s) => `'${s}'`).join(", ") + ` or '${replacement.at(-1)}'` : `'${replacement}'`;
}
const delta = 0.20689655172413793;
const cielabForwardTransform = (t) => t > delta ** 3 ? Math.cbrt(t) : t / (3 * delta ** 2) + 4 / 29;
const cielabReverseTransform = (t) => t > delta ? t ** 3 : 3 * delta ** 2 * (t - 4 / 29);
function fromXYZ$1(xyz) {
  const transform2 = cielabForwardTransform;
  const transformedY = transform2(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
}
function toXYZ$1(lab) {
  const transform2 = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
}
const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
const srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
const srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
function fromXYZ(xyz) {
  const rgb = Array(3);
  const transform2 = srgbForwardTransform;
  const matrix = srgbForwardMatrix;
  for (let i = 0; i < 3; ++i) {
    rgb[i] = Math.round(clamp(transform2(matrix[i][0] * xyz[0] + matrix[i][1] * xyz[1] + matrix[i][2] * xyz[2])) * 255);
  }
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2]
  };
}
function toXYZ(_ref) {
  let {
    r: r2,
    g: g2,
    b
  } = _ref;
  const xyz = [0, 0, 0];
  const transform2 = srgbReverseTransform;
  const matrix = srgbReverseMatrix;
  r2 = transform2(r2 / 255);
  g2 = transform2(g2 / 255);
  b = transform2(b / 255);
  for (let i = 0; i < 3; ++i) {
    xyz[i] = matrix[i][0] * r2 + matrix[i][1] * g2 + matrix[i][2] * b;
  }
  return xyz;
}
function isCssColor(color) {
  return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
function isParsableColor(color) {
  return isCssColor(color) && !/^((rgb|hsl)a?\()?var\(--/.test(color);
}
const cssColorRe = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/;
const mappers = {
  rgb: (r2, g2, b, a) => ({
    r: r2,
    g: g2,
    b,
    a
  }),
  rgba: (r2, g2, b, a) => ({
    r: r2,
    g: g2,
    b,
    a
  }),
  hsl: (h2, s, l2, a) => HSLtoRGB({
    h: h2,
    s,
    l: l2,
    a
  }),
  hsla: (h2, s, l2, a) => HSLtoRGB({
    h: h2,
    s,
    l: l2,
    a
  }),
  hsv: (h2, s, v, a) => HSVtoRGB({
    h: h2,
    s,
    v,
    a
  }),
  hsva: (h2, s, v, a) => HSVtoRGB({
    h: h2,
    s,
    v,
    a
  })
};
function parseColor(color) {
  if (typeof color === "number") {
    return {
      r: (color & 16711680) >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  } else if (typeof color === "string" && cssColorRe.test(color)) {
    const {
      groups
    } = color.match(cssColorRe);
    const {
      fn,
      values
    } = groups;
    const realValues = values.split(/,\s*/).map((v) => {
      if (v.endsWith("%") && ["hsl", "hsla", "hsv", "hsva"].includes(fn)) {
        return parseFloat(v) / 100;
      } else {
        return parseFloat(v);
      }
    });
    return mappers[fn](...realValues);
  } else if (typeof color === "string") {
    let hex = color.startsWith("#") ? color.slice(1) : color;
    if ([3, 4].includes(hex.length)) {
      hex = hex.split("").map((char) => char + char).join("");
    } else if (![6, 8].includes(hex.length))
      ;
    return HexToRGB(hex);
  } else if (typeof color === "object") {
    if (has(color, ["r", "g", "b"])) {
      return color;
    } else if (has(color, ["h", "s", "l"])) {
      return HSVtoRGB(HSLtoHSV(color));
    } else if (has(color, ["h", "s", "v"])) {
      return HSVtoRGB(color);
    }
  }
  throw new TypeError(`Invalid color: ${color == null ? color : String(color) || color.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function HSVtoRGB(hsva) {
  const {
    h: h2,
    s,
    v,
    a
  } = hsva;
  const f = (n) => {
    const k2 = (n + h2 / 60) % 6;
    return v - v * s * Math.max(Math.min(k2, 4 - k2, 1), 0);
  };
  const rgb = [f(5), f(3), f(1)].map((v2) => Math.round(v2 * 255));
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2],
    a
  };
}
function HSLtoRGB(hsla) {
  return HSVtoRGB(HSLtoHSV(hsla));
}
function HSLtoHSV(hsl) {
  const {
    h: h2,
    s,
    l: l2,
    a
  } = hsl;
  const v = l2 + s * Math.min(l2, 1 - l2);
  const sprime = v === 0 ? 0 : 2 - 2 * l2 / v;
  return {
    h: h2,
    s: sprime,
    v,
    a
  };
}
function toHex(v) {
  const h2 = Math.round(v).toString(16);
  return ("00".substr(0, 2 - h2.length) + h2).toUpperCase();
}
function RGBtoHex(_ref2) {
  let {
    r: r2,
    g: g2,
    b,
    a
  } = _ref2;
  return `#${[toHex(r2), toHex(g2), toHex(b), a !== void 0 ? toHex(Math.round(a * 255)) : ""].join("")}`;
}
function HexToRGB(hex) {
  hex = parseHex(hex);
  let [r2, g2, b, a] = chunk(hex, 2).map((c2) => parseInt(c2, 16));
  a = a === void 0 ? a : a / 255;
  return {
    r: r2,
    g: g2,
    b,
    a
  };
}
function parseHex(hex) {
  if (hex.startsWith("#")) {
    hex = hex.slice(1);
  }
  hex = hex.replace(/([^0-9a-f])/gi, "F");
  if (hex.length === 3 || hex.length === 4) {
    hex = hex.split("").map((x2) => x2 + x2).join("");
  }
  if (hex.length !== 6) {
    hex = padEnd(padEnd(hex, 6), 8, "F");
  }
  return hex;
}
function lighten(value, amount) {
  const lab = fromXYZ$1(toXYZ(value));
  lab[0] = lab[0] + amount * 10;
  return fromXYZ(toXYZ$1(lab));
}
function darken(value, amount) {
  const lab = fromXYZ$1(toXYZ(value));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ(toXYZ$1(lab));
}
function getLuma(color) {
  const rgb = parseColor(color);
  return toXYZ(rgb)[1];
}
function getForeground(color) {
  const blackContrast = Math.abs(APCAcontrast(parseColor(0), parseColor(color)));
  const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), parseColor(color)));
  return whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
}
function propsFactory(props2, source) {
  return (defaults) => {
    return Object.keys(props2).reduce((obj, prop) => {
      const isObjectDefinition = typeof props2[prop] === "object" && props2[prop] != null && !Array.isArray(props2[prop]);
      const definition = isObjectDefinition ? props2[prop] : {
        type: props2[prop]
      };
      if (defaults && prop in defaults) {
        obj[prop] = {
          ...definition,
          default: defaults[prop]
        };
      } else {
        obj[prop] = definition;
      }
      if (source && !obj[prop].source) {
        obj[prop].source = source;
      }
      return obj;
    }, {});
  };
}
const makeComponentProps = propsFactory({
  class: [String, Array],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
const DefaultsSymbol = Symbol.for("vuetify:defaults");
function createDefaults(options) {
  return ref(options);
}
function injectDefaults() {
  const defaults = inject$1(DefaultsSymbol);
  if (!defaults)
    throw new Error("[Vuetify] Could not find defaults instance");
  return defaults;
}
function provideDefaults(defaults, options) {
  const injectedDefaults = injectDefaults();
  const providedDefaults = ref(defaults);
  const newDefaults = computed(() => {
    const disabled = unref(options?.disabled);
    if (disabled)
      return injectedDefaults.value;
    const scoped = unref(options?.scoped);
    const reset = unref(options?.reset);
    const root = unref(options?.root);
    if (providedDefaults.value == null && !(scoped || reset || root))
      return injectedDefaults.value;
    let properties = mergeDeep(providedDefaults.value, {
      prev: injectedDefaults.value
    });
    if (scoped)
      return properties;
    if (reset || root) {
      const len = Number(reset || Infinity);
      for (let i = 0; i <= len; i++) {
        if (!properties || !("prev" in properties)) {
          break;
        }
        properties = properties.prev;
      }
      if (properties && typeof root === "string" && root in properties) {
        properties = mergeDeep(mergeDeep(properties, {
          prev: properties
        }), properties[root]);
      }
      return properties;
    }
    return properties.prev ? mergeDeep(properties.prev, properties) : properties;
  });
  provide(DefaultsSymbol, newDefaults);
  return newDefaults;
}
function propIsDefined(vnode, prop) {
  return typeof vnode.props?.[prop] !== "undefined" || typeof vnode.props?.[toKebabCase(prop)] !== "undefined";
}
function internalUseDefaults() {
  let props2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let name = arguments.length > 1 ? arguments[1] : void 0;
  let defaults = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : injectDefaults();
  const vm = getCurrentInstance("useDefaults");
  name = name ?? vm.type.name ?? vm.type.__name;
  if (!name) {
    throw new Error("[Vuetify] Could not determine component name");
  }
  const componentDefaults = computed(() => defaults.value?.[props2._as ?? name]);
  const _props = new Proxy(props2, {
    get(target, prop) {
      const propValue = Reflect.get(target, prop);
      if (prop === "class" || prop === "style") {
        return [componentDefaults.value?.[prop], propValue].filter((v) => v != null);
      } else if (typeof prop === "string" && !propIsDefined(vm.vnode, prop)) {
        return componentDefaults.value?.[prop] ?? defaults.value?.global?.[prop] ?? propValue;
      }
      return propValue;
    }
  });
  const _subcomponentDefaults = shallowRef();
  watchEffect(() => {
    if (componentDefaults.value) {
      const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
        let [key] = _ref;
        return key.startsWith(key[0].toUpperCase());
      });
      _subcomponentDefaults.value = subComponents.length ? Object.fromEntries(subComponents) : void 0;
    } else {
      _subcomponentDefaults.value = void 0;
    }
  });
  function provideSubDefaults() {
    const injected = injectSelf(DefaultsSymbol, vm);
    provide(DefaultsSymbol, computed(() => {
      return _subcomponentDefaults.value ? mergeDeep(injected?.value ?? {}, _subcomponentDefaults.value) : injected?.value;
    }));
  }
  return {
    props: _props,
    provideSubDefaults
  };
}
function defineComponent(options) {
  options._setup = options._setup ?? options.setup;
  if (!options.name) {
    return options;
  }
  if (options._setup) {
    options.props = propsFactory(options.props ?? {}, options.name)();
    const propKeys = Object.keys(options.props).filter((key) => key !== "class" && key !== "style");
    options.filterProps = function filterProps(props2) {
      return pick(props2, propKeys);
    };
    options.props._as = String;
    options.setup = function setup(props2, ctx) {
      const defaults = injectDefaults();
      if (!defaults.value)
        return options._setup(props2, ctx);
      const {
        props: _props,
        provideSubDefaults
      } = internalUseDefaults(props2, props2._as ?? options.name, defaults);
      const setupBindings = options._setup(_props, ctx);
      provideSubDefaults();
      return setupBindings;
    };
  }
  return options;
}
function genericComponent() {
  let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  return (options) => (exposeDefaults ? defineComponent : defineComponent$1)(options);
}
function defineFunctionalComponent(props2, render2) {
  render2.props = props2;
  return render2;
}
function createSimpleFunctional(klass) {
  let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
  let name = arguments.length > 2 ? arguments[2] : void 0;
  return genericComponent()({
    name: name ?? capitalize(camelize(klass.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: tag
      },
      ...makeComponentProps()
    },
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        return h(props2.tag, {
          class: [klass, props2.class],
          style: props2.style
        }, slots.default?.());
      };
    }
  });
}
function attachedRoot(node) {
  if (typeof node.getRootNode !== "function") {
    while (node.parentNode)
      node = node.parentNode;
    if (node !== document)
      return null;
    return document;
  }
  const root = node.getRootNode();
  if (root !== document && root.getRootNode({
    composed: true
  }) !== document)
    return null;
  return root;
}
const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
function getPrefixedEventHandlers(attrs, suffix, getData) {
  return Object.keys(attrs).filter((key) => isOn(key) && key.endsWith(suffix)).reduce((acc, key) => {
    acc[key.slice(0, -suffix.length)] = (event) => attrs[key](event, getData(event));
    return acc;
  }, {});
}
function getCurrentInstance(name, message) {
  const vm = getCurrentInstance$1();
  if (!vm) {
    throw new Error(`[Vuetify] ${name} ${message || "must be called from inside a setup function"}`);
  }
  return vm;
}
function getCurrentInstanceName() {
  let name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const vm = getCurrentInstance(name).type;
  return toKebabCase(vm?.aliasName || vm?.name);
}
let _uid = 0;
let _map = /* @__PURE__ */ new WeakMap();
function getUid() {
  const vm = getCurrentInstance("getUid");
  if (_map.has(vm))
    return _map.get(vm);
  else {
    const uid2 = _uid++;
    _map.set(vm, uid2);
    return uid2;
  }
}
getUid.reset = () => {
  _uid = 0;
  _map = /* @__PURE__ */ new WeakMap();
};
function getScrollParent$1(el) {
  let includeHidden = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  while (el) {
    if (includeHidden ? isPotentiallyScrollable(el) : hasScrollbar(el))
      return el;
    el = el.parentElement;
  }
  return document.scrollingElement;
}
function getScrollParents(el, stopAt) {
  const elements = [];
  if (stopAt && el && !stopAt.contains(el))
    return elements;
  while (el) {
    if (hasScrollbar(el))
      elements.push(el);
    if (el === stopAt)
      break;
    el = el.parentElement;
  }
  return elements;
}
function hasScrollbar(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style3 = window.getComputedStyle(el);
  return style3.overflowY === "scroll" || style3.overflowY === "auto" && el.scrollHeight > el.clientHeight;
}
function isPotentiallyScrollable(el) {
  if (!el || el.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style3 = window.getComputedStyle(el);
  return ["scroll", "auto"].includes(style3.overflowY);
}
function injectSelf(key) {
  let vm = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstance("injectSelf");
  const {
    provides
  } = vm;
  if (provides && key in provides) {
    return provides[key];
  }
  return void 0;
}
function isFixedPosition(el) {
  while (el) {
    if (window.getComputedStyle(el).position === "fixed") {
      return true;
    }
    el = el.offsetParent;
  }
  return false;
}
function useRender(render2) {
  const vm = getCurrentInstance("useRender");
  vm.render = render2;
}
function useProxiedModel(props2, prop, defaultValue) {
  let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
  let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
  const vm = getCurrentInstance("useProxiedModel");
  const internal = ref(props2[prop] !== void 0 ? props2[prop] : defaultValue);
  const kebabProp = toKebabCase(prop);
  const checkKebab = kebabProp !== prop;
  const isControlled = checkKebab ? computed(() => {
    void props2[prop];
    return !!((vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) && (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`)));
  }) : computed(() => {
    void props2[prop];
    return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`));
  });
  useToggleScope(() => !isControlled.value, () => {
    watch(() => props2[prop], (val) => {
      internal.value = val;
    });
  });
  const model = computed({
    get() {
      const externalValue = props2[prop];
      return transformIn(isControlled.value ? externalValue : internal.value);
    },
    set(internalValue) {
      const newValue = transformOut(internalValue);
      const value = toRaw(isControlled.value ? props2[prop] : internal.value);
      if (value === newValue || transformIn(value) === internalValue) {
        return;
      }
      internal.value = newValue;
      vm?.emit(`update:${prop}`, newValue);
    }
  });
  Object.defineProperty(model, "externalValue", {
    get: () => isControlled.value ? props2[prop] : internal.value
  });
  return model;
}
const en = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more",
    today: "Today"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  }
};
const LANG_PREFIX = "$vuetify.";
const replace = (str, params) => {
  return str.replace(/\{(\d+)\}/g, (match, index2) => {
    return String(params[+index2]);
  });
};
const createTranslateFunction = (current, fallback, messages) => {
  return function(key) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (!key.startsWith(LANG_PREFIX)) {
      return replace(key, params);
    }
    const shortKey = key.replace(LANG_PREFIX, "");
    const currentLocale = current.value && messages.value[current.value];
    const fallbackLocale = fallback.value && messages.value[fallback.value];
    let str = getObjectValueByPath(currentLocale, shortKey, null);
    if (!str) {
      consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
      str = getObjectValueByPath(fallbackLocale, shortKey, null);
    }
    if (!str) {
      str = key;
    }
    if (typeof str !== "string") {
      str = key;
    }
    return replace(str, params);
  };
};
function createNumberFunction(current, fallback) {
  return (value, options) => {
    const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
    return numberFormat.format(value);
  };
}
function useProvided(props2, prop, provided) {
  const internal = useProxiedModel(props2, prop, props2[prop] ?? provided.value);
  internal.value = props2[prop] ?? provided.value;
  watch(provided, (v) => {
    if (props2[prop] == null) {
      internal.value = provided.value;
    }
  });
  return internal;
}
function createProvideFunction(state) {
  return (props2) => {
    const current = useProvided(props2, "locale", state.current);
    const fallback = useProvided(props2, "fallback", state.fallback);
    const messages = useProvided(props2, "messages", state.messages);
    return {
      name: "vuetify",
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current,
        fallback,
        messages
      })
    };
  };
}
function createVuetifyAdapter(options) {
  const current = shallowRef(options?.locale ?? "en");
  const fallback = shallowRef(options?.fallback ?? "en");
  const messages = ref({
    en,
    ...options?.messages
  });
  return {
    name: "vuetify",
    current,
    fallback,
    messages,
    t: createTranslateFunction(current, fallback, messages),
    n: createNumberFunction(current, fallback),
    provide: createProvideFunction({
      current,
      fallback,
      messages
    })
  };
}
const LocaleSymbol = Symbol.for("vuetify:locale");
function isLocaleInstance(obj) {
  return obj.name != null;
}
function createLocale(options) {
  const i18n = options?.adapter && isLocaleInstance(options?.adapter) ? options?.adapter : createVuetifyAdapter(options);
  const rtl = createRtl(i18n, options);
  return {
    ...i18n,
    ...rtl
  };
}
function useLocale() {
  const locale = inject$1(LocaleSymbol);
  if (!locale)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return locale;
}
function genDefaults$2() {
  return {
    af: false,
    ar: true,
    bg: false,
    ca: false,
    ckb: false,
    cs: false,
    de: false,
    el: false,
    en: false,
    es: false,
    et: false,
    fa: true,
    fi: false,
    fr: false,
    hr: false,
    hu: false,
    he: true,
    id: false,
    it: false,
    ja: false,
    km: false,
    ko: false,
    lv: false,
    lt: false,
    nl: false,
    no: false,
    pl: false,
    pt: false,
    ro: false,
    ru: false,
    sk: false,
    sl: false,
    srCyrl: false,
    srLatn: false,
    sv: false,
    th: false,
    tr: false,
    az: false,
    uk: false,
    vi: false,
    zhHans: false,
    zhHant: false
  };
}
function createRtl(i18n, options) {
  const rtl = ref(options?.rtl ?? genDefaults$2());
  const isRtl = computed(() => rtl.value[i18n.current.value] ?? false);
  return {
    isRtl,
    rtl,
    rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
  };
}
function useRtl() {
  const locale = inject$1(LocaleSymbol);
  if (!locale)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: locale.isRtl,
    rtlClasses: locale.rtlClasses
  };
}
const firstDay = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AG: 0,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AS: 0,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BD: 0,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BR: 0,
  BS: 0,
  BT: 0,
  BW: 0,
  BY: 1,
  BZ: 0,
  CA: 0,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CO: 0,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DM: 0,
  DO: 0,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  ET: 0,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  "GB-alt-variant": 0,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  GT: 0,
  GU: 0,
  HK: 0,
  HN: 0,
  HR: 1,
  HU: 1,
  ID: 0,
  IE: 1,
  IL: 0,
  IN: 0,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JM: 0,
  JO: 6,
  JP: 0,
  KE: 0,
  KG: 1,
  KH: 0,
  KR: 0,
  KW: 6,
  KZ: 1,
  LA: 0,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MH: 0,
  MK: 1,
  MM: 0,
  MN: 1,
  MO: 0,
  MQ: 1,
  MT: 0,
  MV: 5,
  MX: 0,
  MY: 1,
  MZ: 0,
  NI: 0,
  NL: 1,
  NO: 1,
  NP: 0,
  NZ: 1,
  OM: 6,
  PA: 0,
  PE: 0,
  PH: 0,
  PK: 0,
  PL: 1,
  PR: 0,
  PT: 0,
  PY: 0,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SA: 0,
  SD: 6,
  SE: 1,
  SG: 0,
  SI: 1,
  SK: 1,
  SM: 1,
  SV: 0,
  SY: 6,
  TH: 0,
  TJ: 1,
  TM: 1,
  TR: 1,
  TT: 0,
  TW: 0,
  UA: 1,
  UM: 0,
  US: 0,
  UY: 1,
  UZ: 1,
  VA: 1,
  VE: 0,
  VI: 0,
  VN: 1,
  WS: 0,
  XK: 1,
  YE: 0,
  ZA: 0,
  ZW: 0
};
function getWeekArray(date2, locale) {
  const weeks = [];
  let currentWeek = [];
  const firstDayOfMonth = startOfMonth(date2);
  const lastDayOfMonth = endOfMonth(date2);
  const firstDayWeekIndex = (firstDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()] + 7) % 7;
  const lastDayWeekIndex = (lastDayOfMonth.getDay() - firstDay[locale.slice(-2).toUpperCase()] + 7) % 7;
  for (let i = 0; i < firstDayWeekIndex; i++) {
    const adjacentDay = new Date(firstDayOfMonth);
    adjacentDay.setDate(adjacentDay.getDate() - (firstDayWeekIndex - i));
    currentWeek.push(adjacentDay);
  }
  for (let i = 1; i <= lastDayOfMonth.getDate(); i++) {
    const day = new Date(date2.getFullYear(), date2.getMonth(), i);
    currentWeek.push(day);
    if (currentWeek.length === 7) {
      weeks.push(currentWeek);
      currentWeek = [];
    }
  }
  for (let i = 1; i < 7 - lastDayWeekIndex; i++) {
    const adjacentDay = new Date(lastDayOfMonth);
    adjacentDay.setDate(adjacentDay.getDate() + i);
    currentWeek.push(adjacentDay);
  }
  if (currentWeek.length > 0) {
    weeks.push(currentWeek);
  }
  return weeks;
}
function startOfWeek(date2) {
  const d = new Date(date2);
  while (d.getDay() !== 0) {
    d.setDate(d.getDate() - 1);
  }
  return d;
}
function endOfWeek(date2) {
  const d = new Date(date2);
  while (d.getDay() !== 6) {
    d.setDate(d.getDate() + 1);
  }
  return d;
}
function startOfMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), 1);
}
function endOfMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth() + 1, 0);
}
function parseLocalDate(value) {
  const parts = value.split("-").map(Number);
  return new Date(parts[0], parts[1] - 1, parts[2]);
}
const _YYYMMDD = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function date(value) {
  if (value == null)
    return /* @__PURE__ */ new Date();
  if (value instanceof Date)
    return value;
  if (typeof value === "string") {
    let parsed;
    if (_YYYMMDD.test(value)) {
      return parseLocalDate(value);
    } else {
      parsed = Date.parse(value);
    }
    if (!isNaN(parsed))
      return new Date(parsed);
  }
  return null;
}
const sundayJanuarySecond2000 = new Date(2e3, 0, 2);
function getWeekdays(locale) {
  const daysFromSunday = firstDay[locale.slice(-2).toUpperCase()];
  return createRange(7).map((i) => {
    const weekday = new Date(sundayJanuarySecond2000);
    weekday.setDate(sundayJanuarySecond2000.getDate() + daysFromSunday + i);
    return new Intl.DateTimeFormat(locale, {
      weekday: "narrow"
    }).format(weekday);
  });
}
function format(value, formatString, locale, formats) {
  const newDate = date(value) ?? /* @__PURE__ */ new Date();
  const customFormat = formats?.[formatString];
  if (typeof customFormat === "function") {
    return customFormat(newDate, formatString, locale);
  }
  let options = {};
  switch (formatString) {
    case "fullDateWithWeekday":
      options = {
        weekday: "long",
        day: "numeric",
        month: "long",
        year: "numeric"
      };
      break;
    case "hours12h":
      options = {
        hour: "numeric",
        hour12: true
      };
      break;
    case "normalDateWithWeekday":
      options = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "keyboardDate":
      options = {
        day: "2-digit",
        month: "2-digit",
        year: "numeric"
      };
      break;
    case "monthAndDate":
      options = {
        month: "long",
        day: "numeric"
      };
      break;
    case "monthAndYear":
      options = {
        month: "long",
        year: "numeric"
      };
      break;
    case "month":
      options = {
        month: "long"
      };
      break;
    case "monthShort":
      options = {
        month: "short"
      };
      break;
    case "dayOfMonth":
      return new Intl.NumberFormat(locale).format(newDate.getDate());
    case "shortDate":
      options = {
        year: "2-digit",
        month: "numeric",
        day: "numeric"
      };
      break;
    case "weekdayShort":
      options = {
        weekday: "short"
      };
      break;
    case "year":
      options = {
        year: "numeric"
      };
      break;
    default:
      options = customFormat ?? {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(locale, options).format(newDate);
}
function toISO(adapter, value) {
  const date2 = adapter.toJsDate(value);
  const year = date2.getFullYear();
  const month = padStart(String(date2.getMonth() + 1), 2, "0");
  const day = padStart(String(date2.getDate()), 2, "0");
  return `${year}-${month}-${day}`;
}
function parseISO(value) {
  const [year, month, day] = value.split("-").map(Number);
  return new Date(year, month - 1, day);
}
function addMinutes(date2, amount) {
  const d = new Date(date2);
  d.setMinutes(d.getMinutes() + amount);
  return d;
}
function addHours(date2, amount) {
  const d = new Date(date2);
  d.setHours(d.getHours() + amount);
  return d;
}
function addDays(date2, amount) {
  const d = new Date(date2);
  d.setDate(d.getDate() + amount);
  return d;
}
function addWeeks(date2, amount) {
  const d = new Date(date2);
  d.setDate(d.getDate() + amount * 7);
  return d;
}
function addMonths(date2, amount) {
  const d = new Date(date2);
  d.setMonth(d.getMonth() + amount);
  return d;
}
function getYear(date2) {
  return date2.getFullYear();
}
function getMonth(date2) {
  return date2.getMonth();
}
function getNextMonth(date2) {
  return new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
}
function getHours(date2) {
  return date2.getHours();
}
function getMinutes(date2) {
  return date2.getMinutes();
}
function startOfYear(date2) {
  return new Date(date2.getFullYear(), 0, 1);
}
function endOfYear(date2) {
  return new Date(date2.getFullYear(), 11, 31);
}
function isWithinRange(date2, range) {
  return isAfter(date2, range[0]) && isBefore(date2, range[1]);
}
function isValid(date2) {
  const d = new Date(date2);
  return d instanceof Date && !isNaN(d.getTime());
}
function isAfter(date2, comparing) {
  return date2.getTime() > comparing.getTime();
}
function isBefore(date2, comparing) {
  return date2.getTime() < comparing.getTime();
}
function isEqual(date2, comparing) {
  return date2.getTime() === comparing.getTime();
}
function isSameDay(date2, comparing) {
  return date2.getDate() === comparing.getDate() && date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
}
function isSameMonth(date2, comparing) {
  return date2.getMonth() === comparing.getMonth() && date2.getFullYear() === comparing.getFullYear();
}
function getDiff(date2, comparing, unit) {
  const d = new Date(date2);
  const c2 = new Date(comparing);
  if (unit === "month") {
    return d.getMonth() - c2.getMonth() + (d.getFullYear() - c2.getFullYear()) * 12;
  }
  return Math.floor((d.getTime() - c2.getTime()) / (1e3 * 60 * 60 * 24));
}
function setHours(date2, count) {
  const d = new Date(date2);
  d.setHours(count);
  return d;
}
function setMinutes(date2, count) {
  const d = new Date(date2);
  d.setMinutes(count);
  return d;
}
function setMonth(date2, count) {
  const d = new Date(date2);
  d.setMonth(count);
  return d;
}
function setYear(date2, year) {
  const d = new Date(date2);
  d.setFullYear(year);
  return d;
}
function startOfDay(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
}
function endOfDay(date2) {
  return new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 23, 59, 59, 999);
}
class VuetifyDateAdapter {
  constructor(options) {
    this.locale = options.locale;
    this.formats = options.formats;
  }
  date(value) {
    return date(value);
  }
  toJsDate(date2) {
    return date2;
  }
  toISO(date2) {
    return toISO(this, date2);
  }
  parseISO(date2) {
    return parseISO(date2);
  }
  addMinutes(date2, amount) {
    return addMinutes(date2, amount);
  }
  addHours(date2, amount) {
    return addHours(date2, amount);
  }
  addDays(date2, amount) {
    return addDays(date2, amount);
  }
  addWeeks(date2, amount) {
    return addWeeks(date2, amount);
  }
  addMonths(date2, amount) {
    return addMonths(date2, amount);
  }
  getWeekArray(date2) {
    return getWeekArray(date2, this.locale);
  }
  startOfWeek(date2) {
    return startOfWeek(date2);
  }
  endOfWeek(date2) {
    return endOfWeek(date2);
  }
  startOfMonth(date2) {
    return startOfMonth(date2);
  }
  endOfMonth(date2) {
    return endOfMonth(date2);
  }
  format(date2, formatString) {
    return format(date2, formatString, this.locale, this.formats);
  }
  isEqual(date2, comparing) {
    return isEqual(date2, comparing);
  }
  isValid(date2) {
    return isValid(date2);
  }
  isWithinRange(date2, range) {
    return isWithinRange(date2, range);
  }
  isAfter(date2, comparing) {
    return isAfter(date2, comparing);
  }
  isBefore(date2, comparing) {
    return !isAfter(date2, comparing) && !isEqual(date2, comparing);
  }
  isSameDay(date2, comparing) {
    return isSameDay(date2, comparing);
  }
  isSameMonth(date2, comparing) {
    return isSameMonth(date2, comparing);
  }
  setMinutes(date2, count) {
    return setMinutes(date2, count);
  }
  setHours(date2, count) {
    return setHours(date2, count);
  }
  setMonth(date2, count) {
    return setMonth(date2, count);
  }
  setYear(date2, year) {
    return setYear(date2, year);
  }
  getDiff(date2, comparing, unit) {
    return getDiff(date2, comparing, unit);
  }
  getWeekdays() {
    return getWeekdays(this.locale);
  }
  getYear(date2) {
    return getYear(date2);
  }
  getMonth(date2) {
    return getMonth(date2);
  }
  getNextMonth(date2) {
    return getNextMonth(date2);
  }
  getHours(date2) {
    return getHours(date2);
  }
  getMinutes(date2) {
    return getMinutes(date2);
  }
  startOfDay(date2) {
    return startOfDay(date2);
  }
  endOfDay(date2) {
    return endOfDay(date2);
  }
  startOfYear(date2) {
    return startOfYear(date2);
  }
  endOfYear(date2) {
    return endOfYear(date2);
  }
}
const DateOptionsSymbol = Symbol.for("vuetify:date-options");
const DateAdapterSymbol = Symbol.for("vuetify:date-adapter");
function createDate(options, locale) {
  const _options = mergeDeep({
    adapter: VuetifyDateAdapter,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "cs-CZ",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, options);
  return {
    options: _options,
    instance: createInstance(_options, locale)
  };
}
function createInstance(options, locale) {
  const instance = reactive(typeof options.adapter === "function" ? new options.adapter({
    locale: options.locale[locale.current.value] ?? locale.current.value,
    formats: options.formats
  }) : options.adapter);
  watch(locale.current, (value) => {
    instance.locale = options.locale[value] ?? value ?? instance.locale;
  });
  return instance;
}
const DisplaySymbol = Symbol.for("vuetify:display");
const defaultDisplayOptions = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
};
const parseDisplayOptions = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
  return mergeDeep(defaultDisplayOptions, options);
};
function getClientWidth(ssr) {
  return IN_BROWSER && !ssr ? window.innerWidth : typeof ssr === "object" && ssr.clientWidth || 0;
}
function getClientHeight(ssr) {
  return IN_BROWSER && !ssr ? window.innerHeight : typeof ssr === "object" && ssr.clientHeight || 0;
}
function getPlatform(ssr) {
  const userAgent = IN_BROWSER && !ssr ? window.navigator.userAgent : "ssr";
  function match(regexp) {
    return Boolean(userAgent.match(regexp));
  }
  const android = match(/android/i);
  const ios = match(/iphone|ipad|ipod/i);
  const cordova = match(/cordova/i);
  const electron = match(/electron/i);
  const chrome = match(/chrome/i);
  const edge = match(/edge/i);
  const firefox = match(/firefox/i);
  const opera = match(/opera/i);
  const win = match(/win/i);
  const mac = match(/mac/i);
  const linux = match(/linux/i);
  return {
    android,
    ios,
    cordova,
    electron,
    chrome,
    edge,
    firefox,
    opera,
    win,
    mac,
    linux,
    touch: SUPPORTS_TOUCH,
    ssr: userAgent === "ssr"
  };
}
function createDisplay(options, ssr) {
  const {
    thresholds,
    mobileBreakpoint
  } = parseDisplayOptions(options);
  const height = shallowRef(getClientHeight(ssr));
  const platform = shallowRef(getPlatform(ssr));
  const state = reactive({});
  const width = shallowRef(getClientWidth(ssr));
  function updateSize() {
    height.value = getClientHeight();
    width.value = getClientWidth();
  }
  function update() {
    updateSize();
    platform.value = getPlatform();
  }
  watchEffect(() => {
    const xs = width.value < thresholds.sm;
    const sm = width.value < thresholds.md && !xs;
    const md = width.value < thresholds.lg && !(sm || xs);
    const lg = width.value < thresholds.xl && !(md || sm || xs);
    const xl = width.value < thresholds.xxl && !(lg || md || sm || xs);
    const xxl = width.value >= thresholds.xxl;
    const name = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl ? "xl" : "xxl";
    const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
    const mobile = width.value < breakpointValue;
    state.xs = xs;
    state.sm = sm;
    state.md = md;
    state.lg = lg;
    state.xl = xl;
    state.xxl = xxl;
    state.smAndUp = !xs;
    state.mdAndUp = !(xs || sm);
    state.lgAndUp = !(xs || sm || md);
    state.xlAndUp = !(xs || sm || md || lg);
    state.smAndDown = !(md || lg || xl || xxl);
    state.mdAndDown = !(lg || xl || xxl);
    state.lgAndDown = !(xl || xxl);
    state.xlAndDown = !xxl;
    state.name = name;
    state.height = height.value;
    state.width = width.value;
    state.mobile = mobile;
    state.mobileBreakpoint = mobileBreakpoint;
    state.platform = platform.value;
    state.thresholds = thresholds;
  });
  if (IN_BROWSER) {
    window.addEventListener("resize", updateSize, {
      passive: true
    });
  }
  return {
    ...toRefs(state),
    update,
    ssr: !!ssr
  };
}
const makeDisplayProps = propsFactory({
  mobileBreakpoint: [Number, String]
}, "display");
function useDisplay() {
  let props2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const display = inject$1(DisplaySymbol);
  if (!display)
    throw new Error("Could not find Vuetify display injection");
  const mobile = computed(() => {
    if (!props2.mobileBreakpoint)
      return display.mobile.value;
    const breakpointValue = typeof props2.mobileBreakpoint === "number" ? props2.mobileBreakpoint : display.thresholds.value[props2.mobileBreakpoint];
    return display.width.value < breakpointValue;
  });
  const displayClasses = computed(() => {
    if (!name)
      return {};
    return {
      [`${name}--mobile`]: mobile.value
    };
  });
  return {
    ...display,
    displayClasses,
    mobile
  };
}
const GoToSymbol = Symbol.for("vuetify:goto");
function genDefaults$1() {
  return {
    container: void 0,
    duration: 300,
    layout: false,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: {
      linear: (t) => t,
      easeInQuad: (t) => t ** 2,
      easeOutQuad: (t) => t * (2 - t),
      easeInOutQuad: (t) => t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t,
      easeInCubic: (t) => t ** 3,
      easeOutCubic: (t) => --t ** 3 + 1,
      easeInOutCubic: (t) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
      easeInQuart: (t) => t ** 4,
      easeOutQuart: (t) => 1 - --t ** 4,
      easeInOutQuart: (t) => t < 0.5 ? 8 * t ** 4 : 1 - 8 * --t ** 4,
      easeInQuint: (t) => t ** 5,
      easeOutQuint: (t) => 1 + --t ** 5,
      easeInOutQuint: (t) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5
    }
  };
}
function createGoTo(options, locale) {
  return {
    rtl: locale.isRtl,
    options: mergeDeep(genDefaults$1(), options)
  };
}
const aliases = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar",
  eyeDropper: "mdi-eyedropper"
};
const mdi = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (props2) => h(VClassIcon, {
    ...props2,
    class: "mdi"
  })
};
const IconValue = [String, Function, Object, Array];
const IconSymbol = Symbol.for("vuetify:icons");
const makeIconProps = propsFactory({
  icon: {
    type: IconValue
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: String,
    required: true
  }
}, "icon");
const VComponentIcon = genericComponent()({
  name: "VComponentIcon",
  props: makeIconProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      const Icon = props2.icon;
      return createVNode(props2.tag, null, {
        default: () => [props2.icon ? createVNode(Icon, null, null) : slots.default?.()]
      });
    };
  }
});
const VSvgIcon = defineComponent({
  name: "VSvgIcon",
  inheritAttrs: false,
  props: makeIconProps(),
  setup(props2, _ref2) {
    let {
      attrs
    } = _ref2;
    return () => {
      return createVNode(props2.tag, mergeProps(attrs, {
        "style": null
      }), {
        default: () => [createVNode("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [Array.isArray(props2.icon) ? props2.icon.map((path) => Array.isArray(path) ? createVNode("path", {
          "d": path[0],
          "fill-opacity": path[1]
        }, null) : createVNode("path", {
          "d": path
        }, null)) : createVNode("path", {
          "d": props2.icon
        }, null)])]
      });
    };
  }
});
defineComponent({
  name: "VLigatureIcon",
  props: makeIconProps(),
  setup(props2) {
    return () => {
      return createVNode(props2.tag, null, {
        default: () => [props2.icon]
      });
    };
  }
});
const VClassIcon = defineComponent({
  name: "VClassIcon",
  props: makeIconProps(),
  setup(props2) {
    return () => {
      return createVNode(props2.tag, {
        "class": props2.icon
      }, null);
    };
  }
});
const defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
};
function createIcons(options) {
  return mergeDeep({
    defaultSet: "mdi",
    sets: {
      ...defaultSets,
      mdi
    },
    aliases: {
      ...aliases,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z"
      /* eslint-enable max-len */
    }
  }, options);
}
const useIcon = (props2) => {
  const icons = inject$1(IconSymbol);
  if (!icons)
    throw new Error("Missing Vuetify Icons provide!");
  const iconData = computed(() => {
    const iconAlias = unref(props2);
    if (!iconAlias)
      return {
        component: VComponentIcon
      };
    let icon = iconAlias;
    if (typeof icon === "string") {
      icon = icon.trim();
      if (icon.startsWith("$")) {
        icon = icons.aliases?.[icon.slice(1)];
      }
    }
    if (!icon)
      throw new Error(`Could not find aliased icon "${iconAlias}"`);
    if (Array.isArray(icon)) {
      return {
        component: VSvgIcon,
        icon
      };
    } else if (typeof icon !== "string") {
      return {
        component: VComponentIcon,
        icon
      };
    }
    const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
    const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
    const iconSet = icons.sets[iconSetName ?? icons.defaultSet];
    return {
      component: iconSet.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};
const ThemeSymbol = Symbol.for("vuetify:theme");
const makeThemeProps = propsFactory({
  theme: String
}, "theme");
function genDefaults() {
  return {
    defaultTheme: "light",
    variations: {
      colors: [],
      lighten: 0,
      darken: 0
    },
    themes: {
      light: {
        dark: false,
        colors: {
          background: "#FFFFFF",
          surface: "#FFFFFF",
          "surface-bright": "#FFFFFF",
          "surface-light": "#EEEEEE",
          "surface-variant": "#424242",
          "on-surface-variant": "#EEEEEE",
          primary: "#1867C0",
          "primary-darken-1": "#1F5592",
          secondary: "#48A9A6",
          "secondary-darken-1": "#018786",
          error: "#B00020",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#000000",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 0.87,
          "medium-emphasis-opacity": 0.6,
          "disabled-opacity": 0.38,
          "idle-opacity": 0.04,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.12,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#F5F5F5",
          "theme-on-code": "#000000"
        }
      },
      dark: {
        dark: true,
        colors: {
          background: "#121212",
          surface: "#212121",
          "surface-bright": "#ccbfd6",
          "surface-light": "#424242",
          "surface-variant": "#a3a3a3",
          "on-surface-variant": "#424242",
          primary: "#2196F3",
          "primary-darken-1": "#277CC1",
          secondary: "#54B6B2",
          "secondary-darken-1": "#48A9A6",
          error: "#CF6679",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#FFFFFF",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 1,
          "medium-emphasis-opacity": 0.7,
          "disabled-opacity": 0.5,
          "idle-opacity": 0.1,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.16,
          "dragged-opacity": 0.08,
          "theme-kbd": "#212529",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#343434",
          "theme-on-code": "#CCCCCC"
        }
      }
    }
  };
}
function parseThemeOptions() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : genDefaults();
  const defaults = genDefaults();
  if (!options)
    return {
      ...defaults,
      isDisabled: true
    };
  const themes = {};
  for (const [key, theme] of Object.entries(options.themes ?? {})) {
    const defaultTheme = theme.dark || key === "dark" ? defaults.themes?.dark : defaults.themes?.light;
    themes[key] = mergeDeep(defaultTheme, theme);
  }
  return mergeDeep(defaults, {
    ...options,
    themes
  });
}
function createTheme(options) {
  const parsedOptions = parseThemeOptions(options);
  const name = ref(parsedOptions.defaultTheme);
  const themes = ref(parsedOptions.themes);
  const computedThemes = computed(() => {
    const acc = {};
    for (const [name2, original] of Object.entries(themes.value)) {
      const theme = acc[name2] = {
        ...original,
        colors: {
          ...original.colors
        }
      };
      if (parsedOptions.variations) {
        for (const name3 of parsedOptions.variations.colors) {
          const color = theme.colors[name3];
          if (!color)
            continue;
          for (const variation of ["lighten", "darken"]) {
            const fn = variation === "lighten" ? lighten : darken;
            for (const amount of createRange(parsedOptions.variations[variation], 1)) {
              theme.colors[`${name3}-${variation}-${amount}`] = RGBtoHex(fn(parseColor(color), amount));
            }
          }
        }
      }
      for (const color of Object.keys(theme.colors)) {
        if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
          continue;
        const onColor = `on-${color}`;
        const colorVal = parseColor(theme.colors[color]);
        theme.colors[onColor] = getForeground(colorVal);
      }
    }
    return acc;
  });
  const current = computed(() => computedThemes.value[name.value]);
  const styles = computed(() => {
    const lines = [];
    if (current.value.dark) {
      createCssClass(lines, ":root", ["color-scheme: dark"]);
    }
    createCssClass(lines, ":root", genCssVariables(current.value));
    for (const [themeName, theme] of Object.entries(computedThemes.value)) {
      createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${theme.dark ? "dark" : "normal"}`, ...genCssVariables(theme)]);
    }
    const bgLines = [];
    const fgLines = [];
    const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
    for (const key of colors) {
      if (/^on-[a-z]/.test(key)) {
        createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
      } else {
        createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background-color: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]);
        createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
        createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]);
      }
    }
    lines.push(...bgLines, ...fgLines);
    return lines.map((str, i) => i === 0 ? str : `    ${str}`).join("");
  });
  function getHead() {
    return {
      style: [{
        children: styles.value,
        id: "vuetify-theme-stylesheet",
        nonce: parsedOptions.cspNonce || false
      }]
    };
  }
  function install(app2) {
    if (parsedOptions.isDisabled)
      return;
    const head = app2._context.provides.usehead;
    if (head) {
      if (head.push) {
        const entry = head.push(getHead);
        if (IN_BROWSER) {
          watch(styles, () => {
            entry.patch(getHead);
          });
        }
      } else {
        if (IN_BROWSER) {
          head.addHeadObjs(computed(getHead));
          watchEffect(() => head.updateDOM());
        } else {
          head.addHeadObjs(getHead());
        }
      }
    } else {
      let updateStyles = function() {
        if (typeof document !== "undefined" && !styleEl) {
          const el = document.createElement("style");
          el.type = "text/css";
          el.id = "vuetify-theme-stylesheet";
          if (parsedOptions.cspNonce)
            el.setAttribute("nonce", parsedOptions.cspNonce);
          styleEl = el;
          document.head.appendChild(styleEl);
        }
        if (styleEl)
          styleEl.innerHTML = styles.value;
      };
      let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
      if (IN_BROWSER) {
        watch(styles, updateStyles, {
          immediate: true
        });
      } else {
        updateStyles();
      }
    }
  }
  const themeClasses = computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name.value}`);
  return {
    install,
    isDisabled: parsedOptions.isDisabled,
    name,
    themes,
    current,
    computedThemes,
    themeClasses,
    styles,
    global: {
      name,
      current
    }
  };
}
function provideTheme(props2) {
  getCurrentInstance("provideTheme");
  const theme = inject$1(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  const name = computed(() => {
    return props2.theme ?? theme.name.value;
  });
  const current = computed(() => theme.themes.value[name.value]);
  const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${name.value}`);
  const newTheme = {
    ...theme,
    name,
    current,
    themeClasses
  };
  provide(ThemeSymbol, newTheme);
  return newTheme;
}
function useTheme() {
  getCurrentInstance("useTheme");
  const theme = inject$1(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  return theme;
}
function createCssClass(lines, selector, content) {
  lines.push(`${selector} {
`, ...content.map((line) => `  ${line};
`), "}\n");
}
function genCssVariables(theme) {
  const lightOverlay = theme.dark ? 2 : 1;
  const darkOverlay = theme.dark ? 1 : 2;
  const variables = [];
  for (const [key, value] of Object.entries(theme.colors)) {
    const rgb = parseColor(value);
    variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
    if (!key.startsWith("on-")) {
      variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
    }
  }
  for (const [key, value] of Object.entries(theme.variables)) {
    const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
    const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
    variables.push(`--v-${key}: ${rgb ?? value}`);
  }
  return variables;
}
function useResizeObserver(callback) {
  let box = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const resizeRef = ref();
  const contentRect = ref();
  if (IN_BROWSER) {
    const observer = new ResizeObserver((entries) => {
      callback?.(entries, observer);
      if (!entries.length)
        return;
      if (box === "content") {
        contentRect.value = entries[0].contentRect;
      } else {
        contentRect.value = entries[0].target.getBoundingClientRect();
      }
    });
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(resizeRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(refElement(oldValue));
        contentRect.value = void 0;
      }
      if (newValue)
        observer.observe(refElement(newValue));
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef,
    contentRect: readonly(contentRect)
  };
}
const VuetifyLayoutKey = Symbol.for("vuetify:layout");
const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
const ROOT_ZINDEX = 1e3;
const makeLayoutProps = propsFactory({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout");
const makeLayoutItemProps = propsFactory({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function useLayout() {
  const layout = inject$1(VuetifyLayoutKey);
  if (!layout)
    throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: layout.getLayoutItem,
    mainRect: layout.mainRect,
    mainStyles: layout.mainStyles
  };
}
function useLayoutItem(options) {
  const layout = inject$1(VuetifyLayoutKey);
  if (!layout)
    throw new Error("[Vuetify] Could not find injected layout");
  const id = options.id ?? `layout-item-${getUid()}`;
  const vm = getCurrentInstance("useLayoutItem");
  provide(VuetifyLayoutItemKey, {
    id
  });
  const isKeptAlive = shallowRef(false);
  onDeactivated(() => isKeptAlive.value = true);
  onActivated(() => isKeptAlive.value = false);
  const {
    layoutItemStyles,
    layoutItemScrimStyles
  } = layout.register(vm, {
    ...options,
    active: computed(() => isKeptAlive.value ? false : options.active.value),
    id
  });
  onBeforeUnmount(() => layout.unregister(id));
  return {
    layoutItemStyles,
    layoutRect: layout.layoutRect,
    layoutItemScrimStyles
  };
}
const generateLayers = (layout, positions, layoutSizes, activeItems) => {
  let previousLayer = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const layers = [{
    id: "",
    layer: {
      ...previousLayer
    }
  }];
  for (const id of layout) {
    const position = positions.get(id);
    const amount = layoutSizes.get(id);
    const active = activeItems.get(id);
    if (!position || !amount || !active)
      continue;
    const layer = {
      ...previousLayer,
      [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
    };
    layers.push({
      id,
      layer
    });
    previousLayer = layer;
  }
  return layers;
};
function createLayout(props2) {
  const parentLayout = inject$1(VuetifyLayoutKey, null);
  const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
  const registered = ref([]);
  const positions = reactive(/* @__PURE__ */ new Map());
  const layoutSizes = reactive(/* @__PURE__ */ new Map());
  const priorities = reactive(/* @__PURE__ */ new Map());
  const activeItems = reactive(/* @__PURE__ */ new Map());
  const disabledTransitions = reactive(/* @__PURE__ */ new Map());
  const {
    resizeRef,
    contentRect: layoutRect
  } = useResizeObserver();
  const computedOverlaps = computed(() => {
    const map = /* @__PURE__ */ new Map();
    const overlaps = props2.overlaps ?? [];
    for (const overlap of overlaps.filter((item) => item.includes(":"))) {
      const [top, bottom] = overlap.split(":");
      if (!registered.value.includes(top) || !registered.value.includes(bottom))
        continue;
      const topPosition = positions.get(top);
      const bottomPosition = positions.get(bottom);
      const topAmount = layoutSizes.get(top);
      const bottomAmount = layoutSizes.get(bottom);
      if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
        continue;
      map.set(bottom, {
        position: topPosition.value,
        amount: parseInt(topAmount.value, 10)
      });
      map.set(top, {
        position: bottomPosition.value,
        amount: -parseInt(bottomAmount.value, 10)
      });
    }
    return map;
  });
  const layers = computed(() => {
    const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a, b) => a - b);
    const layout = [];
    for (const p2 of uniquePriorities) {
      const items2 = registered.value.filter((id) => priorities.get(id)?.value === p2);
      layout.push(...items2);
    }
    return generateLayers(layout, positions, layoutSizes, activeItems);
  });
  const transitionsEnabled = computed(() => {
    return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
  });
  const mainRect = computed(() => {
    return layers.value[layers.value.length - 1].layer;
  });
  const mainStyles = computed(() => {
    return {
      "--v-layout-left": convertToUnit(mainRect.value.left),
      "--v-layout-right": convertToUnit(mainRect.value.right),
      "--v-layout-top": convertToUnit(mainRect.value.top),
      "--v-layout-bottom": convertToUnit(mainRect.value.bottom),
      ...transitionsEnabled.value ? void 0 : {
        transition: "none"
      }
    };
  });
  const items = computed(() => {
    return layers.value.slice(1).map((_ref, index2) => {
      let {
        id
      } = _ref;
      const {
        layer
      } = layers.value[index2];
      const size2 = layoutSizes.get(id);
      const position = positions.get(id);
      return {
        id,
        ...layer,
        size: Number(size2.value),
        position: position.value
      };
    });
  });
  const getLayoutItem = (id) => {
    return items.value.find((item) => item.id === id);
  };
  const rootVm = getCurrentInstance("createLayout");
  const isMounted = shallowRef(false);
  onMounted(() => {
    isMounted.value = true;
  });
  provide(VuetifyLayoutKey, {
    register: (vm, _ref2) => {
      let {
        id,
        order,
        position,
        layoutSize,
        elementSize,
        active,
        disableTransitions,
        absolute
      } = _ref2;
      priorities.set(id, order);
      positions.set(id, position);
      layoutSizes.set(id, layoutSize);
      activeItems.set(id, active);
      disableTransitions && disabledTransitions.set(id, disableTransitions);
      const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm?.vnode);
      const instanceIndex = instances.indexOf(vm);
      if (instanceIndex > -1)
        registered.value.splice(instanceIndex, 0, id);
      else
        registered.value.push(id);
      const index2 = computed(() => items.value.findIndex((i) => i.id === id));
      const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index2.value * 2);
      const layoutItemStyles = computed(() => {
        const isHorizontal = position.value === "left" || position.value === "right";
        const isOppositeHorizontal = position.value === "right";
        const isOppositeVertical = position.value === "bottom";
        const styles = {
          [position.value]: 0,
          zIndex: zIndex.value,
          transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
          position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
          ...transitionsEnabled.value ? void 0 : {
            transition: "none"
          }
        };
        if (!isMounted.value)
          return styles;
        const item = items.value[index2.value];
        if (!item)
          throw new Error(`[Vuetify] Could not find layout item "${id}"`);
        const overlap = computedOverlaps.value.get(id);
        if (overlap) {
          item[overlap.position] += overlap.amount;
        }
        return {
          ...styles,
          height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
          left: isOppositeHorizontal ? void 0 : `${item.left}px`,
          right: isOppositeHorizontal ? `${item.right}px` : void 0,
          top: position.value !== "bottom" ? `${item.top}px` : void 0,
          bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
          width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
        };
      });
      const layoutItemScrimStyles = computed(() => ({
        zIndex: zIndex.value - 1
      }));
      return {
        layoutItemStyles,
        layoutItemScrimStyles,
        zIndex
      };
    },
    unregister: (id) => {
      priorities.delete(id);
      positions.delete(id);
      layoutSizes.delete(id);
      activeItems.delete(id);
      disabledTransitions.delete(id);
      registered.value = registered.value.filter((v) => v !== id);
    },
    mainRect,
    mainStyles,
    getLayoutItem,
    items,
    layoutRect,
    rootZIndex
  });
  const layoutClasses = computed(() => ["v-layout", {
    "v-layout--full-height": props2.fullHeight
  }]);
  const layoutStyles = computed(() => ({
    zIndex: parentLayout ? rootZIndex.value : void 0,
    position: parentLayout ? "relative" : void 0,
    overflow: parentLayout ? "hidden" : void 0
  }));
  return {
    layoutClasses,
    layoutStyles,
    getLayoutItem,
    items,
    layoutRect,
    layoutRef: resizeRef
  };
}
function createVuetify() {
  let vuetify2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint,
    ...rest
  } = vuetify2;
  const options = mergeDeep(blueprint, rest);
  const {
    aliases: aliases2 = {},
    components = {},
    directives = {}
  } = options;
  const defaults = createDefaults(options.defaults);
  const display = createDisplay(options.display, options.ssr);
  const theme = createTheme(options.theme);
  const icons = createIcons(options.icons);
  const locale = createLocale(options.locale);
  const date2 = createDate(options.date, locale);
  const goTo = createGoTo(options.goTo, locale);
  const install = (app2) => {
    for (const key in directives) {
      app2.directive(key, directives[key]);
    }
    for (const key in components) {
      app2.component(key, components[key]);
    }
    for (const key in aliases2) {
      app2.component(key, defineComponent({
        ...aliases2[key],
        name: key,
        aliasName: aliases2[key].name
      }));
    }
    theme.install(app2);
    app2.provide(DefaultsSymbol, defaults);
    app2.provide(DisplaySymbol, display);
    app2.provide(ThemeSymbol, theme);
    app2.provide(IconSymbol, icons);
    app2.provide(LocaleSymbol, locale);
    app2.provide(DateOptionsSymbol, date2.options);
    app2.provide(DateAdapterSymbol, date2.instance);
    app2.provide(GoToSymbol, goTo);
    if (IN_BROWSER && options.ssr) {
      if (app2.$nuxt) {
        app2.$nuxt.hook("app:suspense:resolve", () => {
          display.update();
        });
      } else {
        const {
          mount
        } = app2;
        app2.mount = function() {
          const vm = mount(...arguments);
          nextTick(() => display.update());
          app2.mount = mount;
          return vm;
        };
      }
    }
    getUid.reset();
    {
      app2.mixin({
        computed: {
          $vuetify() {
            return reactive({
              defaults: inject.call(this, DefaultsSymbol),
              display: inject.call(this, DisplaySymbol),
              theme: inject.call(this, ThemeSymbol),
              icons: inject.call(this, IconSymbol),
              locale: inject.call(this, LocaleSymbol),
              date: inject.call(this, DateAdapterSymbol)
            });
          }
        }
      });
    }
  };
  return {
    install,
    defaults,
    display,
    theme,
    icons,
    locale,
    date: date2,
    goTo
  };
}
const version = "3.5.4";
createVuetify.version = version;
function inject(key) {
  const vm = this.$;
  const provides = vm.parent?.provides ?? vm.vnode.appContext?.provides;
  if (provides && key in provides) {
    return provides[key];
  }
}
const materialdesignicons = "";
const VApp$1 = "";
const makeVAppProps = propsFactory({
  ...makeComponentProps(),
  ...makeLayoutProps({
    fullHeight: true
  }),
  ...makeThemeProps()
}, "VApp");
const VApp = genericComponent()({
  name: "VApp",
  props: makeVAppProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const theme = provideTheme(props2);
    const {
      layoutClasses,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props2);
    const {
      rtlClasses
    } = useRtl();
    useRender(() => createVNode("div", {
      "ref": layoutRef,
      "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value, props2.class],
      "style": [props2.style]
    }, [createVNode("div", {
      "class": "v-application__wrap"
    }, [slots.default?.()])]));
    return {
      getLayoutItem,
      items,
      theme
    };
  }
});
const makeTagProps = propsFactory({
  tag: {
    type: String,
    default: "div"
  }
}, "tag");
const makeTransitionProps$1 = propsFactory({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function createCssTransition(name, origin, mode) {
  return genericComponent()({
    name,
    props: makeTransitionProps$1({
      mode,
      origin
    }),
    setup(props2, _ref) {
      let {
        slots
      } = _ref;
      const functions = {
        onBeforeEnter(el) {
          if (props2.origin) {
            el.style.transformOrigin = props2.origin;
          }
        },
        onLeave(el) {
          if (props2.leaveAbsolute) {
            const {
              offsetTop,
              offsetLeft,
              offsetWidth,
              offsetHeight
            } = el;
            el._transitionInitialStyles = {
              position: el.style.position,
              top: el.style.top,
              left: el.style.left,
              width: el.style.width,
              height: el.style.height
            };
            el.style.position = "absolute";
            el.style.top = `${offsetTop}px`;
            el.style.left = `${offsetLeft}px`;
            el.style.width = `${offsetWidth}px`;
            el.style.height = `${offsetHeight}px`;
          }
          if (props2.hideOnLeave) {
            el.style.setProperty("display", "none", "important");
          }
        },
        onAfterLeave(el) {
          if (props2.leaveAbsolute && el?._transitionInitialStyles) {
            const {
              position,
              top,
              left,
              width,
              height
            } = el._transitionInitialStyles;
            delete el._transitionInitialStyles;
            el.style.position = position || "";
            el.style.top = top || "";
            el.style.left = left || "";
            el.style.width = width || "";
            el.style.height = height || "";
          }
        }
      };
      return () => {
        const tag = props2.group ? TransitionGroup : Transition;
        return h(tag, {
          name: props2.disabled ? "" : name,
          css: !props2.disabled,
          ...props2.group ? void 0 : {
            mode: props2.mode
          },
          ...props2.disabled ? {} : functions
        }, slots.default);
      };
    }
  });
}
function createJavascriptTransition(name, functions) {
  let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return genericComponent()({
    name,
    props: {
      mode: {
        type: String,
        default: mode
      },
      disabled: Boolean
    },
    setup(props2, _ref2) {
      let {
        slots
      } = _ref2;
      return () => {
        return h(Transition, {
          name: props2.disabled ? "" : name,
          css: !props2.disabled,
          // mode: props.mode, // TODO: vuejs/vue-next#3104
          ...props2.disabled ? {} : functions
        }, slots.default);
      };
    }
  });
}
function ExpandTransitionGenerator() {
  let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let x2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const sizeProperty = x2 ? "width" : "height";
  const offsetProperty = camelize(`offset-${sizeProperty}`);
  return {
    onBeforeEnter(el) {
      el._parent = el.parentNode;
      el._initialStyle = {
        transition: el.style.transition,
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
    },
    onEnter(el) {
      const initialStyle = el._initialStyle;
      el.style.setProperty("transition", "none", "important");
      el.style.overflow = "hidden";
      const offset = `${el[offsetProperty]}px`;
      el.style[sizeProperty] = "0";
      void el.offsetHeight;
      el.style.transition = initialStyle.transition;
      if (expandedParentClass && el._parent) {
        el._parent.classList.add(expandedParentClass);
      }
      requestAnimationFrame(() => {
        el.style[sizeProperty] = offset;
      });
    },
    onAfterEnter: resetStyles,
    onEnterCancelled: resetStyles,
    onLeave(el) {
      el._initialStyle = {
        transition: "",
        overflow: el.style.overflow,
        [sizeProperty]: el.style[sizeProperty]
      };
      el.style.overflow = "hidden";
      el.style[sizeProperty] = `${el[offsetProperty]}px`;
      void el.offsetHeight;
      requestAnimationFrame(() => el.style[sizeProperty] = "0");
    },
    onAfterLeave,
    onLeaveCancelled: onAfterLeave
  };
  function onAfterLeave(el) {
    if (expandedParentClass && el._parent) {
      el._parent.classList.remove(expandedParentClass);
    }
    resetStyles(el);
  }
  function resetStyles(el) {
    const size2 = el._initialStyle[sizeProperty];
    el.style.overflow = el._initialStyle.overflow;
    if (size2 != null)
      el.style[sizeProperty] = size2;
    delete el._initialStyle;
  }
}
const makeVDialogTransitionProps = propsFactory({
  target: [Object, Array]
}, "v-dialog-transition");
const VDialogTransition = genericComponent()({
  name: "VDialogTransition",
  props: makeVDialogTransitionProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const functions = {
      onBeforeEnter(el) {
        el.style.pointerEvents = "none";
        el.style.visibility = "hidden";
      },
      async onEnter(el, done) {
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        el.style.visibility = "";
        const {
          x: x2,
          y,
          sx,
          sy,
          speed
        } = getDimensions(props2.target, el);
        const animation = animate(el, [{
          transform: `translate(${x2}px, ${y}px) scale(${sx}, ${sy})`,
          opacity: 0
        }, {}], {
          duration: 225 * speed,
          easing: deceleratedEasing
        });
        getChildren(el)?.forEach((el2) => {
          animate(el2, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * speed,
            easing: standardEasing
          });
        });
        animation.finished.then(() => done());
      },
      onAfterEnter(el) {
        el.style.removeProperty("pointer-events");
      },
      onBeforeLeave(el) {
        el.style.pointerEvents = "none";
      },
      async onLeave(el, done) {
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        const {
          x: x2,
          y,
          sx,
          sy,
          speed
        } = getDimensions(props2.target, el);
        const animation = animate(el, [{}, {
          transform: `translate(${x2}px, ${y}px) scale(${sx}, ${sy})`,
          opacity: 0
        }], {
          duration: 125 * speed,
          easing: acceleratedEasing
        });
        animation.finished.then(() => done());
        getChildren(el)?.forEach((el2) => {
          animate(el2, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * speed,
            easing: standardEasing
          });
        });
      },
      onAfterLeave(el) {
        el.style.removeProperty("pointer-events");
      }
    };
    return () => {
      return props2.target ? createVNode(Transition, mergeProps({
        "name": "dialog-transition"
      }, functions, {
        "css": false
      }), slots) : createVNode(Transition, {
        "name": "dialog-transition"
      }, slots);
    };
  }
});
function getChildren(el) {
  const els = el.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")?.children;
  return els && [...els];
}
function getDimensions(target, el) {
  const targetBox = getTargetBox(target);
  const elBox = nullifyTransforms(el);
  const [originX, originY] = getComputedStyle(el).transformOrigin.split(" ").map((v) => parseFloat(v));
  const [anchorSide, anchorOffset] = getComputedStyle(el).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let offsetX = targetBox.left + targetBox.width / 2;
  if (anchorSide === "left" || anchorOffset === "left") {
    offsetX -= targetBox.width / 2;
  } else if (anchorSide === "right" || anchorOffset === "right") {
    offsetX += targetBox.width / 2;
  }
  let offsetY = targetBox.top + targetBox.height / 2;
  if (anchorSide === "top" || anchorOffset === "top") {
    offsetY -= targetBox.height / 2;
  } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
    offsetY += targetBox.height / 2;
  }
  const tsx = targetBox.width / elBox.width;
  const tsy = targetBox.height / elBox.height;
  const maxs = Math.max(1, tsx, tsy);
  const sx = tsx / maxs || 0;
  const sy = tsy / maxs || 0;
  const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
  const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
  return {
    x: offsetX - (originX + elBox.left),
    y: offsetY - (originY + elBox.top),
    sx,
    sy,
    speed
  };
}
createCssTransition("fab-transition", "center center", "out-in");
createCssTransition("dialog-bottom-transition");
createCssTransition("dialog-top-transition");
const VFadeTransition = createCssTransition("fade-transition");
const VScaleTransition = createCssTransition("scale-transition");
createCssTransition("scroll-x-transition");
createCssTransition("scroll-x-reverse-transition");
createCssTransition("scroll-y-transition");
createCssTransition("scroll-y-reverse-transition");
createCssTransition("slide-x-transition");
createCssTransition("slide-x-reverse-transition");
const VSlideYTransition = createCssTransition("slide-y-transition");
createCssTransition("slide-y-reverse-transition");
const VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
const VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
const makeVDefaultsProviderProps = propsFactory({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider");
const VDefaultsProvider = genericComponent(false)({
  name: "VDefaultsProvider",
  props: makeVDefaultsProviderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      defaults,
      disabled,
      reset,
      root,
      scoped
    } = toRefs(props2);
    provideDefaults(defaults, {
      reset,
      root,
      scoped,
      disabled
    });
    return () => slots.default?.();
  }
});
const VImg$1 = "";
const VResponsive$1 = "";
const makeDimensionProps = propsFactory({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function useDimension(props2) {
  const dimensionStyles = computed(() => ({
    height: convertToUnit(props2.height),
    maxHeight: convertToUnit(props2.maxHeight),
    maxWidth: convertToUnit(props2.maxWidth),
    minHeight: convertToUnit(props2.minHeight),
    minWidth: convertToUnit(props2.minWidth),
    width: convertToUnit(props2.width)
  }));
  return {
    dimensionStyles
  };
}
function useAspectStyles(props2) {
  return {
    aspectStyles: computed(() => {
      const ratio = Number(props2.aspectRatio);
      return ratio ? {
        paddingBottom: String(1 / ratio * 100) + "%"
      } : void 0;
    })
  };
}
const makeVResponsiveProps = propsFactory({
  aspectRatio: [String, Number],
  contentClass: String,
  inline: Boolean,
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VResponsive");
const VResponsive = genericComponent()({
  name: "VResponsive",
  props: makeVResponsiveProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      aspectStyles
    } = useAspectStyles(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    useRender(() => createVNode("div", {
      "class": ["v-responsive", {
        "v-responsive--inline": props2.inline
      }, props2.class],
      "style": [dimensionStyles.value, props2.style]
    }, [createVNode("div", {
      "class": "v-responsive__sizer",
      "style": aspectStyles.value
    }, null), slots.additional?.(), slots.default && createVNode("div", {
      "class": ["v-responsive__content", props2.contentClass]
    }, [slots.default()])]));
    return {};
  }
});
function useColor(colors) {
  return destructComputed(() => {
    const classes = [];
    const styles = {};
    if (colors.value.background) {
      if (isCssColor(colors.value.background)) {
        styles.backgroundColor = colors.value.background;
        if (!colors.value.text && isParsableColor(colors.value.background)) {
          const backgroundColor = parseColor(colors.value.background);
          if (backgroundColor.a == null || backgroundColor.a === 1) {
            const textColor = getForeground(backgroundColor);
            styles.color = textColor;
            styles.caretColor = textColor;
          }
        }
      } else {
        classes.push(`bg-${colors.value.background}`);
      }
    }
    if (colors.value.text) {
      if (isCssColor(colors.value.text)) {
        styles.color = colors.value.text;
        styles.caretColor = colors.value.text;
      } else {
        classes.push(`text-${colors.value.text}`);
      }
    }
    return {
      colorClasses: classes,
      colorStyles: styles
    };
  });
}
function useTextColor(props2, name) {
  const colors = computed(() => ({
    text: isRef(props2) ? props2.value : name ? props2[name] : null
  }));
  const {
    colorClasses: textColorClasses,
    colorStyles: textColorStyles
  } = useColor(colors);
  return {
    textColorClasses,
    textColorStyles
  };
}
function useBackgroundColor(props2, name) {
  const colors = computed(() => ({
    background: isRef(props2) ? props2.value : name ? props2[name] : null
  }));
  const {
    colorClasses: backgroundColorClasses,
    colorStyles: backgroundColorStyles
  } = useColor(colors);
  return {
    backgroundColorClasses,
    backgroundColorStyles
  };
}
const makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function useRounded(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const roundedClasses = computed(() => {
    const rounded = isRef(props2) ? props2.value : props2.rounded;
    const classes = [];
    if (rounded === true || rounded === "") {
      classes.push(`${name}--rounded`);
    } else if (typeof rounded === "string" || rounded === 0) {
      for (const value of String(rounded).split(" ")) {
        classes.push(`rounded-${value}`);
      }
    }
    return classes;
  });
  return {
    roundedClasses
  };
}
const makeTransitionProps = propsFactory({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (val) => val !== true
  }
}, "transition");
const MaybeTransition = (props2, _ref) => {
  let {
    slots
  } = _ref;
  const {
    transition,
    disabled,
    ...rest
  } = props2;
  const {
    component = Transition,
    ...customProps
  } = typeof transition === "object" ? transition : {};
  return h(component, mergeProps(typeof transition === "string" ? {
    name: disabled ? "" : transition
  } : customProps, rest, {
    disabled
  }), slots);
};
function mounted$1(el, binding) {
  if (!SUPPORTS_INTERSECTION)
    return;
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    handler,
    options
  } = typeof value === "object" ? value : {
    handler: value,
    options: {}
  };
  const observer = new IntersectionObserver(function() {
    let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let observer2 = arguments.length > 1 ? arguments[1] : void 0;
    const _observe = el._observe?.[binding.instance.$.uid];
    if (!_observe)
      return;
    const isIntersecting = entries.some((entry) => entry.isIntersecting);
    if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
      handler(isIntersecting, entries, observer2);
    }
    if (isIntersecting && modifiers.once)
      unmounted$2(el, binding);
    else
      _observe.init = true;
  }, options);
  el._observe = Object(el._observe);
  el._observe[binding.instance.$.uid] = {
    init: false,
    observer
  };
  observer.observe(el);
}
function unmounted$2(el, binding) {
  const observe = el._observe?.[binding.instance.$.uid];
  if (!observe)
    return;
  observe.observer.unobserve(el);
  delete el._observe[binding.instance.$.uid];
}
const Intersect = {
  mounted: mounted$1,
  unmounted: unmounted$2
};
const Intersect$1 = Intersect;
const makeVImgProps = propsFactory({
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...makeVResponsiveProps(),
  ...makeComponentProps(),
  ...makeRoundedProps(),
  ...makeTransitionProps()
}, "VImg");
const VImg = genericComponent()({
  name: "VImg",
  directives: {
    intersect: Intersect$1
  },
  props: makeVImgProps(),
  emits: {
    loadstart: (value) => true,
    load: (value) => true,
    error: (value) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      roundedClasses
    } = useRounded(props2);
    const vm = getCurrentInstance("VImg");
    const currentSrc = shallowRef("");
    const image = ref();
    const state = shallowRef(props2.eager ? "loading" : "idle");
    const naturalWidth = shallowRef();
    const naturalHeight = shallowRef();
    const normalisedSrc = computed(() => {
      return props2.src && typeof props2.src === "object" ? {
        src: props2.src.src,
        srcset: props2.srcset || props2.src.srcset,
        lazySrc: props2.lazySrc || props2.src.lazySrc,
        aspect: Number(props2.aspectRatio || props2.src.aspect || 0)
      } : {
        src: props2.src,
        srcset: props2.srcset,
        lazySrc: props2.lazySrc,
        aspect: Number(props2.aspectRatio || 0)
      };
    });
    const aspectRatio = computed(() => {
      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
    });
    watch(() => props2.src, () => {
      init(state.value !== "idle");
    });
    watch(aspectRatio, (val, oldVal) => {
      if (!val && oldVal && image.value) {
        pollForSize(image.value);
      }
    });
    onBeforeMount(() => init());
    function init(isIntersecting) {
      if (props2.eager && isIntersecting)
        return;
      if (SUPPORTS_INTERSECTION && !isIntersecting && !props2.eager)
        return;
      state.value = "loading";
      if (normalisedSrc.value.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = normalisedSrc.value.lazySrc;
        pollForSize(lazyImg, null);
      }
      if (!normalisedSrc.value.src)
        return;
      nextTick(() => {
        emit2("loadstart", image.value?.currentSrc || normalisedSrc.value.src);
        setTimeout(() => {
          if (vm.isUnmounted)
            return;
          if (image.value?.complete) {
            if (!image.value.naturalWidth) {
              onError();
            }
            if (state.value === "error")
              return;
            if (!aspectRatio.value)
              pollForSize(image.value, null);
            if (state.value === "loading")
              onLoad();
          } else {
            if (!aspectRatio.value)
              pollForSize(image.value);
            getSrc();
          }
        });
      });
    }
    function onLoad() {
      if (vm.isUnmounted)
        return;
      getSrc();
      pollForSize(image.value);
      state.value = "loaded";
      emit2("load", image.value?.currentSrc || normalisedSrc.value.src);
    }
    function onError() {
      if (vm.isUnmounted)
        return;
      state.value = "error";
      emit2("error", image.value?.currentSrc || normalisedSrc.value.src);
    }
    function getSrc() {
      const img = image.value;
      if (img)
        currentSrc.value = img.currentSrc || img.src;
    }
    let timer = -1;
    onBeforeUnmount(() => {
      clearTimeout(timer);
    });
    function pollForSize(img) {
      let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const poll = () => {
        clearTimeout(timer);
        if (vm.isUnmounted)
          return;
        const {
          naturalHeight: imgHeight,
          naturalWidth: imgWidth
        } = img;
        if (imgHeight || imgWidth) {
          naturalWidth.value = imgWidth;
          naturalHeight.value = imgHeight;
        } else if (!img.complete && state.value === "loading" && timeout != null) {
          timer = window.setTimeout(poll, timeout);
        } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
          naturalWidth.value = 1;
          naturalHeight.value = 1;
        }
      };
      poll();
    }
    const containClasses = computed(() => ({
      "v-img__img--cover": props2.cover,
      "v-img__img--contain": !props2.cover
    }));
    const __image = () => {
      if (!normalisedSrc.value.src || state.value === "idle")
        return null;
      const img = createVNode("img", {
        "class": ["v-img__img", containClasses.value],
        "style": {
          objectPosition: props2.position
        },
        "src": normalisedSrc.value.src,
        "srcset": normalisedSrc.value.srcset,
        "alt": props2.alt,
        "crossorigin": props2.crossorigin,
        "referrerpolicy": props2.referrerpolicy,
        "draggable": props2.draggable,
        "sizes": props2.sizes,
        "ref": image,
        "onLoad": onLoad,
        "onError": onError
      }, null);
      const sources = slots.sources?.();
      return createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => [withDirectives(sources ? createVNode("picture", {
          "class": "v-img__picture"
        }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
      });
    };
    const __preloadImage = () => createVNode(MaybeTransition, {
      "transition": props2.transition
    }, {
      default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
        "class": ["v-img__img", "v-img__img--preload", containClasses.value],
        "style": {
          objectPosition: props2.position
        },
        "src": normalisedSrc.value.lazySrc,
        "alt": props2.alt,
        "crossorigin": props2.crossorigin,
        "referrerpolicy": props2.referrerpolicy,
        "draggable": props2.draggable
      }, null)]
    });
    const __placeholder = () => {
      if (!slots.placeholder)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
          "class": "v-img__placeholder"
        }, [slots.placeholder()])]
      });
    };
    const __error = () => {
      if (!slots.error)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props2.transition,
        "appear": true
      }, {
        default: () => [state.value === "error" && createVNode("div", {
          "class": "v-img__error"
        }, [slots.error()])]
      });
    };
    const __gradient = () => {
      if (!props2.gradient)
        return null;
      return createVNode("div", {
        "class": "v-img__gradient",
        "style": {
          backgroundImage: `linear-gradient(${props2.gradient})`
        }
      }, null);
    };
    const isBooted = shallowRef(false);
    {
      const stop2 = watch(aspectRatio, (val) => {
        if (val) {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              isBooted.value = true;
            });
          });
          stop2();
        }
      });
    }
    useRender(() => {
      const responsiveProps = VResponsive.filterProps(props2);
      return withDirectives(createVNode(VResponsive, mergeProps({
        "class": ["v-img", {
          "v-img--booting": !isBooted.value
        }, backgroundColorClasses.value, roundedClasses.value, props2.class],
        "style": [{
          width: convertToUnit(props2.width === "auto" ? naturalWidth.value : props2.width)
        }, backgroundColorStyles.value, props2.style]
      }, responsiveProps, {
        "aspectRatio": aspectRatio.value,
        "aria-label": props2.alt,
        "role": props2.alt ? "img" : void 0
      }), {
        additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
        default: slots.default
      }), [[resolveDirective("intersect"), {
        handler: init,
        options: props2.options
      }, null, {
        once: true
      }]]);
    });
    return {
      currentSrc,
      image,
      state,
      naturalWidth,
      naturalHeight
    };
  }
});
const makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, "border");
function useBorder(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const borderClasses = computed(() => {
    const border = isRef(props2) ? props2.value : props2.border;
    const classes = [];
    if (border === true || border === "") {
      classes.push(`${name}--border`);
    } else if (typeof border === "string" || border === 0) {
      for (const value of String(border).split(" ")) {
        classes.push(`border-${value}`);
      }
    }
    return classes;
  });
  return {
    borderClasses
  };
}
const makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],
    validator(v) {
      const value = parseInt(v);
      return !isNaN(value) && value >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      value <= 24;
    }
  }
}, "elevation");
function useElevation(props2) {
  const elevationClasses = computed(() => {
    const elevation = isRef(props2) ? props2.value : props2.elevation;
    const classes = [];
    if (elevation == null)
      return classes;
    classes.push(`elevation-${elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}
function useSsrBoot() {
  const isBooted = shallowRef(false);
  onMounted(() => {
    window.requestAnimationFrame(() => {
      isBooted.value = true;
    });
  });
  const ssrBootStyles = computed(() => !isBooted.value ? {
    transition: "none !important"
  } : void 0);
  return {
    ssrBootStyles,
    isBooted: readonly(isBooted)
  };
}
const VBtn$1 = "";
const VBtnToggle = "";
const VBtnGroup$1 = "";
const allowedDensities = [null, "default", "comfortable", "compact"];
const makeDensityProps = propsFactory({
  density: {
    type: String,
    default: "default",
    validator: (v) => allowedDensities.includes(v)
  }
}, "density");
function useDensity(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const densityClasses = computed(() => {
    return `${name}--density-${props2.density}`;
  });
  return {
    densityClasses
  };
}
const allowedVariants$2 = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function genOverlays(isClickable, name) {
  return createVNode(Fragment, null, [isClickable && createVNode("span", {
    "key": "overlay",
    "class": `${name}__overlay`
  }, null), createVNode("span", {
    "key": "underlay",
    "class": `${name}__underlay`
  }, null)]);
}
const makeVariantProps = propsFactory({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (v) => allowedVariants$2.includes(v)
  }
}, "variant");
function useVariant(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const variantClasses = computed(() => {
    const {
      variant
    } = unref(props2);
    return `${name}--variant-${variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor(computed(() => {
    const {
      variant,
      color
    } = unref(props2);
    return {
      [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
    };
  }));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}
const makeVBtnGroupProps = propsFactory({
  divided: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps()
}, "VBtnGroup");
const VBtnGroup = genericComponent()({
  name: "VBtnGroup",
  props: makeVBtnGroupProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    provideDefaults({
      VBtn: {
        height: "auto",
        color: toRef(props2, "color"),
        density: toRef(props2, "density"),
        flat: true,
        variant: toRef(props2, "variant")
      }
    });
    useRender(() => {
      return createVNode(props2.tag, {
        "class": ["v-btn-group", {
          "v-btn-group--divided": props2.divided
        }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
        "style": props2.style
      }, slots);
    });
  }
});
const makeGroupProps = propsFactory({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group");
const makeGroupItemProps = propsFactory({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function useGroupItem(props2, injectKey) {
  let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const vm = getCurrentInstance("useGroupItem");
  if (!vm) {
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  }
  const id = getUid();
  provide(Symbol.for(`${injectKey.description}:id`), id);
  const group = inject$1(injectKey, null);
  if (!group) {
    if (!required)
      return group;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }
  const value = toRef(props2, "value");
  const disabled = computed(() => !!(group.disabled.value || props2.disabled));
  group.register({
    id,
    value,
    disabled
  }, vm);
  onBeforeUnmount(() => {
    group.unregister(id);
  });
  const isSelected = computed(() => {
    return group.isSelected(id);
  });
  const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props2.selectedClass]);
  watch(isSelected, (value2) => {
    vm.emit("group:selected", {
      value: value2
    });
  });
  return {
    id,
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: (value2) => group.select(id, value2),
    selectedClass,
    value,
    disabled,
    group
  };
}
function useGroup(props2, injectKey) {
  let isUnmounted = false;
  const items = reactive([]);
  const selected = useProxiedModel(props2, "modelValue", [], (v) => {
    if (v == null)
      return [];
    return getIds(items, wrapInArray(v));
  }, (v) => {
    const arr = getValues(items, v);
    return props2.multiple ? arr : arr[0];
  });
  const groupVm = getCurrentInstance("useGroup");
  function register(item, vm) {
    const unwrapped = item;
    const key = Symbol.for(`${injectKey.description}:id`);
    const children = findChildrenWithProvide(key, groupVm?.vnode);
    const index2 = children.indexOf(vm);
    if (unref(unwrapped.value) == null) {
      unwrapped.value = index2;
    }
    if (index2 > -1) {
      items.splice(index2, 0, unwrapped);
    } else {
      items.push(unwrapped);
    }
  }
  function unregister(id) {
    if (isUnmounted)
      return;
    forceMandatoryValue();
    const index2 = items.findIndex((item) => item.id === id);
    items.splice(index2, 1);
  }
  function forceMandatoryValue() {
    const item = items.find((item2) => !item2.disabled);
    if (item && props2.mandatory === "force" && !selected.value.length) {
      selected.value = [item.id];
    }
  }
  onMounted(() => {
    forceMandatoryValue();
  });
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function select(id, value) {
    const item = items.find((item2) => item2.id === id);
    if (value && item?.disabled)
      return;
    if (props2.multiple) {
      const internalValue = selected.value.slice();
      const index2 = internalValue.findIndex((v) => v === id);
      const isSelected = ~index2;
      value = value ?? !isSelected;
      if (isSelected && props2.mandatory && internalValue.length <= 1)
        return;
      if (!isSelected && props2.max != null && internalValue.length + 1 > props2.max)
        return;
      if (index2 < 0 && value)
        internalValue.push(id);
      else if (index2 >= 0 && !value)
        internalValue.splice(index2, 1);
      selected.value = internalValue;
    } else {
      const isSelected = selected.value.includes(id);
      if (props2.mandatory && isSelected)
        return;
      selected.value = value ?? !isSelected ? [id] : [];
    }
  }
  function step(offset) {
    if (props2.multiple)
      ;
    if (!selected.value.length) {
      const item = items.find((item2) => !item2.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex((i) => i.id === currentId);
      let newIndex = (currentIndex + offset) % items.length;
      let newItem = items[newIndex];
      while (newItem.disabled && newIndex !== currentIndex) {
        newIndex = (newIndex + offset) % items.length;
        newItem = items[newIndex];
      }
      if (newItem.disabled)
        return;
      selected.value = [items[newIndex].id];
    }
  }
  const state = {
    register,
    unregister,
    selected,
    select,
    disabled: toRef(props2, "disabled"),
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: (id) => selected.value.includes(id),
    selectedClass: computed(() => props2.selectedClass),
    items: computed(() => items),
    getItemIndex: (value) => getItemIndex(items, value)
  };
  provide(injectKey, state);
  return state;
}
function getItemIndex(items, value) {
  const ids = getIds(items, [value]);
  if (!ids.length)
    return -1;
  return items.findIndex((item) => item.id === ids[0]);
}
function getIds(items, modelValue) {
  const ids = [];
  modelValue.forEach((value) => {
    const item = items.find((item2) => deepEqual$1(value, item2.value));
    const itemByIndex = items[value];
    if (item?.value != null) {
      ids.push(item.id);
    } else if (itemByIndex != null) {
      ids.push(itemByIndex.id);
    }
  });
  return ids;
}
function getValues(items, ids) {
  const values = [];
  ids.forEach((id) => {
    const itemIndex = items.findIndex((item) => item.id === id);
    if (~itemIndex) {
      const item = items[itemIndex];
      values.push(item.value != null ? item.value : itemIndex);
    }
  });
  return values;
}
const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
const makeVBtnToggleProps = propsFactory({
  ...makeVBtnGroupProps(),
  ...makeGroupProps()
}, "VBtnToggle");
genericComponent()({
  name: "VBtnToggle",
  props: makeVBtnToggleProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      next,
      prev,
      select,
      selected
    } = useGroup(props2, VBtnToggleSymbol);
    useRender(() => {
      const btnGroupProps = VBtnGroup.filterProps(props2);
      return createVNode(VBtnGroup, mergeProps({
        "class": ["v-btn-toggle", props2.class]
      }, btnGroupProps, {
        "style": props2.style
      }), {
        default: () => [slots.default?.({
          isSelected,
          next,
          prev,
          select,
          selected
        })]
      });
    });
    return {
      next,
      prev,
      select
    };
  }
});
const VIcon$1 = "";
const predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
const makeSizeProps = propsFactory({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function useSize(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  return destructComputed(() => {
    let sizeClasses;
    let sizeStyles;
    if (includes(predefinedSizes, props2.size)) {
      sizeClasses = `${name}--size-${props2.size}`;
    } else if (props2.size) {
      sizeStyles = {
        width: convertToUnit(props2.size),
        height: convertToUnit(props2.size)
      };
    }
    return {
      sizeClasses,
      sizeStyles
    };
  });
}
const makeVIconProps = propsFactory({
  color: String,
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  ...makeComponentProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "i"
  }),
  ...makeThemeProps()
}, "VIcon");
const VIcon = genericComponent()({
  name: "VIcon",
  props: makeVIconProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const slotIcon = ref();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      iconData
    } = useIcon(computed(() => slotIcon.value || props2.icon));
    const {
      sizeClasses
    } = useSize(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    useRender(() => {
      const slotValue = slots.default?.();
      if (slotValue) {
        slotIcon.value = flattenFragments(slotValue).filter((node) => node.type === Text && node.children && typeof node.children === "string")[0]?.children;
      }
      return createVNode(iconData.value.component, {
        "tag": props2.tag,
        "icon": iconData.value.icon,
        "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
          "v-icon--clickable": !!attrs.onClick,
          "v-icon--start": props2.start,
          "v-icon--end": props2.end
        }, props2.class],
        "style": [!sizeClasses.value ? {
          fontSize: convertToUnit(props2.size),
          height: convertToUnit(props2.size),
          width: convertToUnit(props2.size)
        } : void 0, textColorStyles.value, props2.style],
        "role": attrs.onClick ? "button" : void 0,
        "aria-hidden": !attrs.onClick
      }, {
        default: () => [slotValue]
      });
    });
    return {};
  }
});
const VProgressCircular$1 = "";
function useIntersectionObserver(callback, options) {
  const intersectionRef = ref();
  const isIntersecting = shallowRef(false);
  if (SUPPORTS_INTERSECTION) {
    const observer = new IntersectionObserver((entries) => {
      callback?.(entries, observer);
      isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
    }, options);
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(intersectionRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(oldValue);
        isIntersecting.value = false;
      }
      if (newValue)
        observer.observe(newValue);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef,
    isIntersecting
  };
}
const makeVProgressCircularProps = propsFactory({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...makeComponentProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "div"
  }),
  ...makeThemeProps()
}, "VProgressCircular");
const VProgressCircular = genericComponent()({
  name: "VProgressCircular",
  props: makeVProgressCircularProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const root = ref();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor(toRef(props2, "bgColor"));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props2.modelValue))));
    const width = computed(() => Number(props2.width));
    const size2 = computed(() => {
      return sizeStyles.value ? Number(props2.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
    });
    const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
    const strokeWidth = computed(() => width.value / size2.value * diameter.value);
    const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    watchEffect(() => {
      intersectionRef.value = root.value;
      resizeRef.value = root.value;
    });
    useRender(() => createVNode(props2.tag, {
      "ref": root,
      "class": ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!props2.indeterminate,
        "v-progress-circular--visible": isIntersecting.value,
        "v-progress-circular--disable-shrink": props2.indeterminate === "disable-shrink"
      }, themeClasses.value, sizeClasses.value, textColorClasses.value, props2.class],
      "style": [sizeStyles.value, textColorStyles.value, props2.style],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props2.indeterminate ? void 0 : normalizedValue.value
    }, {
      default: () => [createVNode("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props2.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [createVNode("circle", {
        "class": ["v-progress-circular__underlay", underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null), createVNode("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null)]), slots.default && createVNode("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])]
    }));
    return {};
  }
});
const VProgressLinear$1 = "";
const oppositeMap = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const makeLocationProps = propsFactory({
  location: String
}, "location");
function useLocation(props2) {
  let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let offset = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl
  } = useRtl();
  const locationStyles = computed(() => {
    if (!props2.location)
      return {};
    const {
      side,
      align
    } = parseAnchor(props2.location.split(" ").length > 1 ? props2.location : `${props2.location} center`, isRtl.value);
    function getOffset2(side2) {
      return offset ? offset(side2) : 0;
    }
    const styles = {};
    if (side !== "center") {
      if (opposite)
        styles[oppositeMap[side]] = `calc(100% - ${getOffset2(side)}px)`;
      else
        styles[side] = 0;
    }
    if (align !== "center") {
      if (opposite)
        styles[oppositeMap[align]] = `calc(100% - ${getOffset2(align)}px)`;
      else
        styles[align] = 0;
    } else {
      if (side === "center")
        styles.top = styles.left = "50%";
      else {
        styles[{
          top: "left",
          bottom: "left",
          left: "top",
          right: "top"
        }[side]] = "50%";
      }
      styles.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[side];
    }
    return styles;
  });
  return {
    locationStyles
  };
}
const makeVProgressLinearProps = propsFactory({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: true
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VProgressLinear");
const VProgressLinear = genericComponent()({
  name: "VProgressLinear",
  props: makeVProgressLinearProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const progress = useProxiedModel(props2, "modelValue");
    const {
      isRtl,
      rtlClasses
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(props2, "color");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed(() => props2.bgColor || props2.color));
    const {
      backgroundColorClasses: barColorClasses,
      backgroundColorStyles: barColorStyles
    } = useBackgroundColor(props2, "color");
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const max = computed(() => parseInt(props2.max, 10));
    const height = computed(() => parseInt(props2.height, 10));
    const normalizedBuffer = computed(() => parseFloat(props2.bufferValue) / max.value * 100);
    const normalizedValue = computed(() => parseFloat(progress.value) / max.value * 100);
    const isReversed = computed(() => isRtl.value !== props2.reverse);
    const transition = computed(() => props2.indeterminate ? "fade-transition" : "slide-x-transition");
    const opacity = computed(() => {
      return props2.bgOpacity == null ? props2.bgOpacity : parseFloat(props2.bgOpacity);
    });
    function handleClick(e) {
      if (!intersectionRef.value)
        return;
      const {
        left,
        right,
        width
      } = intersectionRef.value.getBoundingClientRect();
      const value = isReversed.value ? width - e.clientX + (right - width) : e.clientX - left;
      progress.value = Math.round(value / width * max.value);
    }
    useRender(() => createVNode(props2.tag, {
      "ref": intersectionRef,
      "class": ["v-progress-linear", {
        "v-progress-linear--absolute": props2.absolute,
        "v-progress-linear--active": props2.active && isIntersecting.value,
        "v-progress-linear--reverse": isReversed.value,
        "v-progress-linear--rounded": props2.rounded,
        "v-progress-linear--rounded-bar": props2.roundedBar,
        "v-progress-linear--striped": props2.striped
      }, roundedClasses.value, themeClasses.value, rtlClasses.value, props2.class],
      "style": [{
        bottom: props2.location === "bottom" ? 0 : void 0,
        top: props2.location === "top" ? 0 : void 0,
        height: props2.active ? convertToUnit(height.value) : 0,
        "--v-progress-linear-height": convertToUnit(height.value),
        ...locationStyles.value
      }, props2.style],
      "role": "progressbar",
      "aria-hidden": props2.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": props2.max,
      "aria-valuenow": props2.indeterminate ? void 0 : normalizedValue.value,
      "onClick": props2.clickable && handleClick
    }, {
      default: () => [props2.stream && createVNode("div", {
        "key": "stream",
        "class": ["v-progress-linear__stream", textColorClasses.value],
        "style": {
          ...textColorStyles.value,
          [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
          borderTop: `${convertToUnit(height.value / 2)} dotted`,
          opacity: opacity.value,
          top: `calc(50% - ${convertToUnit(height.value / 4)})`,
          width: convertToUnit(100 - normalizedBuffer.value, "%"),
          "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
        }
      }, null), createVNode("div", {
        "class": ["v-progress-linear__background", backgroundColorClasses.value],
        "style": [backgroundColorStyles.value, {
          opacity: opacity.value,
          width: convertToUnit(!props2.stream ? 100 : normalizedBuffer.value, "%")
        }]
      }, null), createVNode(Transition, {
        "name": transition.value
      }, {
        default: () => [!props2.indeterminate ? createVNode("div", {
          "class": ["v-progress-linear__determinate", barColorClasses.value],
          "style": [barColorStyles.value, {
            width: convertToUnit(normalizedValue.value, "%")
          }]
        }, null) : createVNode("div", {
          "class": "v-progress-linear__indeterminate"
        }, [["long", "short"].map((bar) => createVNode("div", {
          "key": bar,
          "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
          "style": barColorStyles.value
        }, null))])]
      }), slots.default && createVNode("div", {
        "class": "v-progress-linear__content"
      }, [slots.default({
        value: normalizedValue.value,
        buffer: normalizedBuffer.value
      })])]
    }));
    return {};
  }
});
const makeLoaderProps = propsFactory({
  loading: [Boolean, String]
}, "loader");
function useLoader(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const loaderClasses = computed(() => ({
    [`${name}--loading`]: props2.loading
  }));
  return {
    loaderClasses
  };
}
function LoaderSlot(props2, _ref) {
  let {
    slots
  } = _ref;
  return createVNode("div", {
    "class": `${props2.name}__loader`
  }, [slots.default?.({
    color: props2.color,
    isActive: props2.active
  }) || createVNode(VProgressLinear, {
    "absolute": props2.absolute,
    "active": props2.active,
    "color": props2.color,
    "height": "2",
    "indeterminate": true
  }, null)]);
}
const positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
const makePositionProps = propsFactory({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (v) => positionValues.includes(v)
    )
  }
}, "position");
function usePosition(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const positionClasses = computed(() => {
    return props2.position ? `${name}--${props2.position}` : void 0;
  });
  return {
    positionClasses
  };
}
function useRoute$1() {
  const vm = getCurrentInstance("useRoute");
  return computed(() => vm?.proxy?.$route);
}
function useRouter$1() {
  return getCurrentInstance("useRouter")?.proxy?.$router;
}
function useLink$1(props2, attrs) {
  const RouterLink2 = resolveDynamicComponent("RouterLink");
  const isLink = computed(() => !!(props2.href || props2.to));
  const isClickable = computed(() => {
    return isLink?.value || hasEvent(attrs, "click") || hasEvent(props2, "click");
  });
  if (typeof RouterLink2 === "string") {
    return {
      isLink,
      isClickable,
      href: toRef(props2, "href")
    };
  }
  const link = props2.to ? RouterLink2.useLink(props2) : void 0;
  const route = useRoute$1();
  return {
    isLink,
    isClickable,
    route: link?.route,
    navigate: link?.navigate,
    isActive: link && computed(() => {
      if (!props2.exact)
        return link.isActive?.value;
      if (!route.value)
        return link.isExactActive?.value;
      return link.isExactActive?.value && deepEqual$1(link.route.value.query, route.value.query);
    }),
    href: computed(() => props2.to ? link?.route.value.href : props2.href)
  };
}
const makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let inTransition = false;
function useBackButton(router2, cb) {
  let popped = false;
  let removeBefore;
  let removeAfter;
  if (IN_BROWSER) {
    nextTick(() => {
      window.addEventListener("popstate", onPopstate);
      removeBefore = router2?.beforeEach((to, from, next) => {
        if (!inTransition) {
          setTimeout(() => popped ? cb(next) : next());
        } else {
          popped ? cb(next) : next();
        }
        inTransition = true;
      });
      removeAfter = router2?.afterEach(() => {
        inTransition = false;
      });
    });
    onScopeDispose(() => {
      window.removeEventListener("popstate", onPopstate);
      removeBefore?.();
      removeAfter?.();
    });
  }
  function onPopstate(e) {
    if (e.state?.replaced)
      return;
    popped = true;
    setTimeout(() => popped = false);
  }
}
function useSelectLink(link, select) {
  watch(() => link.isActive?.value, (isActive) => {
    if (link.isLink.value && isActive && select) {
      nextTick(() => {
        select(true);
      });
    }
  }, {
    immediate: true
  });
}
const VRipple = "";
const stopSymbol = Symbol("rippleStop");
const DELAY_RIPPLE = 80;
function transform(el, value) {
  el.style.transform = value;
  el.style.webkitTransform = value;
}
function isTouchEvent(e) {
  return e.constructor.name === "TouchEvent";
}
function isKeyboardEvent(e) {
  return e.constructor.name === "KeyboardEvent";
}
const calculate = function(e, el) {
  let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let localX = 0;
  let localY = 0;
  if (!isKeyboardEvent(e)) {
    const offset = el.getBoundingClientRect();
    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e;
    localX = target.clientX - offset.left;
    localY = target.clientY - offset.top;
  }
  let radius = 0;
  let scale = 0.3;
  if (el._ripple?.circle) {
    scale = 0.15;
    radius = el.clientWidth / 2;
    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
  } else {
    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2;
  }
  const centerX = `${(el.clientWidth - radius * 2) / 2}px`;
  const centerY = `${(el.clientHeight - radius * 2) / 2}px`;
  const x2 = value.center ? centerX : `${localX - radius}px`;
  const y = value.center ? centerY : `${localY - radius}px`;
  return {
    radius,
    scale,
    x: x2,
    y,
    centerX,
    centerY
  };
};
const ripples = {
  /* eslint-disable max-statements */
  show(e, el) {
    let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!el?._ripple?.enabled) {
      return;
    }
    const container = document.createElement("span");
    const animation = document.createElement("span");
    container.appendChild(animation);
    container.className = "v-ripple__container";
    if (value.class) {
      container.className += ` ${value.class}`;
    }
    const {
      radius,
      scale,
      x: x2,
      y,
      centerX,
      centerY
    } = calculate(e, el, value);
    const size2 = `${radius * 2}px`;
    animation.className = "v-ripple__animation";
    animation.style.width = size2;
    animation.style.height = size2;
    el.appendChild(container);
    const computed2 = window.getComputedStyle(el);
    if (computed2 && computed2.position === "static") {
      el.style.position = "relative";
      el.dataset.previousPosition = "static";
    }
    animation.classList.add("v-ripple__animation--enter");
    animation.classList.add("v-ripple__animation--visible");
    transform(animation, `translate(${x2}, ${y}) scale3d(${scale},${scale},${scale})`);
    animation.dataset.activated = String(performance.now());
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--in");
      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(el) {
    if (!el?._ripple?.enabled)
      return;
    const ripples2 = el.getElementsByClassName("v-ripple__animation");
    if (ripples2.length === 0)
      return;
    const animation = ripples2[ripples2.length - 1];
    if (animation.dataset.isHiding)
      return;
    else
      animation.dataset.isHiding = "true";
    const diff = performance.now() - Number(animation.dataset.activated);
    const delay = Math.max(250 - diff, 0);
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--in");
      animation.classList.add("v-ripple__animation--out");
      setTimeout(() => {
        const ripples3 = el.getElementsByClassName("v-ripple__animation");
        if (ripples3.length === 1 && el.dataset.previousPosition) {
          el.style.position = el.dataset.previousPosition;
          delete el.dataset.previousPosition;
        }
        if (animation.parentNode?.parentNode === el)
          el.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }
};
function isRippleEnabled(value) {
  return typeof value === "undefined" || !!value;
}
function rippleShow(e) {
  const value = {};
  const element = e.currentTarget;
  if (!element?._ripple || element._ripple.touched || e[stopSymbol])
    return;
  e[stopSymbol] = true;
  if (isTouchEvent(e)) {
    element._ripple.touched = true;
    element._ripple.isTouch = true;
  } else {
    if (element._ripple.isTouch)
      return;
  }
  value.center = element._ripple.centered || isKeyboardEvent(e);
  if (element._ripple.class) {
    value.class = element._ripple.class;
  }
  if (isTouchEvent(e)) {
    if (element._ripple.showTimerCommit)
      return;
    element._ripple.showTimerCommit = () => {
      ripples.show(e, element, value);
    };
    element._ripple.showTimer = window.setTimeout(() => {
      if (element?._ripple?.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
      }
    }, DELAY_RIPPLE);
  } else {
    ripples.show(e, element, value);
  }
}
function rippleStop(e) {
  e[stopSymbol] = true;
}
function rippleHide(e) {
  const element = e.currentTarget;
  if (!element?._ripple)
    return;
  window.clearTimeout(element._ripple.showTimer);
  if (e.type === "touchend" && element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit();
    element._ripple.showTimerCommit = null;
    element._ripple.showTimer = window.setTimeout(() => {
      rippleHide(e);
    });
    return;
  }
  window.setTimeout(() => {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripples.hide(element);
}
function rippleCancelShow(e) {
  const element = e.currentTarget;
  if (!element?._ripple)
    return;
  if (element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit = null;
  }
  window.clearTimeout(element._ripple.showTimer);
}
let keyboardRipple = false;
function keyboardRippleShow(e) {
  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {
    keyboardRipple = true;
    rippleShow(e);
  }
}
function keyboardRippleHide(e) {
  keyboardRipple = false;
  rippleHide(e);
}
function focusRippleHide(e) {
  if (keyboardRipple) {
    keyboardRipple = false;
    rippleHide(e);
  }
}
function updateRipple(el, binding, wasEnabled) {
  const {
    value,
    modifiers
  } = binding;
  const enabled = isRippleEnabled(value);
  if (!enabled) {
    ripples.hide(el);
  }
  el._ripple = el._ripple ?? {};
  el._ripple.enabled = enabled;
  el._ripple.centered = modifiers.center;
  el._ripple.circle = modifiers.circle;
  if (isObject(value) && value.class) {
    el._ripple.class = value.class;
  }
  if (enabled && !wasEnabled) {
    if (modifiers.stop) {
      el.addEventListener("touchstart", rippleStop, {
        passive: true
      });
      el.addEventListener("mousedown", rippleStop);
      return;
    }
    el.addEventListener("touchstart", rippleShow, {
      passive: true
    });
    el.addEventListener("touchend", rippleHide, {
      passive: true
    });
    el.addEventListener("touchmove", rippleCancelShow, {
      passive: true
    });
    el.addEventListener("touchcancel", rippleHide);
    el.addEventListener("mousedown", rippleShow);
    el.addEventListener("mouseup", rippleHide);
    el.addEventListener("mouseleave", rippleHide);
    el.addEventListener("keydown", keyboardRippleShow);
    el.addEventListener("keyup", keyboardRippleHide);
    el.addEventListener("blur", focusRippleHide);
    el.addEventListener("dragstart", rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el);
  }
}
function removeListeners(el) {
  el.removeEventListener("mousedown", rippleShow);
  el.removeEventListener("touchstart", rippleShow);
  el.removeEventListener("touchend", rippleHide);
  el.removeEventListener("touchmove", rippleCancelShow);
  el.removeEventListener("touchcancel", rippleHide);
  el.removeEventListener("mouseup", rippleHide);
  el.removeEventListener("mouseleave", rippleHide);
  el.removeEventListener("keydown", keyboardRippleShow);
  el.removeEventListener("keyup", keyboardRippleHide);
  el.removeEventListener("dragstart", rippleHide);
  el.removeEventListener("blur", focusRippleHide);
}
function mounted(el, binding) {
  updateRipple(el, binding, false);
}
function unmounted$1(el) {
  delete el._ripple;
  removeListeners(el);
}
function updated$1(el, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }
  const wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el, binding, wasEnabled);
}
const Ripple = {
  mounted,
  unmounted: unmounted$1,
  updated: updated$1
};
const makeVBtnProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  symbol: {
    type: null,
    default: VBtnToggleSymbol
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: IconValue,
  appendIcon: IconValue,
  block: Boolean,
  slim: Boolean,
  stacked: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  text: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeLoaderProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "button"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "elevated"
  })
}, "VBtn");
const VBtn = genericComponent()({
  name: "VBtn",
  directives: {
    Ripple
  },
  props: makeVBtnProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2);
    const group = useGroupItem(props2, props2.symbol, false);
    const link = useLink$1(props2, attrs);
    const isActive = computed(() => {
      if (props2.active !== void 0) {
        return props2.active;
      }
      if (link.isLink.value) {
        return link.isActive?.value;
      }
      return group?.isSelected.value;
    });
    const isDisabled = computed(() => group?.disabled.value || props2.disabled);
    const isElevated = computed(() => {
      return props2.variant === "elevated" && !(props2.disabled || props2.flat || props2.border);
    });
    const valueAttr = computed(() => {
      if (props2.value === void 0 || typeof props2.value === "symbol")
        return void 0;
      return Object(props2.value) === props2.value ? JSON.stringify(props2.value, null, 0) : props2.value;
    });
    function onClick(e) {
      if (isDisabled.value || link.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || e.button !== 0 || attrs.target === "_blank"))
        return;
      link.navigate?.(e);
      group?.toggle();
    }
    useSelectLink(link, group?.select);
    useRender(() => {
      const Tag = link.isLink.value ? "a" : props2.tag;
      const hasPrepend = !!(props2.prependIcon || slots.prepend);
      const hasAppend = !!(props2.appendIcon || slots.append);
      const hasIcon = !!(props2.icon && props2.icon !== true);
      const hasColor = group?.isSelected.value && (!link.isLink.value || link.isActive?.value) || !group || link.isActive?.value;
      return withDirectives(createVNode(Tag, {
        "type": Tag === "a" ? void 0 : "button",
        "class": ["v-btn", group?.selectedClass.value, {
          "v-btn--active": isActive.value,
          "v-btn--block": props2.block,
          "v-btn--disabled": isDisabled.value,
          "v-btn--elevated": isElevated.value,
          "v-btn--flat": props2.flat,
          "v-btn--icon": !!props2.icon,
          "v-btn--loading": props2.loading,
          "v-btn--slim": props2.slim,
          "v-btn--stacked": props2.stacked
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props2.class],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, locationStyles.value, sizeStyles.value, props2.style],
        "disabled": isDisabled.value || void 0,
        "href": link.href.value,
        "onClick": onClick,
        "value": valueAttr.value
      }, {
        default: () => [genOverlays(true, "v-btn"), !props2.icon && hasPrepend && createVNode("span", {
          "key": "prepend",
          "class": "v-btn__prepend"
        }, [!slots.prepend ? createVNode(VIcon, {
          "key": "prepend-icon",
          "icon": props2.prependIcon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !props2.prependIcon,
          "defaults": {
            VIcon: {
              icon: props2.prependIcon
            }
          }
        }, slots.prepend)]), createVNode("span", {
          "class": "v-btn__content",
          "data-no-activator": ""
        }, [!slots.default && hasIcon ? createVNode(VIcon, {
          "key": "content-icon",
          "icon": props2.icon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "content-defaults",
          "disabled": !hasIcon,
          "defaults": {
            VIcon: {
              icon: props2.icon
            }
          }
        }, {
          default: () => [slots.default?.() ?? props2.text]
        })]), !props2.icon && hasAppend && createVNode("span", {
          "key": "append",
          "class": "v-btn__append"
        }, [!slots.append ? createVNode(VIcon, {
          "key": "append-icon",
          "icon": props2.appendIcon
        }, null) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !props2.appendIcon,
          "defaults": {
            VIcon: {
              icon: props2.appendIcon
            }
          }
        }, slots.append)]), !!props2.loading && createVNode("span", {
          "key": "loader",
          "class": "v-btn__loader"
        }, [slots.loader?.() ?? createVNode(VProgressCircular, {
          "color": typeof props2.loading === "boolean" ? void 0 : props2.loading,
          "indeterminate": true,
          "size": "23",
          "width": "2"
        }, null)])]
      }), [[resolveDirective("ripple"), !isDisabled.value && props2.ripple, null]]);
    });
    return {
      group
    };
  }
});
const VAlert$1 = "";
const VAlertTitle = createSimpleFunctional("v-alert-title");
const allowedTypes = ["success", "info", "warning", "error"];
const makeVAlertProps = propsFactory({
  border: {
    type: [Boolean, String],
    validator: (val) => {
      return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
    }
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: IconValue,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: true
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (val) => allowedTypes.includes(val)
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VAlert");
const VAlert = genericComponent()({
  name: "VAlert",
  props: makeVAlertProps(),
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const icon = computed(() => {
      if (props2.icon === false)
        return void 0;
      if (!props2.type)
        return props2.icon;
      return props2.icon ?? `$${props2.type}`;
    });
    const variantProps = computed(() => ({
      color: props2.color ?? props2.type,
      variant: props2.variant
    }));
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "borderColor"));
    const {
      t
    } = useLocale();
    const closeProps = computed(() => ({
      "aria-label": t(props2.closeLabel),
      onClick(e) {
        isActive.value = false;
        emit2("click:close", e);
      }
    }));
    return () => {
      const hasPrepend = !!(slots.prepend || icon.value);
      const hasTitle = !!(slots.title || props2.title);
      const hasClose = !!(slots.close || props2.closable);
      return isActive.value && createVNode(props2.tag, {
        "class": ["v-alert", props2.border && {
          "v-alert--border": !!props2.border,
          [`v-alert--border-${props2.border === true ? "start" : props2.border}`]: true
        }, {
          "v-alert--prominent": props2.prominent
        }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props2.class],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props2.style],
        "role": "alert"
      }, {
        default: () => [genOverlays(false, "v-alert"), props2.border && createVNode("div", {
          "key": "border",
          "class": ["v-alert__border", textColorClasses.value],
          "style": textColorStyles.value
        }, null), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-alert__prepend"
        }, [!slots.prepend ? createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props2.density,
          "icon": icon.value,
          "size": props2.prominent ? 44 : 28
        }, null) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !icon.value,
          "defaults": {
            VIcon: {
              density: props2.density,
              icon: icon.value,
              size: props2.prominent ? 44 : 28
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-alert__content"
        }, [hasTitle && createVNode(VAlertTitle, {
          "key": "title"
        }, {
          default: () => [slots.title?.() ?? props2.title]
        }), slots.text?.() ?? props2.text, slots.default?.()]), slots.append && createVNode("div", {
          "key": "append",
          "class": "v-alert__append"
        }, [slots.append()]), hasClose && createVNode("div", {
          "key": "close",
          "class": "v-alert__close"
        }, [!slots.close ? createVNode(VBtn, mergeProps({
          "key": "close-btn",
          "icon": props2.closeIcon,
          "size": "x-small",
          "variant": "text"
        }, closeProps.value), null) : createVNode(VDefaultsProvider, {
          "key": "close-defaults",
          "defaults": {
            VBtn: {
              icon: props2.closeIcon,
              size: "x-small",
              variant: "text"
            }
          }
        }, {
          default: () => [slots.close?.({
            props: closeProps.value
          })]
        })])]
      });
    };
  }
});
const VAutocomplete$1 = "";
const VAvatar$1 = "";
const makeVAvatarProps = propsFactory({
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  image: String,
  text: String,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "VAvatar");
const VAvatar = genericComponent()({
  name: "VAvatar",
  props: makeVAvatarProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props2);
    useRender(() => createVNode(props2.tag, {
      "class": ["v-avatar", {
        "v-avatar--start": props2.start,
        "v-avatar--end": props2.end
      }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, props2.class],
      "style": [colorStyles.value, sizeStyles.value, props2.style]
    }, {
      default: () => [!slots.default ? props2.image ? createVNode(VImg, {
        "key": "image",
        "src": props2.image,
        "alt": "",
        "cover": true
      }, null) : props2.icon ? createVNode(VIcon, {
        "key": "icon",
        "icon": props2.icon
      }, null) : props2.text : createVNode(VDefaultsProvider, {
        "key": "content-defaults",
        "defaults": {
          VImg: {
            cover: true,
            image: props2.image
          },
          VIcon: {
            icon: props2.icon
          }
        }
      }, {
        default: () => [slots.default()]
      }), genOverlays(false, "v-avatar")]
    }));
    return {};
  }
});
const VSelectionControl$1 = "";
const VLabel$1 = "";
const makeVLabelProps = propsFactory({
  text: String,
  onClick: EventProp(),
  ...makeComponentProps(),
  ...makeThemeProps()
}, "VLabel");
const VLabel = genericComponent()({
  name: "VLabel",
  props: makeVLabelProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode("label", {
      "class": ["v-label", {
        "v-label--clickable": !!props2.onClick
      }, props2.class],
      "style": props2.style,
      "onClick": props2.onClick
    }, [props2.text, slots.default?.()]));
    return {};
  }
});
const VSelectionControlGroup$1 = "";
const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
const makeSelectionControlGroupProps = propsFactory({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: IconValue,
  trueIcon: IconValue,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: deepEqual$1
  },
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeThemeProps()
}, "SelectionControlGroup");
const makeVSelectionControlGroupProps = propsFactory({
  ...makeSelectionControlGroupProps({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup");
const VSelectionControlGroup = genericComponent()({
  name: "VSelectionControlGroup",
  props: makeVSelectionControlGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props2, "modelValue");
    const uid2 = getUid();
    const id = computed(() => props2.id || `v-selection-control-group-${uid2}`);
    const name = computed(() => props2.name || id.value);
    const updateHandlers = /* @__PURE__ */ new Set();
    provide(VSelectionControlGroupSymbol, {
      modelValue,
      forceUpdate: () => {
        updateHandlers.forEach((fn) => fn());
      },
      onForceUpdate: (cb) => {
        updateHandlers.add(cb);
        onScopeDispose(() => {
          updateHandlers.delete(cb);
        });
      }
    });
    provideDefaults({
      [props2.defaultsTarget]: {
        color: toRef(props2, "color"),
        disabled: toRef(props2, "disabled"),
        density: toRef(props2, "density"),
        error: toRef(props2, "error"),
        inline: toRef(props2, "inline"),
        modelValue,
        multiple: computed(() => !!props2.multiple || props2.multiple == null && Array.isArray(modelValue.value)),
        name,
        falseIcon: toRef(props2, "falseIcon"),
        trueIcon: toRef(props2, "trueIcon"),
        readonly: toRef(props2, "readonly"),
        ripple: toRef(props2, "ripple"),
        type: toRef(props2, "type"),
        valueComparator: toRef(props2, "valueComparator")
      }
    });
    useRender(() => createVNode("div", {
      "class": ["v-selection-control-group", {
        "v-selection-control-group--inline": props2.inline
      }, props2.class],
      "style": props2.style,
      "role": props2.type === "radio" ? "radiogroup" : void 0
    }, [slots.default?.()]));
    return {};
  }
});
const makeVSelectionControlProps = propsFactory({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...makeComponentProps(),
  ...makeSelectionControlGroupProps()
}, "VSelectionControl");
function useSelectionControl(props2) {
  const group = inject$1(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props2);
  const modelValue = useProxiedModel(props2, "modelValue");
  const trueValue = computed(() => props2.trueValue !== void 0 ? props2.trueValue : props2.value !== void 0 ? props2.value : true);
  const falseValue = computed(() => props2.falseValue !== void 0 ? props2.falseValue : false);
  const isMultiple = computed(() => !!props2.multiple || props2.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? wrapInArray(val).some((v) => props2.valueComparator(v, trueValue.value)) : props2.valueComparator(val, trueValue.value);
    },
    set(val) {
      if (props2.readonly)
        return;
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props2.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    if (props2.error || props2.disabled)
      return void 0;
    return model.value ? props2.color : props2.baseColor;
  }));
  const {
    backgroundColorClasses,
    backgroundColorStyles
  } = useBackgroundColor(computed(() => {
    return model.value && !props2.error && !props2.disabled ? props2.color : void 0;
  }));
  const icon = computed(() => model.value ? props2.trueIcon : props2.falseIcon);
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    backgroundColorClasses,
    backgroundColorStyles,
    icon
  };
}
const VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeVSelectionControlProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      group,
      densityClasses,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      backgroundColorClasses,
      backgroundColorStyles,
      trueValue
    } = useSelectionControl(props2);
    const uid2 = getUid();
    const isFocused = shallowRef(false);
    const isFocusVisible = shallowRef(false);
    const input = ref();
    const id = computed(() => props2.id || `input-${uid2}`);
    const isInteractive = computed(() => !props2.disabled && !props2.readonly);
    group?.onForceUpdate(() => {
      if (input.value) {
        input.value.checked = model.value;
      }
    });
    function onFocus(e) {
      if (!isInteractive.value)
        return;
      isFocused.value = true;
      if (matchesSelector(e.target, ":focus-visible") !== false) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    function onClickLabel(e) {
      e.stopPropagation();
    }
    function onInput(e) {
      if (!isInteractive.value)
        return;
      if (props2.readonly && group) {
        nextTick(() => group.forceUpdate());
      }
      model.value = e.target.checked;
    }
    useRender(() => {
      const label = slots.label ? slots.label({
        label: props2.label,
        props: {
          for: id.value
        }
      }) : props2.label;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const inputNode = createVNode("input", mergeProps({
        "ref": input,
        "checked": model.value,
        "disabled": !!props2.disabled,
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "aria-disabled": !!props2.disabled,
        "type": props2.type,
        "value": trueValue.value,
        "name": props2.name,
        "aria-checked": props2.type === "checkbox" ? model.value : void 0
      }, inputAttrs), null);
      return createVNode("div", mergeProps({
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props2.disabled,
          "v-selection-control--error": props2.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": props2.inline
        }, densityClasses.value, props2.class]
      }, rootAttrs, {
        "style": props2.style
      }), [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value],
        "style": textColorStyles.value
      }, [slots.default?.({
        backgroundColorClasses,
        backgroundColorStyles
      }), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"]
      }, [slots.input?.({
        model,
        textColorClasses,
        textColorStyles,
        backgroundColorClasses,
        backgroundColorStyles,
        inputNode,
        icon: icon.value,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      }) ?? createVNode(Fragment, null, [icon.value && createVNode(VIcon, {
        "key": "icon",
        "icon": icon.value
      }, null), inputNode])]), [[resolveDirective("ripple"), props2.ripple && [!props2.disabled && !props2.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
        "for": id.value,
        "onClick": onClickLabel
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});
const makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeVSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn");
const VCheckboxBtn = genericComponent()({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:indeterminate": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props2, "indeterminate");
    const model = useProxiedModel(props2, "modelValue");
    function onChange(v) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    const falseIcon = computed(() => {
      return indeterminate.value ? props2.indeterminateIcon : props2.falseIcon;
    });
    const trueIcon = computed(() => {
      return indeterminate.value ? props2.indeterminateIcon : props2.trueIcon;
    });
    useRender(() => {
      const controlProps = omit(VSelectionControl.filterProps(props2), ["modelValue"]);
      return createVNode(VSelectionControl, mergeProps(controlProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": [($event) => model.value = $event, onChange],
        "class": ["v-checkbox-btn", props2.class],
        "style": props2.style,
        "type": "checkbox",
        "falseIcon": falseIcon.value,
        "trueIcon": trueIcon.value,
        "aria-checked": indeterminate.value ? "mixed" : void 0
      }), slots);
    });
    return {};
  }
});
const VInput$1 = "";
function useInputIcon(props2) {
  const {
    t
  } = useLocale();
  function InputIcon(_ref) {
    let {
      name
    } = _ref;
    const localeKey = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[name];
    const listener = props2[`onClick:${name}`];
    const label = listener && localeKey ? t(`$vuetify.input.${localeKey}`, props2.label ?? "") : void 0;
    return createVNode(VIcon, {
      "icon": props2[`${name}Icon`],
      "aria-label": label,
      "onClick": listener
    }, null);
  }
  return {
    InputIcon
  };
}
const VMessages$1 = "";
const makeVMessagesProps = propsFactory({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...makeComponentProps(),
  ...makeTransitionProps({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })
}, "VMessages");
const VMessages = genericComponent()({
  name: "VMessages",
  props: makeVMessagesProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const messages = computed(() => wrapInArray(props2.messages));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props2.color));
    useRender(() => createVNode(MaybeTransition, {
      "transition": props2.transition,
      "tag": "div",
      "class": ["v-messages", textColorClasses.value, props2.class],
      "style": [textColorStyles.value, props2.style],
      "role": "alert",
      "aria-live": "polite"
    }, {
      default: () => [props2.active && messages.value.map((message, i) => createVNode("div", {
        "class": "v-messages__message",
        "key": `${i}-${messages.value}`
      }, [slots.message ? slots.message({
        message
      }) : message]))]
    }));
    return {};
  }
});
const makeFocusProps = propsFactory({
  focused: Boolean,
  "onUpdate:focused": EventProp()
}, "focus");
function useFocus(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const isFocused = useProxiedModel(props2, "focused");
  const focusClasses = computed(() => {
    return {
      [`${name}--focused`]: isFocused.value
    };
  });
  function focus() {
    isFocused.value = true;
  }
  function blur() {
    isFocused.value = false;
  }
  return {
    focusClasses,
    isFocused,
    focus,
    blur
  };
}
const FormKey = Symbol.for("vuetify:form");
const makeFormProps = propsFactory({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function createForm(props2) {
  const model = useProxiedModel(props2, "modelValue");
  const isDisabled = computed(() => props2.disabled);
  const isReadonly2 = computed(() => props2.readonly);
  const isValidating = shallowRef(false);
  const items = ref([]);
  const errors = ref([]);
  async function validate() {
    const results = [];
    let valid = true;
    errors.value = [];
    isValidating.value = true;
    for (const item of items.value) {
      const itemErrorMessages = await item.validate();
      if (itemErrorMessages.length > 0) {
        valid = false;
        results.push({
          id: item.id,
          errorMessages: itemErrorMessages
        });
      }
      if (!valid && props2.fastFail)
        break;
    }
    errors.value = results;
    isValidating.value = false;
    return {
      valid,
      errors: errors.value
    };
  }
  function reset() {
    items.value.forEach((item) => item.reset());
  }
  function resetValidation() {
    items.value.forEach((item) => item.resetValidation());
  }
  watch(items, () => {
    let valid = 0;
    let invalid = 0;
    const results = [];
    for (const item of items.value) {
      if (item.isValid === false) {
        invalid++;
        results.push({
          id: item.id,
          errorMessages: item.errorMessages
        });
      } else if (item.isValid === true)
        valid++;
    }
    errors.value = results;
    model.value = invalid > 0 ? false : valid === items.value.length ? true : null;
  }, {
    deep: true
  });
  provide(FormKey, {
    register: (_ref) => {
      let {
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2
      } = _ref;
      if (items.value.some((item) => item.id === id))
        ;
      items.value.push({
        id,
        validate: validate2,
        reset: reset2,
        resetValidation: resetValidation2,
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (id) => {
      items.value = items.value.filter((item) => {
        return item.id !== id;
      });
    },
    update: (id, isValid2, errorMessages) => {
      const found = items.value.find((item) => item.id === id);
      if (!found)
        return;
      found.isValid = isValid2;
      found.errorMessages = errorMessages;
    },
    isDisabled,
    isReadonly: isReadonly2,
    isValidating,
    isValid: model,
    items,
    validateOn: toRef(props2, "validateOn")
  });
  return {
    errors,
    isDisabled,
    isReadonly: isReadonly2,
    isValidating,
    isValid: model,
    items,
    validate,
    reset,
    resetValidation
  };
}
function useForm() {
  return inject$1(FormKey, null);
}
const makeValidationProps = propsFactory({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...makeFocusProps()
}, "validation");
function useValidation(props2) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
  const model = useProxiedModel(props2, "modelValue");
  const validationModel = computed(() => props2.validationValue === void 0 ? model.value : props2.validationValue);
  const form = useForm();
  const internalErrorMessages = ref([]);
  const isPristine = shallowRef(true);
  const isDirty = computed(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
  const isDisabled = computed(() => !!(props2.disabled ?? form?.isDisabled.value));
  const isReadonly2 = computed(() => !!(props2.readonly ?? form?.isReadonly.value));
  const errorMessages = computed(() => {
    return props2.errorMessages?.length ? wrapInArray(props2.errorMessages).concat(internalErrorMessages.value).slice(0, Math.max(0, +props2.maxErrors)) : internalErrorMessages.value;
  });
  const validateOn = computed(() => {
    let value = (props2.validateOn ?? form?.validateOn.value) || "input";
    if (value === "lazy")
      value = "input lazy";
    const set2 = new Set(value?.split(" ") ?? []);
    return {
      blur: set2.has("blur") || set2.has("input"),
      input: set2.has("input"),
      submit: set2.has("submit"),
      lazy: set2.has("lazy")
    };
  });
  const isValid2 = computed(() => {
    if (props2.error || props2.errorMessages?.length)
      return false;
    if (!props2.rules.length)
      return true;
    if (isPristine.value) {
      return internalErrorMessages.value.length || validateOn.value.lazy ? null : true;
    } else {
      return !internalErrorMessages.value.length;
    }
  });
  const isValidating = shallowRef(false);
  const validationClasses = computed(() => {
    return {
      [`${name}--error`]: isValid2.value === false,
      [`${name}--dirty`]: isDirty.value,
      [`${name}--disabled`]: isDisabled.value,
      [`${name}--readonly`]: isReadonly2.value
    };
  });
  const uid2 = computed(() => props2.name ?? unref(id));
  onBeforeMount(() => {
    form?.register({
      id: uid2.value,
      validate,
      reset,
      resetValidation
    });
  });
  onBeforeUnmount(() => {
    form?.unregister(uid2.value);
  });
  onMounted(async () => {
    if (!validateOn.value.lazy) {
      await validate(true);
    }
    form?.update(uid2.value, isValid2.value, errorMessages.value);
  });
  useToggleScope(() => validateOn.value.input, () => {
    watch(validationModel, () => {
      if (validationModel.value != null) {
        validate();
      } else if (props2.focused) {
        const unwatch = watch(() => props2.focused, (val) => {
          if (!val)
            validate();
          unwatch();
        });
      }
    });
  });
  useToggleScope(() => validateOn.value.blur, () => {
    watch(() => props2.focused, (val) => {
      if (!val)
        validate();
    });
  });
  watch([isValid2, errorMessages], () => {
    form?.update(uid2.value, isValid2.value, errorMessages.value);
  });
  function reset() {
    model.value = null;
    nextTick(resetValidation);
  }
  function resetValidation() {
    isPristine.value = true;
    if (!validateOn.value.lazy) {
      validate(true);
    } else {
      internalErrorMessages.value = [];
    }
  }
  async function validate() {
    let silent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    const results = [];
    isValidating.value = true;
    for (const rule of props2.rules) {
      if (results.length >= +(props2.maxErrors ?? 1)) {
        break;
      }
      const handler = typeof rule === "function" ? rule : () => rule;
      const result = await handler(validationModel.value);
      if (result === true)
        continue;
      if (result !== false && typeof result !== "string") {
        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
        continue;
      }
      results.push(result || "");
    }
    internalErrorMessages.value = results;
    isValidating.value = false;
    isPristine.value = silent;
    return internalErrorMessages.value;
  }
  return {
    errorMessages,
    isDirty,
    isDisabled,
    isReadonly: isReadonly2,
    isPristine,
    isValid: isValid2,
    isValidating,
    reset,
    resetValidation,
    validate,
    validationClasses
  };
}
const makeVInputProps = propsFactory({
  id: String,
  appendIcon: IconValue,
  centerAffix: {
    type: Boolean,
    default: true
  },
  prependIcon: IconValue,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v) => ["horizontal", "vertical"].includes(v)
  },
  "onClick:prepend": EventProp(),
  "onClick:append": EventProp(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeValidationProps()
}, "VInput");
const VInput = genericComponent()({
  name: "VInput",
  props: {
    ...makeVInputProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const {
      densityClasses
    } = useDensity(props2);
    const {
      rtlClasses
    } = useRtl();
    const {
      InputIcon
    } = useInputIcon(props2);
    const uid2 = getUid();
    const id = computed(() => props2.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    } = useValidation(props2, "v-input", id);
    const slotProps = computed(() => ({
      id,
      messagesId,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate
    }));
    const messages = computed(() => {
      if (props2.errorMessages?.length || !isPristine.value && errorMessages.value.length) {
        return errorMessages.value;
      } else if (props2.hint && (props2.persistentHint || props2.focused)) {
        return props2.hint;
      } else {
        return props2.messages;
      }
    });
    useRender(() => {
      const hasPrepend = !!(slots.prepend || props2.prependIcon);
      const hasAppend = !!(slots.append || props2.appendIcon);
      const hasMessages = messages.value.length > 0;
      const hasDetails = !props2.hideDetails || props2.hideDetails === "auto" && (hasMessages || !!slots.details);
      return createVNode("div", {
        "class": ["v-input", `v-input--${props2.direction}`, {
          "v-input--center-affix": props2.centerAffix,
          "v-input--hide-spin-buttons": props2.hideSpinButtons
        }, densityClasses.value, rtlClasses.value, validationClasses.value, props2.class],
        "style": props2.style
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-input__prepend"
      }, [slots.prepend?.(slotProps.value), props2.prependIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prepend"
      }, null)]), slots.default && createVNode("div", {
        "class": "v-input__control"
      }, [slots.default?.(slotProps.value)]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-input__append"
      }, [props2.appendIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "append"
      }, null), slots.append?.(slotProps.value)]), hasDetails && createVNode("div", {
        "class": "v-input__details"
      }, [createVNode(VMessages, {
        "id": messagesId.value,
        "active": hasMessages,
        "messages": messages.value
      }, {
        message: slots.message
      }), slots.details?.(slotProps.value)])]);
    });
    return {
      reset,
      resetValidation,
      validate,
      isValid: isValid2,
      errorMessages
    };
  }
});
const VChip$1 = "";
const VChipGroup = "";
const VSlideGroup$1 = "";
function bias(val) {
  const c2 = 0.501;
  const x2 = Math.abs(val);
  return Math.sign(val) * (x2 / ((1 / c2 - 2) * (1 - x2) + 1));
}
function calculateUpdatedOffset(_ref) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    currentScrollOffset,
    isHorizontal
  } = _ref;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const adjustedOffsetStart = isRtl && isHorizontal ? contentSize - offsetStart - clientSize : offsetStart;
  const totalSize = containerSize + currentScrollOffset;
  const itemOffset = clientSize + adjustedOffsetStart;
  const additionalOffset = clientSize * 0.4;
  if (adjustedOffsetStart <= currentScrollOffset) {
    currentScrollOffset = Math.max(adjustedOffsetStart - additionalOffset, 0);
  } else if (totalSize <= itemOffset) {
    currentScrollOffset = Math.min(currentScrollOffset - (totalSize - itemOffset - additionalOffset), contentSize - containerSize);
  }
  return currentScrollOffset;
}
function calculateCenteredOffset(_ref2) {
  let {
    selectedElement,
    containerSize,
    contentSize,
    isRtl,
    isHorizontal
  } = _ref2;
  const clientSize = isHorizontal ? selectedElement.clientWidth : selectedElement.clientHeight;
  const offsetStart = isHorizontal ? selectedElement.offsetLeft : selectedElement.offsetTop;
  const offsetCentered = isRtl && isHorizontal ? contentSize - offsetStart - clientSize / 2 - containerSize / 2 : offsetStart + clientSize / 2 - containerSize / 2;
  return Math.min(contentSize - containerSize, Math.max(0, offsetCentered));
}
const VSlideGroupSymbol = Symbol.for("vuetify:v-slide-group");
const makeVSlideGroupProps = propsFactory({
  centerActive: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: VSlideGroupSymbol
  },
  nextIcon: {
    type: IconValue,
    default: "$next"
  },
  prevIcon: {
    type: IconValue,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (v) => typeof v === "boolean" || ["always", "desktop", "mobile"].includes(v)
  },
  ...makeComponentProps(),
  ...makeDisplayProps(),
  ...makeTagProps(),
  ...makeGroupProps({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup");
const VSlideGroup = genericComponent()({
  name: "VSlideGroup",
  props: makeVSlideGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const {
      displayClasses,
      mobile
    } = useDisplay(props2);
    const group = useGroup(props2, props2.symbol);
    const isOverflowing = shallowRef(false);
    const scrollOffset = shallowRef(0);
    const containerSize = shallowRef(0);
    const contentSize = shallowRef(0);
    const isHorizontal = computed(() => props2.direction === "horizontal");
    const {
      resizeRef: containerRef,
      contentRect: containerRect
    } = useResizeObserver();
    const {
      resizeRef: contentRef,
      contentRect
    } = useResizeObserver();
    const firstSelectedIndex = computed(() => {
      if (!group.selected.value.length)
        return -1;
      return group.items.value.findIndex((item) => item.id === group.selected.value[0]);
    });
    const lastSelectedIndex = computed(() => {
      if (!group.selected.value.length)
        return -1;
      return group.items.value.findIndex((item) => item.id === group.selected.value[group.selected.value.length - 1]);
    });
    if (IN_BROWSER) {
      let frame = -1;
      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {
        cancelAnimationFrame(frame);
        frame = requestAnimationFrame(() => {
          if (containerRect.value && contentRect.value) {
            const sizeProperty = isHorizontal.value ? "width" : "height";
            containerSize.value = containerRect.value[sizeProperty];
            contentSize.value = contentRect.value[sizeProperty];
            isOverflowing.value = containerSize.value + 1 < contentSize.value;
          }
          if (firstSelectedIndex.value >= 0 && contentRef.value) {
            const selectedElement = contentRef.value.children[lastSelectedIndex.value];
            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {
              scrollOffset.value = 0;
            } else if (props2.centerActive) {
              scrollOffset.value = calculateCenteredOffset({
                selectedElement,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                isHorizontal: isHorizontal.value
              });
            } else if (isOverflowing.value) {
              scrollOffset.value = calculateUpdatedOffset({
                selectedElement,
                containerSize: containerSize.value,
                contentSize: contentSize.value,
                isRtl: isRtl.value,
                currentScrollOffset: scrollOffset.value,
                isHorizontal: isHorizontal.value
              });
            }
          }
        });
      });
    }
    const disableTransition = shallowRef(false);
    let startTouch = 0;
    let startOffset = 0;
    function onTouchstart(e) {
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      const sign = isRtl.value && isHorizontal.value ? -1 : 1;
      startOffset = sign * scrollOffset.value;
      startTouch = e.touches[0][sizeProperty];
      disableTransition.value = true;
    }
    function onTouchmove(e) {
      if (!isOverflowing.value)
        return;
      const sizeProperty = isHorizontal.value ? "clientX" : "clientY";
      const sign = isRtl.value && isHorizontal.value ? -1 : 1;
      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);
    }
    function onTouchend(e) {
      const maxScrollOffset = contentSize.value - containerSize.value;
      if (scrollOffset.value < 0 || !isOverflowing.value) {
        scrollOffset.value = 0;
      } else if (scrollOffset.value >= maxScrollOffset) {
        scrollOffset.value = maxScrollOffset;
      }
      disableTransition.value = false;
    }
    function onScroll() {
      if (!containerRef.value)
        return;
      containerRef.value[isHorizontal.value ? "scrollLeft" : "scrollTop"] = 0;
    }
    const isFocused = shallowRef(false);
    function onFocusin(e) {
      isFocused.value = true;
      if (!isOverflowing.value || !contentRef.value)
        return;
      for (const el of e.composedPath()) {
        for (const item of contentRef.value.children) {
          if (item === el) {
            scrollOffset.value = calculateUpdatedOffset({
              selectedElement: item,
              containerSize: containerSize.value,
              contentSize: contentSize.value,
              isRtl: isRtl.value,
              currentScrollOffset: scrollOffset.value,
              isHorizontal: isHorizontal.value
            });
            return;
          }
        }
      }
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget)))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (isHorizontal.value) {
        if (e.key === "ArrowRight") {
          focus(isRtl.value ? "prev" : "next");
        } else if (e.key === "ArrowLeft") {
          focus(isRtl.value ? "next" : "prev");
        }
      } else {
        if (e.key === "ArrowDown") {
          focus("next");
        } else if (e.key === "ArrowUp") {
          focus("prev");
        }
      }
      if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      }
    }
    function focus(location2) {
      if (!contentRef.value)
        return;
      if (!location2) {
        const focusable = focusableChildren(contentRef.value);
        focusable[0]?.focus();
      } else if (location2 === "next") {
        const el = contentRef.value.querySelector(":focus")?.nextElementSibling;
        if (el)
          el.focus();
        else
          focus("first");
      } else if (location2 === "prev") {
        const el = contentRef.value.querySelector(":focus")?.previousElementSibling;
        if (el)
          el.focus();
        else
          focus("last");
      } else if (location2 === "first") {
        contentRef.value.firstElementChild?.focus();
      } else if (location2 === "last") {
        contentRef.value.lastElementChild?.focus();
      }
    }
    function scrollTo(location2) {
      const newAbsoluteOffset = scrollOffset.value + (location2 === "prev" ? -1 : 1) * containerSize.value;
      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);
    }
    const contentStyles = computed(() => {
      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value;
      if (scrollOffset.value <= 0) {
        scrollAmount = bias(-scrollOffset.value);
      }
      const sign = isRtl.value && isHorizontal.value ? -1 : 1;
      return {
        transform: `translate${isHorizontal.value ? "X" : "Y"}(${sign * scrollAmount}px)`,
        transition: disableTransition.value ? "none" : "",
        willChange: disableTransition.value ? "transform" : ""
      };
    });
    const slotProps = computed(() => ({
      next: group.next,
      prev: group.prev,
      select: group.select,
      isSelected: group.isSelected
    }));
    const hasAffixes = computed(() => {
      switch (props2.showArrows) {
        case "always":
          return true;
        case "desktop":
          return !mobile.value;
        case true:
          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        case "mobile":
          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;
        default:
          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);
      }
    });
    const hasPrev = computed(() => {
      return Math.abs(scrollOffset.value) > 0;
    });
    const hasNext = computed(() => {
      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-slide-group", {
        "v-slide-group--vertical": !isHorizontal.value,
        "v-slide-group--has-affixes": hasAffixes.value,
        "v-slide-group--is-overflowing": isOverflowing.value
      }, displayClasses.value, props2.class],
      "style": props2.style,
      "tabindex": isFocused.value || group.selected.value.length ? -1 : 0,
      "onFocus": onFocus
    }, {
      default: () => [hasAffixes.value && createVNode("div", {
        "key": "prev",
        "class": ["v-slide-group__prev", {
          "v-slide-group__prev--disabled": !hasPrev.value
        }],
        "onClick": () => hasPrev.value && scrollTo("prev")
      }, [slots.prev?.(slotProps.value) ?? createVNode(VFadeTransition, null, {
        default: () => [createVNode(VIcon, {
          "icon": isRtl.value ? props2.nextIcon : props2.prevIcon
        }, null)]
      })]), createVNode("div", {
        "key": "container",
        "ref": containerRef,
        "class": "v-slide-group__container",
        "onScroll": onScroll
      }, [createVNode("div", {
        "ref": contentRef,
        "class": "v-slide-group__content",
        "style": contentStyles.value,
        "onTouchstartPassive": onTouchstart,
        "onTouchmovePassive": onTouchmove,
        "onTouchendPassive": onTouchend,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onKeydown": onKeydown
      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && createVNode("div", {
        "key": "next",
        "class": ["v-slide-group__next", {
          "v-slide-group__next--disabled": !hasNext.value
        }],
        "onClick": () => hasNext.value && scrollTo("next")
      }, [slots.next?.(slotProps.value) ?? createVNode(VFadeTransition, null, {
        default: () => [createVNode(VIcon, {
          "icon": isRtl.value ? props2.prevIcon : props2.nextIcon
        }, null)]
      })])]
    }));
    return {
      selected: group.selected,
      scrollTo,
      scrollOffset,
      focus
    };
  }
});
const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
const makeVChipGroupProps = propsFactory({
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual$1
  },
  ...makeVSlideGroupProps(),
  ...makeComponentProps(),
  ...makeGroupProps({
    selectedClass: "v-chip--selected"
  }),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "tonal"
  })
}, "VChipGroup");
genericComponent()({
  name: "VChipGroup",
  props: makeVChipGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props2, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props2, "color"),
        disabled: toRef(props2, "disabled"),
        filter: toRef(props2, "filter"),
        variant: toRef(props2, "variant")
      }
    });
    useRender(() => {
      const slideGroupProps = VSlideGroup.filterProps(props2);
      return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
        "class": ["v-chip-group", {
          "v-chip-group--column": props2.column
        }, themeClasses.value, props2.class],
        "style": props2.style
      }), {
        default: () => [slots.default?.({
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      });
    });
    return {};
  }
});
const makeVChipProps = propsFactory({
  activeClass: String,
  appendAvatar: String,
  appendIcon: IconValue,
  closable: Boolean,
  closeIcon: {
    type: IconValue,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: String,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  text: String,
  modelValue: {
    type: Boolean,
    default: true
  },
  onClick: EventProp(),
  onClickOnce: EventProp(),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "span"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "tonal"
  })
}, "VChip");
const VChip = genericComponent()({
  name: "VChip",
  directives: {
    Ripple
  },
  props: makeVChipProps(),
  emits: {
    "click:close": (e) => true,
    "update:modelValue": (value) => true,
    "group:selected": (val) => true,
    click: (e) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      sizeClasses
    } = useSize(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const isActive = useProxiedModel(props2, "modelValue");
    const group = useGroupItem(props2, VChipGroupSymbol, false);
    const link = useLink$1(props2, attrs);
    const isLink = computed(() => props2.link !== false && link.isLink.value);
    const isClickable = computed(() => !props2.disabled && props2.link !== false && (!!group || props2.link || link.isClickable.value));
    const closeProps = computed(() => ({
      "aria-label": t(props2.closeLabel),
      onClick(e) {
        e.stopPropagation();
        isActive.value = false;
        emit2("click:close", e);
      }
    }));
    function onClick(e) {
      emit2("click", e);
      if (!isClickable.value)
        return;
      link.navigate?.(e);
      group?.toggle();
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    return () => {
      const Tag = link.isLink.value ? "a" : props2.tag;
      const hasAppendMedia = !!(props2.appendIcon || props2.appendAvatar);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasClose = !!(slots.close || props2.closable);
      const hasFilter = !!(slots.filter || props2.filter) && group;
      const hasPrependMedia = !!(props2.prependIcon || props2.prependAvatar);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      const hasColor = !group || group.isSelected.value;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props2.disabled,
          "v-chip--label": props2.label,
          "v-chip--link": isClickable.value,
          "v-chip--filter": hasFilter,
          "v-chip--pill": props2.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group?.selectedClass.value, props2.class],
        "style": [hasColor ? colorStyles.value : void 0, props2.style],
        "disabled": props2.disabled || void 0,
        "draggable": props2.draggable,
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VExpandXTransition, {
          "key": "filter"
        }, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-chip__filter"
          }, [!slots.filter ? createVNode(VIcon, {
            "key": "filter-icon",
            "icon": props2.filterIcon
          }, null) : createVNode(VDefaultsProvider, {
            "key": "filter-defaults",
            "disabled": !props2.filterIcon,
            "defaults": {
              VIcon: {
                icon: props2.filterIcon
              }
            }
          }, slots.filter)]), [[vShow, group.isSelected.value]])]
        }), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-chip__prepend"
        }, [!slots.prepend ? createVNode(Fragment, null, [props2.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "icon": props2.prependIcon,
          "start": true
        }, null), props2.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "image": props2.prependAvatar,
          "start": true
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              image: props2.prependAvatar,
              start: true
            },
            VIcon: {
              icon: props2.prependIcon,
              start: true
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-chip__content",
          "data-no-activator": ""
        }, [slots.default?.({
          isSelected: group?.isSelected.value,
          selectedClass: group?.selectedClass.value,
          select: group?.select,
          toggle: group?.toggle,
          value: group?.value.value,
          disabled: props2.disabled
        }) ?? props2.text]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-chip__append"
        }, [!slots.append ? createVNode(Fragment, null, [props2.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "end": true,
          "icon": props2.appendIcon
        }, null), props2.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "end": true,
          "image": props2.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              end: true,
              image: props2.appendAvatar
            },
            VIcon: {
              end: true,
              icon: props2.appendIcon
            }
          }
        }, slots.append)]), hasClose && createVNode("button", mergeProps({
          "key": "close",
          "class": "v-chip__close",
          "type": "button"
        }, closeProps.value), [!slots.close ? createVNode(VIcon, {
          "key": "close-icon",
          "icon": props2.closeIcon,
          "size": "x-small"
        }, null) : createVNode(VDefaultsProvider, {
          "key": "close-defaults",
          "defaults": {
            VIcon: {
              icon: props2.closeIcon,
              size: "x-small"
            }
          }
        }, slots.close)])]
      }), [[resolveDirective("ripple"), isClickable.value && props2.ripple, null]]);
    };
  }
});
const VList$1 = "";
const ListKey = Symbol.for("vuetify:list");
function createList() {
  const parent = inject$1(ListKey, {
    hasPrepend: shallowRef(false),
    updateHasPrepend: () => null
  });
  const data = {
    hasPrepend: shallowRef(false),
    updateHasPrepend: (value) => {
      if (value)
        data.hasPrepend.value = value;
    }
  };
  provide(ListKey, data);
  return parent;
}
function useList() {
  return inject$1(ListKey, null);
}
const singleOpenStrategy = {
  open: (_ref) => {
    let {
      id,
      value,
      opened,
      parents: parents2
    } = _ref;
    if (value) {
      const newOpened = /* @__PURE__ */ new Set();
      newOpened.add(id);
      let parent = parents2.get(id);
      while (parent != null) {
        newOpened.add(parent);
        parent = parents2.get(parent);
      }
      return newOpened;
    } else {
      opened.delete(id);
      return opened;
    }
  },
  select: () => null
};
const multipleOpenStrategy = {
  open: (_ref2) => {
    let {
      id,
      value,
      opened,
      parents: parents2
    } = _ref2;
    if (value) {
      let parent = parents2.get(id);
      opened.add(id);
      while (parent != null && parent !== id) {
        opened.add(parent);
        parent = parents2.get(parent);
      }
      return opened;
    } else {
      opened.delete(id);
    }
    return opened;
  },
  select: () => null
};
const listOpenStrategy = {
  open: multipleOpenStrategy.open,
  select: (_ref3) => {
    let {
      id,
      value,
      opened,
      parents: parents2
    } = _ref3;
    if (!value)
      return opened;
    const path = [];
    let parent = parents2.get(id);
    while (parent != null) {
      path.push(parent);
      parent = parents2.get(parent);
    }
    return new Set(path);
  }
};
const independentSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref) => {
      let {
        id,
        value,
        selected
      } = _ref;
      id = toRaw(id);
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
          let [key, value2] = _ref2;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 1 && on[0] === id)
          return selected;
      }
      selected.set(id, value ? "on" : "off");
      return selected;
    },
    in: (v, children, parents2) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents: parents2
        });
      }
      return map;
    },
    out: (v) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on")
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
const independentSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref3) => {
      let {
        selected,
        id,
        ...rest
      } = _ref3;
      id = toRaw(id);
      const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
      return parentStrategy.select({
        ...rest,
        id,
        selected: singleSelected
      });
    },
    in: (v, children, parents2) => {
      let map = /* @__PURE__ */ new Map();
      if (v?.length) {
        map = parentStrategy.in(v.slice(0, 1), children, parents2);
      }
      return map;
    },
    out: (v, children, parents2) => {
      return parentStrategy.out(v, children, parents2);
    }
  };
  return strategy;
};
const leafSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref4) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref4;
      id = toRaw(id);
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const leafSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSingleSelectStrategy(mandatory);
  const strategy = {
    select: (_ref5) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref5;
      id = toRaw(id);
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const classicSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref6) => {
      let {
        id,
        value,
        selected,
        children,
        parents: parents2
      } = _ref6;
      id = toRaw(id);
      const original = new Map(selected);
      const items = [id];
      while (items.length) {
        const item = items.shift();
        selected.set(item, value ? "on" : "off");
        if (children.has(item)) {
          items.push(...children.get(item));
        }
      }
      let parent = parents2.get(id);
      while (parent) {
        const childrenIds = children.get(parent);
        const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
        const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
        selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
        parent = parents2.get(parent);
      }
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
          let [key, value2] = _ref7;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 0)
          return original;
      }
      return selected;
    },
    in: (v, children, parents2) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents: parents2
        });
      }
      return map;
    },
    out: (v, children) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on" && !children.has(key))
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
const VNestedSymbol = Symbol.for("vuetify:nested");
const emptyNested = {
  id: shallowRef(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: ref(/* @__PURE__ */ new Map()),
    children: ref(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    select: () => null,
    opened: ref(/* @__PURE__ */ new Set()),
    selected: ref(/* @__PURE__ */ new Map()),
    selectedValues: ref([])
  }
};
const makeNestedProps = propsFactory({
  selectStrategy: [String, Function],
  openStrategy: [String, Object],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested");
const useNested = (props2) => {
  let isUnmounted = false;
  const children = ref(/* @__PURE__ */ new Map());
  const parents2 = ref(/* @__PURE__ */ new Map());
  const opened = useProxiedModel(props2, "opened", props2.opened, (v) => new Set(v), (v) => [...v.values()]);
  const selectStrategy = computed(() => {
    if (typeof props2.selectStrategy === "object")
      return props2.selectStrategy;
    switch (props2.selectStrategy) {
      case "single-leaf":
        return leafSingleSelectStrategy(props2.mandatory);
      case "leaf":
        return leafSelectStrategy(props2.mandatory);
      case "independent":
        return independentSelectStrategy(props2.mandatory);
      case "single-independent":
        return independentSingleSelectStrategy(props2.mandatory);
      case "classic":
      default:
        return classicSelectStrategy(props2.mandatory);
    }
  });
  const openStrategy = computed(() => {
    if (typeof props2.openStrategy === "object")
      return props2.openStrategy;
    switch (props2.openStrategy) {
      case "list":
        return listOpenStrategy;
      case "single":
        return singleOpenStrategy;
      case "multiple":
      default:
        return multipleOpenStrategy;
    }
  });
  const selected = useProxiedModel(props2, "selected", props2.selected, (v) => selectStrategy.value.in(v, children.value, parents2.value), (v) => selectStrategy.value.out(v, children.value, parents2.value));
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function getPath(id) {
    const path = [];
    let parent = id;
    while (parent != null) {
      path.unshift(parent);
      parent = parents2.value.get(parent);
    }
    return path;
  }
  const vm = getCurrentInstance("nested");
  const nested = {
    id: shallowRef(),
    root: {
      opened,
      selected,
      selectedValues: computed(() => {
        const arr = [];
        for (const [key, value] of selected.value.entries()) {
          if (value === "on")
            arr.push(key);
        }
        return arr;
      }),
      register: (id, parentId, isGroup) => {
        parentId && id !== parentId && parents2.value.set(id, parentId);
        isGroup && children.value.set(id, []);
        if (parentId != null) {
          children.value.set(parentId, [...children.value.get(parentId) || [], id]);
        }
      },
      unregister: (id) => {
        if (isUnmounted)
          return;
        children.value.delete(id);
        const parent = parents2.value.get(id);
        if (parent) {
          const list = children.value.get(parent) ?? [];
          children.value.set(parent, list.filter((child) => child !== id));
        }
        parents2.value.delete(id);
        opened.value.delete(id);
      },
      open: (id, value, event) => {
        vm.emit("click:open", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newOpened = openStrategy.value.open({
          id,
          value,
          opened: new Set(opened.value),
          children: children.value,
          parents: parents2.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      openOnSelect: (id, value, event) => {
        const newOpened = openStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          opened: new Set(opened.value),
          children: children.value,
          parents: parents2.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      select: (id, value, event) => {
        vm.emit("click:select", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newSelected = selectStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          children: children.value,
          parents: parents2.value,
          event
        });
        newSelected && (selected.value = newSelected);
        nested.root.openOnSelect(id, value, event);
      },
      children,
      parents: parents2
    }
  };
  provide(VNestedSymbol, nested);
  return nested.root;
};
const useNestedItem = (id, isGroup) => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  const uidSymbol = Symbol(getUid());
  const computedId = computed(() => id.value !== void 0 ? id.value : uidSymbol);
  const item = {
    ...parent,
    id: computedId,
    open: (open, e) => parent.root.open(computedId.value, open, e),
    openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),
    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
    parent: computed(() => parent.root.parents.value.get(computedId.value)),
    select: (selected, e) => parent.root.select(computedId.value, selected, e),
    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === "on"),
    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
    isGroupActivator: parent.isGroupActivator
  };
  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
  onBeforeUnmount(() => {
    !parent.isGroupActivator && parent.root.unregister(computedId.value);
  });
  isGroup && provide(VNestedSymbol, item);
  return item;
};
const useNestedGroupActivator = () => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  provide(VNestedSymbol, {
    ...parent,
    isGroupActivator: true
  });
};
const VListGroupActivator = defineComponent({
  name: "VListGroupActivator",
  setup(_, _ref) {
    let {
      slots
    } = _ref;
    useNestedGroupActivator();
    return () => slots.default?.();
  }
});
const makeVListGroupProps = propsFactory({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  prependIcon: IconValue,
  appendIcon: IconValue,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListGroup");
const VListGroup = genericComponent()({
  name: "VListGroup",
  props: makeVListGroupProps(),
  setup(props2, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      isOpen,
      open,
      id: _id
    } = useNestedItem(toRef(props2, "value"), true);
    const id = computed(() => `v-list-group--id-${String(_id.value)}`);
    const list = useList();
    const {
      isBooted
    } = useSsrBoot();
    function onClick(e) {
      open(!isOpen.value, e);
    }
    const activatorProps = computed(() => ({
      onClick,
      class: "v-list-group__header",
      id: id.value
    }));
    const toggleIcon = computed(() => isOpen.value ? props2.collapseIcon : props2.expandIcon);
    const activatorDefaults = computed(() => ({
      VListItem: {
        active: isOpen.value,
        activeColor: props2.activeColor,
        baseColor: props2.baseColor,
        color: props2.color,
        prependIcon: props2.prependIcon || props2.subgroup && toggleIcon.value,
        appendIcon: props2.appendIcon || !props2.subgroup && toggleIcon.value,
        title: props2.title,
        value: props2.value
      }
    }));
    useRender(() => createVNode(props2.tag, {
      "class": ["v-list-group", {
        "v-list-group--prepend": list?.hasPrepend.value,
        "v-list-group--fluid": props2.fluid,
        "v-list-group--subgroup": props2.subgroup,
        "v-list-group--open": isOpen.value
      }, props2.class],
      "style": props2.style
    }, {
      default: () => [slots.activator && createVNode(VDefaultsProvider, {
        "defaults": activatorDefaults.value
      }, {
        default: () => [createVNode(VListGroupActivator, null, {
          default: () => [slots.activator({
            props: activatorProps.value,
            isOpen: isOpen.value
          })]
        })]
      }), createVNode(MaybeTransition, {
        "transition": {
          component: VExpandTransition
        },
        "disabled": !isBooted.value
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-list-group__items",
          "role": "group",
          "aria-labelledby": id.value
        }, [slots.default?.()]), [[vShow, isOpen.value]])]
      })]
    }));
    return {};
  }
});
const VListItem$1 = "";
const VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");
const VListItemTitle = createSimpleFunctional("v-list-item-title");
const makeVListItemProps = propsFactory({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: IconValue,
  baseColor: String,
  disabled: Boolean,
  lines: String,
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  slim: Boolean,
  subtitle: [String, Number],
  title: [String, Number],
  value: null,
  onClick: EventProp(),
  onClickOnce: EventProp(),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VListItem");
const VListItem = genericComponent()({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: makeVListItemProps(),
  emits: {
    click: (e) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const link = useLink$1(props2, attrs);
    const id = computed(() => props2.value === void 0 ? link.href.value : props2.value);
    const {
      select,
      isSelected,
      isIndeterminate,
      isGroupActivator,
      root,
      parent,
      openOnSelect
    } = useNestedItem(id, false);
    const list = useList();
    const isActive = computed(() => props2.active !== false && (props2.active || link.isActive?.value || isSelected.value));
    const isLink = computed(() => props2.link !== false && link.isLink.value);
    const isClickable = computed(() => !props2.disabled && props2.link !== false && (props2.link || link.isClickable.value || props2.value != null && !!list));
    const roundedProps = computed(() => props2.rounded || props2.nav);
    const color = computed(() => props2.color ?? props2.activeColor);
    const variantProps = computed(() => ({
      color: isActive.value ? color.value ?? props2.baseColor : props2.baseColor,
      variant: props2.variant
    }));
    watch(() => link.isActive?.value, (val) => {
      if (val && parent.value != null) {
        root.open(parent.value, true);
      }
      if (val) {
        openOnSelect(val);
      }
    }, {
      immediate: true
    });
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(roundedProps);
    const lineClasses = computed(() => props2.lines ? `v-list-item--${props2.lines}-line` : void 0);
    const slotProps = computed(() => ({
      isActive: isActive.value,
      select,
      isSelected: isSelected.value,
      isIndeterminate: isIndeterminate.value
    }));
    function onClick(e) {
      emit2("click", e);
      if (isGroupActivator || !isClickable.value)
        return;
      link.navigate?.(e);
      props2.value != null && select(!isSelected.value, e);
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    useRender(() => {
      const Tag = isLink.value ? "a" : props2.tag;
      const hasTitle = slots.title || props2.title != null;
      const hasSubtitle = slots.subtitle || props2.subtitle != null;
      const hasAppendMedia = !!(props2.appendAvatar || props2.appendIcon);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasPrependMedia = !!(props2.prependAvatar || props2.prependIcon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      list?.updateHasPrepend(hasPrepend);
      if (props2.activeColor) {
        deprecate("active-color", ["color", "base-color"]);
      }
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props2.disabled,
          "v-list-item--link": isClickable.value,
          "v-list-item--nav": props2.nav,
          "v-list-item--prepend": !hasPrepend && list?.hasPrepend.value,
          "v-list-item--slim": props2.slim,
          [`${props2.activeClass}`]: props2.activeClass && isActive.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value, props2.class],
        "style": [colorStyles.value, dimensionStyles.value, props2.style],
        "href": link.href.value,
        "tabindex": isClickable.value ? list ? -2 : 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-list-item__prepend"
        }, [!slots.prepend ? createVNode(Fragment, null, [props2.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "density": props2.density,
          "image": props2.prependAvatar
        }, null), props2.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props2.density,
          "icon": props2.prependIcon
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              density: props2.density,
              image: props2.prependAvatar
            },
            VIcon: {
              density: props2.density,
              icon: props2.prependIcon
            },
            VListItemAction: {
              start: true
            }
          }
        }, {
          default: () => [slots.prepend?.(slotProps.value)]
        }), createVNode("div", {
          "class": "v-list-item__spacer"
        }, null)]), createVNode("div", {
          "class": "v-list-item__content",
          "data-no-activator": ""
        }, [hasTitle && createVNode(VListItemTitle, {
          "key": "title"
        }, {
          default: () => [slots.title?.({
            title: props2.title
          }) ?? props2.title]
        }), hasSubtitle && createVNode(VListItemSubtitle, {
          "key": "subtitle"
        }, {
          default: () => [slots.subtitle?.({
            subtitle: props2.subtitle
          }) ?? props2.subtitle]
        }), slots.default?.(slotProps.value)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-list-item__append"
        }, [!slots.append ? createVNode(Fragment, null, [props2.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "density": props2.density,
          "icon": props2.appendIcon
        }, null), props2.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "density": props2.density,
          "image": props2.appendAvatar
        }, null)]) : createVNode(VDefaultsProvider, {
          "key": "append-defaults",
          "disabled": !hasAppendMedia,
          "defaults": {
            VAvatar: {
              density: props2.density,
              image: props2.appendAvatar
            },
            VIcon: {
              density: props2.density,
              icon: props2.appendIcon
            },
            VListItemAction: {
              end: true
            }
          }
        }, {
          default: () => [slots.append?.(slotProps.value)]
        }), createVNode("div", {
          "class": "v-list-item__spacer"
        }, null)])]
      }), [[resolveDirective("ripple"), isClickable.value && props2.ripple]]);
    });
    return {};
  }
});
const makeVListSubheaderProps = propsFactory({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...makeComponentProps(),
  ...makeTagProps()
}, "VListSubheader");
const VListSubheader = genericComponent()({
  name: "VListSubheader",
  props: makeVListSubheaderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    useRender(() => {
      const hasText = !!(slots.default || props2.title);
      return createVNode(props2.tag, {
        "class": ["v-list-subheader", {
          "v-list-subheader--inset": props2.inset,
          "v-list-subheader--sticky": props2.sticky
        }, textColorClasses.value, props2.class],
        "style": [{
          textColorStyles
        }, props2.style]
      }, {
        default: () => [hasText && createVNode("div", {
          "class": "v-list-subheader__text"
        }, [slots.default?.() ?? props2.title])]
      });
    });
    return {};
  }
});
const VDivider$1 = "";
const makeVDividerProps = propsFactory({
  color: String,
  inset: Boolean,
  length: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...makeComponentProps(),
  ...makeThemeProps()
}, "VDivider");
const VDivider = genericComponent()({
  name: "VDivider",
  props: makeVDividerProps(),
  setup(props2, _ref) {
    let {
      attrs
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "color"));
    const dividerStyles = computed(() => {
      const styles = {};
      if (props2.length) {
        styles[props2.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props2.length);
      }
      if (props2.thickness) {
        styles[props2.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props2.thickness);
      }
      return styles;
    });
    useRender(() => createVNode("hr", {
      "class": [{
        "v-divider": true,
        "v-divider--inset": props2.inset,
        "v-divider--vertical": props2.vertical
      }, themeClasses.value, textColorClasses.value, props2.class],
      "style": [dividerStyles.value, textColorStyles.value, props2.style],
      "aria-orientation": !attrs.role || attrs.role === "separator" ? props2.vertical ? "vertical" : "horizontal" : void 0,
      "role": `${attrs.role || "separator"}`
    }, null));
    return {};
  }
});
const makeVListChildrenProps = propsFactory({
  items: Array,
  returnObject: Boolean
}, "VListChildren");
const VListChildren = genericComponent()({
  name: "VListChildren",
  props: makeVListChildrenProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    createList();
    return () => slots.default?.() ?? props2.items?.map((_ref2) => {
      let {
        children,
        props: itemProps,
        type,
        raw: item
      } = _ref2;
      if (type === "divider") {
        return slots.divider?.({
          props: itemProps
        }) ?? createVNode(VDivider, itemProps, null);
      }
      if (type === "subheader") {
        return slots.subheader?.({
          props: itemProps
        }) ?? createVNode(VListSubheader, itemProps, null);
      }
      const slotsWithItem = {
        subtitle: slots.subtitle ? (slotProps) => slots.subtitle?.({
          ...slotProps,
          item
        }) : void 0,
        prepend: slots.prepend ? (slotProps) => slots.prepend?.({
          ...slotProps,
          item
        }) : void 0,
        append: slots.append ? (slotProps) => slots.append?.({
          ...slotProps,
          item
        }) : void 0,
        title: slots.title ? (slotProps) => slots.title?.({
          ...slotProps,
          item
        }) : void 0
      };
      const listGroupProps = VListGroup.filterProps(itemProps);
      return children ? createVNode(VListGroup, mergeProps({
        "value": itemProps?.value
      }, listGroupProps), {
        activator: (_ref3) => {
          let {
            props: activatorProps
          } = _ref3;
          const listItemProps = {
            ...itemProps,
            ...activatorProps,
            value: props2.returnObject ? item : itemProps.value
          };
          return slots.header ? slots.header({
            props: listItemProps
          }) : createVNode(VListItem, listItemProps, slotsWithItem);
        },
        default: () => createVNode(VListChildren, {
          "items": children
        }, slots)
      }) : slots.item ? slots.item({
        props: itemProps
      }) : createVNode(VListItem, mergeProps(itemProps, {
        "value": props2.returnObject ? item : itemProps.value
      }), slotsWithItem);
    });
  }
});
const makeItemsProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual$1
  }
}, "list-items");
function transformItem$2(props2, item) {
  const title = getPropertyFromItem(item, props2.itemTitle, item);
  const value = getPropertyFromItem(item, props2.itemValue, title);
  const children = getPropertyFromItem(item, props2.itemChildren);
  const itemProps = props2.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? omit(item, ["children"]) : item : void 0 : getPropertyFromItem(item, props2.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    title: String(_props.title ?? ""),
    value: _props.value,
    props: _props,
    children: Array.isArray(children) ? transformItems$2(props2, children) : void 0,
    raw: item
  };
}
function transformItems$2(props2, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem$2(props2, item));
  }
  return array;
}
function useItems(props2) {
  const items = computed(() => transformItems$2(props2, props2.items));
  const hasNullItem = computed(() => items.value.some((item) => item.value === null));
  function transformIn(value) {
    if (!hasNullItem.value) {
      value = value.filter((v) => v !== null);
    }
    return value.map((v) => {
      if (props2.returnObject && typeof v === "string") {
        return transformItem$2(props2, v);
      }
      return items.value.find((item) => props2.valueComparator(v, item.value)) || transformItem$2(props2, v);
    });
  }
  function transformOut(value) {
    return props2.returnObject ? value.map((_ref) => {
      let {
        raw
      } = _ref;
      return raw;
    }) : value.map((_ref2) => {
      let {
        value: value2
      } = _ref2;
      return value2;
    });
  }
  return {
    items,
    transformIn,
    transformOut
  };
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
}
function transformItem$1(props2, item) {
  const type = getPropertyFromItem(item, props2.itemType, "item");
  const title = isPrimitive(item) ? item : getPropertyFromItem(item, props2.itemTitle);
  const value = getPropertyFromItem(item, props2.itemValue, void 0);
  const children = getPropertyFromItem(item, props2.itemChildren);
  const itemProps = props2.itemProps === true ? omit(item, ["children"]) : getPropertyFromItem(item, props2.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    type,
    title: _props.title,
    value: _props.value,
    props: _props,
    children: type === "item" && children ? transformItems$1(props2, children) : void 0,
    raw: item
  };
}
function transformItems$1(props2, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem$1(props2, item));
  }
  return array;
}
function useListItems(props2) {
  const items = computed(() => transformItems$1(props2, props2.items));
  return {
    items
  };
}
const makeVListProps = propsFactory({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  expandIcon: String,
  collapseIcon: String,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  ...makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  itemType: {
    type: String,
    default: "type"
  },
  ...makeItemsProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VList");
const VList = genericComponent()({
  name: "VList",
  props: makeVListProps(),
  emits: {
    "update:selected": (value) => true,
    "update:opened": (value) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    const {
      borderClasses
    } = useBorder(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      open,
      select
    } = useNested(props2);
    const lineClasses = computed(() => props2.lines ? `v-list--${props2.lines}-line` : void 0);
    const activeColor = toRef(props2, "activeColor");
    const baseColor = toRef(props2, "baseColor");
    const color = toRef(props2, "color");
    createList();
    provideDefaults({
      VListGroup: {
        activeColor,
        baseColor,
        color,
        expandIcon: toRef(props2, "expandIcon"),
        collapseIcon: toRef(props2, "collapseIcon")
      },
      VListItem: {
        activeClass: toRef(props2, "activeClass"),
        activeColor,
        baseColor,
        color,
        density: toRef(props2, "density"),
        disabled: toRef(props2, "disabled"),
        lines: toRef(props2, "lines"),
        nav: toRef(props2, "nav"),
        slim: toRef(props2, "slim"),
        variant: toRef(props2, "variant")
      }
    });
    const isFocused = shallowRef(false);
    const contentRef = ref();
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onFocusout(e) {
      isFocused.value = false;
    }
    function onFocus(e) {
      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget)))
        focus();
    }
    function onKeydown(e) {
      if (!contentRef.value)
        return;
      if (e.key === "ArrowDown") {
        focus("next");
      } else if (e.key === "ArrowUp") {
        focus("prev");
      } else if (e.key === "Home") {
        focus("first");
      } else if (e.key === "End") {
        focus("last");
      } else {
        return;
      }
      e.preventDefault();
    }
    function onMousedown(e) {
      isFocused.value = true;
    }
    function focus(location2) {
      if (contentRef.value) {
        return focusChild(contentRef.value, location2);
      }
    }
    useRender(() => {
      return createVNode(props2.tag, {
        "ref": contentRef,
        "class": ["v-list", {
          "v-list--disabled": props2.disabled,
          "v-list--nav": props2.nav,
          "v-list--slim": props2.slim
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, dimensionStyles.value, props2.style],
        "tabindex": props2.disabled || isFocused.value ? -1 : 0,
        "role": "listbox",
        "aria-activedescendant": void 0,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onFocus": onFocus,
        "onKeydown": onKeydown,
        "onMousedown": onMousedown
      }, {
        default: () => [createVNode(VListChildren, {
          "items": items.value,
          "returnObject": props2.returnObject
        }, slots)]
      });
    });
    return {
      open,
      select,
      focus
    };
  }
});
const VMenu$1 = "";
const VOverlay$1 = "";
function elementToViewport(point, offset) {
  return {
    x: point.x + offset.x,
    y: point.y + offset.y
  };
}
function getOffset(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function anchorToPoint(anchor, box) {
  if (anchor.side === "top" || anchor.side === "bottom") {
    const {
      side,
      align
    } = anchor;
    const x2 = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
    const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
    return elementToViewport({
      x: x2,
      y
    }, box);
  } else if (anchor.side === "left" || anchor.side === "right") {
    const {
      side,
      align
    } = anchor;
    const x2 = side === "left" ? 0 : side === "right" ? box.width : side;
    const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
    return elementToViewport({
      x: x2,
      y
    }, box);
  }
  return elementToViewport({
    x: box.width / 2,
    y: box.height / 2
  }, box);
}
const locationStrategies = {
  static: staticLocationStrategy,
  // specific viewport position, usually centered
  connected: connectedLocationStrategy
  // connected to a certain element
};
const makeLocationStrategyProps = propsFactory({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (val) => typeof val === "function" || val in locationStrategies
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function useLocationStrategies(props2, data) {
  const contentStyles = ref({});
  const updateLocation = ref();
  if (IN_BROWSER) {
    useToggleScope(() => !!(data.isActive.value && props2.locationStrategy), (reset) => {
      watch(() => props2.locationStrategy, reset);
      onScopeDispose(() => {
        window.removeEventListener("resize", onResize);
        updateLocation.value = void 0;
      });
      window.addEventListener("resize", onResize, {
        passive: true
      });
      if (typeof props2.locationStrategy === "function") {
        updateLocation.value = props2.locationStrategy(data, props2, contentStyles)?.updateLocation;
      } else {
        updateLocation.value = locationStrategies[props2.locationStrategy](data, props2, contentStyles)?.updateLocation;
      }
    });
  }
  function onResize(e) {
    updateLocation.value?.(e);
  }
  return {
    contentStyles,
    updateLocation
  };
}
function staticLocationStrategy() {
}
function getIntrinsicSize(el, isRtl) {
  if (isRtl) {
    el.style.removeProperty("left");
  } else {
    el.style.removeProperty("right");
  }
  const contentBox = nullifyTransforms(el);
  if (isRtl) {
    contentBox.x += parseFloat(el.style.right || 0);
  } else {
    contentBox.x -= parseFloat(el.style.left || 0);
  }
  contentBox.y -= parseFloat(el.style.top || 0);
  return contentBox;
}
function connectedLocationStrategy(data, props2, contentStyles) {
  const activatorFixed = Array.isArray(data.target.value) || isFixedPosition(data.target.value);
  if (activatorFixed) {
    Object.assign(contentStyles.value, {
      position: "fixed",
      top: 0,
      [data.isRtl.value ? "right" : "left"]: 0
    });
  }
  const {
    preferredAnchor,
    preferredOrigin
  } = destructComputed(() => {
    const parsedAnchor = parseAnchor(props2.location, data.isRtl.value);
    const parsedOrigin = props2.origin === "overlap" ? parsedAnchor : props2.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props2.origin, data.isRtl.value);
    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
      return {
        preferredAnchor: flipCorner(parsedAnchor),
        preferredOrigin: flipCorner(parsedOrigin)
      };
    } else {
      return {
        preferredAnchor: parsedAnchor,
        preferredOrigin: parsedOrigin
      };
    }
  });
  const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
    return computed(() => {
      const val = parseFloat(props2[key]);
      return isNaN(val) ? Infinity : val;
    });
  });
  const offset = computed(() => {
    if (Array.isArray(props2.offset)) {
      return props2.offset;
    }
    if (typeof props2.offset === "string") {
      const offset2 = props2.offset.split(" ").map(parseFloat);
      if (offset2.length < 2)
        offset2.push(0);
      return offset2;
    }
    return typeof props2.offset === "number" ? [props2.offset, 0] : [0, 0];
  });
  let observe = false;
  const observer = new ResizeObserver(() => {
    if (observe)
      updateLocation();
  });
  watch([data.target, data.contentEl], (_ref, _ref2) => {
    let [newTarget, newContentEl] = _ref;
    let [oldTarget, oldContentEl] = _ref2;
    if (oldTarget && !Array.isArray(oldTarget))
      observer.unobserve(oldTarget);
    if (newTarget && !Array.isArray(newTarget))
      observer.observe(newTarget);
    if (oldContentEl)
      observer.unobserve(oldContentEl);
    if (newContentEl)
      observer.observe(newContentEl);
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    observer.disconnect();
  });
  function updateLocation() {
    observe = false;
    requestAnimationFrame(() => observe = true);
    if (!data.target.value || !data.contentEl.value)
      return;
    const targetBox = getTargetBox(data.target.value);
    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);
    const scrollParents = getScrollParents(data.contentEl.value);
    const viewportMargin = 12;
    if (!scrollParents.length) {
      scrollParents.push(document.documentElement);
      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
        contentBox.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
        contentBox.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
      }
    }
    const viewport = scrollParents.reduce((box, el) => {
      const rect = el.getBoundingClientRect();
      const scrollBox = new Box({
        x: el === document.documentElement ? 0 : rect.x,
        y: el === document.documentElement ? 0 : rect.y,
        width: el.clientWidth,
        height: el.clientHeight
      });
      if (box) {
        return new Box({
          x: Math.max(box.left, scrollBox.left),
          y: Math.max(box.top, scrollBox.top),
          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
        });
      }
      return scrollBox;
    }, void 0);
    viewport.x += viewportMargin;
    viewport.y += viewportMargin;
    viewport.width -= viewportMargin * 2;
    viewport.height -= viewportMargin * 2;
    let placement = {
      anchor: preferredAnchor.value,
      origin: preferredOrigin.value
    };
    function checkOverflow(_placement) {
      const box = new Box(contentBox);
      const targetPoint = anchorToPoint(_placement.anchor, targetBox);
      const contentPoint = anchorToPoint(_placement.origin, box);
      let {
        x: x3,
        y: y2
      } = getOffset(targetPoint, contentPoint);
      switch (_placement.anchor.side) {
        case "top":
          y2 -= offset.value[0];
          break;
        case "bottom":
          y2 += offset.value[0];
          break;
        case "left":
          x3 -= offset.value[0];
          break;
        case "right":
          x3 += offset.value[0];
          break;
      }
      switch (_placement.anchor.align) {
        case "top":
          y2 -= offset.value[1];
          break;
        case "bottom":
          y2 += offset.value[1];
          break;
        case "left":
          x3 -= offset.value[1];
          break;
        case "right":
          x3 += offset.value[1];
          break;
      }
      box.x += x3;
      box.y += y2;
      box.width = Math.min(box.width, maxWidth.value);
      box.height = Math.min(box.height, maxHeight.value);
      const overflows = getOverflow(box, viewport);
      return {
        overflows,
        x: x3,
        y: y2
      };
    }
    let x2 = 0;
    let y = 0;
    const available = {
      x: 0,
      y: 0
    };
    const flipped = {
      x: false,
      y: false
    };
    let resets = -1;
    while (true) {
      if (resets++ > 10) {
        break;
      }
      const {
        x: _x,
        y: _y,
        overflows
      } = checkOverflow(placement);
      x2 += _x;
      y += _y;
      contentBox.x += _x;
      contentBox.y += _y;
      {
        const axis2 = getAxis(placement.anchor);
        const hasOverflowX = overflows.x.before || overflows.x.after;
        const hasOverflowY = overflows.y.before || overflows.y.after;
        let reset = false;
        ["x", "y"].forEach((key) => {
          if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
            const newPlacement = {
              anchor: {
                ...placement.anchor
              },
              origin: {
                ...placement.origin
              }
            };
            const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
            newPlacement.anchor = flip(newPlacement.anchor);
            newPlacement.origin = flip(newPlacement.origin);
            const {
              overflows: newOverflows
            } = checkOverflow(newPlacement);
            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
              placement = newPlacement;
              reset = flipped[key] = true;
            }
          }
        });
        if (reset)
          continue;
      }
      if (overflows.x.before) {
        x2 += overflows.x.before;
        contentBox.x += overflows.x.before;
      }
      if (overflows.x.after) {
        x2 -= overflows.x.after;
        contentBox.x -= overflows.x.after;
      }
      if (overflows.y.before) {
        y += overflows.y.before;
        contentBox.y += overflows.y.before;
      }
      if (overflows.y.after) {
        y -= overflows.y.after;
        contentBox.y -= overflows.y.after;
      }
      {
        const overflows2 = getOverflow(contentBox, viewport);
        available.x = viewport.width - overflows2.x.before - overflows2.x.after;
        available.y = viewport.height - overflows2.y.before - overflows2.y.after;
        x2 += overflows2.x.before;
        contentBox.x += overflows2.x.before;
        y += overflows2.y.before;
        contentBox.y += overflows2.y.before;
      }
      break;
    }
    const axis = getAxis(placement.anchor);
    Object.assign(contentStyles.value, {
      "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: convertToUnit(pixelRound(y)),
      left: data.isRtl.value ? void 0 : convertToUnit(pixelRound(x2)),
      right: data.isRtl.value ? convertToUnit(pixelRound(-x2)) : void 0,
      minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
    });
    return {
      available,
      contentBox
    };
  }
  watch(() => [preferredAnchor.value, preferredOrigin.value, props2.offset, props2.minWidth, props2.minHeight, props2.maxWidth, props2.maxHeight], () => updateLocation());
  nextTick(() => {
    const result = updateLocation();
    if (!result)
      return;
    const {
      available,
      contentBox
    } = result;
    if (contentBox.height > available.y) {
      requestAnimationFrame(() => {
        updateLocation();
        requestAnimationFrame(() => {
          updateLocation();
        });
      });
    }
  });
  return {
    updateLocation
  };
}
function pixelRound(val) {
  return Math.round(val * devicePixelRatio) / devicePixelRatio;
}
function pixelCeil(val) {
  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
}
let clean = true;
const frames = [];
function requestNewFrame(cb) {
  if (!clean || frames.length) {
    frames.push(cb);
    run();
  } else {
    clean = false;
    cb();
    run();
  }
}
let raf = -1;
function run() {
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => {
    const frame = frames.shift();
    if (frame)
      frame();
    if (frames.length)
      run();
    else
      clean = true;
  });
}
const scrollStrategies = {
  none: null,
  close: closeScrollStrategy,
  block: blockScrollStrategy,
  reposition: repositionScrollStrategy
};
const makeScrollStrategyProps = propsFactory({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (val) => typeof val === "function" || val in scrollStrategies
  }
}, "VOverlay-scroll-strategies");
function useScrollStrategies(props2, data) {
  if (!IN_BROWSER)
    return;
  let scope;
  watchEffect(async () => {
    scope?.stop();
    if (!(data.isActive.value && props2.scrollStrategy))
      return;
    scope = effectScope();
    await nextTick();
    scope.active && scope.run(() => {
      if (typeof props2.scrollStrategy === "function") {
        props2.scrollStrategy(data, props2, scope);
      } else {
        scrollStrategies[props2.scrollStrategy]?.(data, props2, scope);
      }
    });
  });
  onScopeDispose(() => {
    scope?.stop();
  });
}
function closeScrollStrategy(data) {
  function onScroll(e) {
    data.isActive.value = false;
  }
  bindScroll(data.targetEl.value ?? data.contentEl.value, onScroll);
}
function blockScrollStrategy(data, props2) {
  const offsetParent = data.root.value?.offsetParent;
  const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.targetEl.value, props2.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props2.contained ? offsetParent : void 0)])].filter((el) => !el.classList.contains("v-overlay-scroll-blocked"));
  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
  const scrollableParent = ((el) => hasScrollbar(el) && el)(offsetParent || document.documentElement);
  if (scrollableParent) {
    data.root.value.classList.add("v-overlay--scroll-blocked");
  }
  scrollElements.forEach((el, i) => {
    el.style.setProperty("--v-body-scroll-x", convertToUnit(-el.scrollLeft));
    el.style.setProperty("--v-body-scroll-y", convertToUnit(-el.scrollTop));
    if (el !== document.documentElement) {
      el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    }
    el.classList.add("v-overlay-scroll-blocked");
  });
  onScopeDispose(() => {
    scrollElements.forEach((el, i) => {
      const x2 = parseFloat(el.style.getPropertyValue("--v-body-scroll-x"));
      const y = parseFloat(el.style.getPropertyValue("--v-body-scroll-y"));
      const scrollBehavior = el.style.scrollBehavior;
      el.style.scrollBehavior = "auto";
      el.style.removeProperty("--v-body-scroll-x");
      el.style.removeProperty("--v-body-scroll-y");
      el.style.removeProperty("--v-scrollbar-offset");
      el.classList.remove("v-overlay-scroll-blocked");
      el.scrollLeft = -x2;
      el.scrollTop = -y;
      el.style.scrollBehavior = scrollBehavior;
    });
    if (scrollableParent) {
      data.root.value.classList.remove("v-overlay--scroll-blocked");
    }
  });
}
function repositionScrollStrategy(data, props2, scope) {
  let slow = false;
  let raf2 = -1;
  let ric = -1;
  function update(e) {
    requestNewFrame(() => {
      const start = performance.now();
      data.updateLocation.value?.(e);
      const time = performance.now() - start;
      slow = time / (1e3 / 60) > 2;
    });
  }
  ric = (typeof requestIdleCallback === "undefined" ? (cb) => cb() : requestIdleCallback)(() => {
    scope.run(() => {
      bindScroll(data.targetEl.value ?? data.contentEl.value, (e) => {
        if (slow) {
          cancelAnimationFrame(raf2);
          raf2 = requestAnimationFrame(() => {
            raf2 = requestAnimationFrame(() => {
              update(e);
            });
          });
        } else {
          update(e);
        }
      });
    });
  });
  onScopeDispose(() => {
    typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(ric);
    cancelAnimationFrame(raf2);
  });
}
function bindScroll(el, onScroll) {
  const scrollElements = [document, ...getScrollParents(el)];
  scrollElements.forEach((el2) => {
    el2.addEventListener("scroll", onScroll, {
      passive: true
    });
  });
  onScopeDispose(() => {
    scrollElements.forEach((el2) => {
      el2.removeEventListener("scroll", onScroll);
    });
  });
}
const VMenuSymbol = Symbol.for("vuetify:v-menu");
const makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props2, cb) {
  let clearDelay = () => {
  };
  function runDelay(isOpening) {
    clearDelay?.();
    const delay = Number(isOpening ? props2.openDelay : props2.closeDelay);
    return new Promise((resolve2) => {
      clearDelay = defer(delay, () => {
        cb?.(isOpening);
        resolve2(isOpening);
      });
    });
  }
  function runOpenDelay() {
    return runDelay(true);
  }
  function runCloseDelay() {
    return runDelay(false);
  }
  return {
    clearDelay,
    runOpenDelay,
    runCloseDelay
  };
}
const makeActivatorProps = propsFactory({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...makeDelayProps()
}, "VOverlay-activator");
function useActivator(props2, _ref) {
  let {
    isActive,
    isTop
  } = _ref;
  const vm = getCurrentInstance("useActivator");
  const activatorEl = ref();
  let isHovered = false;
  let isFocused = false;
  let firstEnter = true;
  const openOnFocus = computed(() => props2.openOnFocus || props2.openOnFocus == null && props2.openOnHover);
  const openOnClick = computed(() => props2.openOnClick || props2.openOnClick == null && !props2.openOnHover && !openOnFocus.value);
  const {
    runOpenDelay,
    runCloseDelay
  } = useDelay(props2, (value) => {
    if (value === (props2.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props2.openOnHover && isActive.value && !isTop.value)) {
      if (isActive.value !== value) {
        firstEnter = true;
      }
      isActive.value = value;
    }
  });
  const cursorTarget = ref();
  const availableEvents = {
    onClick: (e) => {
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      if (!isActive.value) {
        cursorTarget.value = [e.clientX, e.clientY];
      }
      isActive.value = !isActive.value;
    },
    onMouseenter: (e) => {
      if (e.sourceCapabilities?.firesTouchEvents)
        return;
      isHovered = true;
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    onMouseleave: (e) => {
      isHovered = false;
      runCloseDelay();
    },
    onFocus: (e) => {
      if (matchesSelector(e.target, ":focus-visible") === false)
        return;
      isFocused = true;
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    onBlur: (e) => {
      isFocused = false;
      e.stopPropagation();
      runCloseDelay();
    }
  };
  const activatorEvents = computed(() => {
    const events = {};
    if (openOnClick.value) {
      events.onClick = availableEvents.onClick;
    }
    if (props2.openOnHover) {
      events.onMouseenter = availableEvents.onMouseenter;
      events.onMouseleave = availableEvents.onMouseleave;
    }
    if (openOnFocus.value) {
      events.onFocus = availableEvents.onFocus;
      events.onBlur = availableEvents.onBlur;
    }
    return events;
  });
  const contentEvents = computed(() => {
    const events = {};
    if (props2.openOnHover) {
      events.onMouseenter = () => {
        isHovered = true;
        runOpenDelay();
      };
      events.onMouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    if (openOnFocus.value) {
      events.onFocusin = () => {
        isFocused = true;
        runOpenDelay();
      };
      events.onFocusout = () => {
        isFocused = false;
        runCloseDelay();
      };
    }
    if (props2.closeOnContentClick) {
      const menu = inject$1(VMenuSymbol, null);
      events.onClick = () => {
        isActive.value = false;
        menu?.closeParents();
      };
    }
    return events;
  });
  const scrimEvents = computed(() => {
    const events = {};
    if (props2.openOnHover) {
      events.onMouseenter = () => {
        if (firstEnter) {
          isHovered = true;
          firstEnter = false;
          runOpenDelay();
        }
      };
      events.onMouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    return events;
  });
  watch(isTop, (val) => {
    if (val && (props2.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props2.openOnHover || !isHovered))) {
      isActive.value = false;
    }
  });
  watch(isActive, (val) => {
    if (!val) {
      setTimeout(() => {
        cursorTarget.value = void 0;
      });
    }
  }, {
    flush: "post"
  });
  const activatorRef = ref();
  watchEffect(() => {
    if (!activatorRef.value)
      return;
    nextTick(() => {
      activatorEl.value = refElement(activatorRef.value);
    });
  });
  const targetRef = ref();
  const target = computed(() => {
    if (props2.target === "cursor" && cursorTarget.value)
      return cursorTarget.value;
    if (targetRef.value)
      return refElement(targetRef.value);
    return getTarget(props2.target, vm) || activatorEl.value;
  });
  const targetEl = computed(() => {
    return Array.isArray(target.value) ? void 0 : target.value;
  });
  let scope;
  watch(() => !!props2.activator, (val) => {
    if (val && IN_BROWSER) {
      scope = effectScope();
      scope.run(() => {
        _useActivator(props2, vm, {
          activatorEl,
          activatorEvents
        });
      });
    } else if (scope) {
      scope.stop();
    }
  }, {
    flush: "post",
    immediate: true
  });
  onScopeDispose(() => {
    scope?.stop();
  });
  return {
    activatorEl,
    activatorRef,
    target,
    targetEl,
    targetRef,
    activatorEvents,
    contentEvents,
    scrimEvents
  };
}
function _useActivator(props2, vm, _ref2) {
  let {
    activatorEl,
    activatorEvents
  } = _ref2;
  watch(() => props2.activator, (val, oldVal) => {
    if (oldVal && val !== oldVal) {
      const activator = getActivator(oldVal);
      activator && unbindActivatorProps(activator);
    }
    if (val) {
      nextTick(() => bindActivatorProps());
    }
  }, {
    immediate: true
  });
  watch(() => props2.activatorProps, () => {
    bindActivatorProps();
  });
  onScopeDispose(() => {
    unbindActivatorProps();
  });
  function bindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props2.activatorProps;
    if (!el)
      return;
    bindProps(el, mergeProps(activatorEvents.value, _props));
  }
  function unbindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props2.activatorProps;
    if (!el)
      return;
    unbindProps(el, mergeProps(activatorEvents.value, _props));
  }
  function getActivator() {
    let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props2.activator;
    const activator = getTarget(selector, vm);
    activatorEl.value = activator?.nodeType === Node.ELEMENT_NODE ? activator : void 0;
    return activatorEl.value;
  }
}
function getTarget(selector, vm) {
  if (!selector)
    return;
  let target;
  if (selector === "parent") {
    let el = vm?.proxy?.$el?.parentNode;
    while (el?.hasAttribute("data-no-activator")) {
      el = el.parentNode;
    }
    target = el;
  } else if (typeof selector === "string") {
    target = document.querySelector(selector);
  } else if ("$el" in selector) {
    target = selector.$el;
  } else {
    target = selector;
  }
  return target;
}
function useHydration() {
  if (!IN_BROWSER)
    return shallowRef(false);
  const {
    ssr
  } = useDisplay();
  if (ssr) {
    const isMounted = shallowRef(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return isMounted;
  } else {
    return shallowRef(true);
  }
}
const makeLazyProps = propsFactory({
  eager: Boolean
}, "lazy");
function useLazy(props2, active) {
  const isBooted = shallowRef(false);
  const hasContent = computed(() => isBooted.value || props2.eager || active.value);
  watch(active, () => isBooted.value = true);
  function onAfterLeave() {
    if (!props2.eager)
      isBooted.value = false;
  }
  return {
    isBooted,
    hasContent,
    onAfterLeave
  };
}
function useScopeId() {
  const vm = getCurrentInstance("useScopeId");
  const scopeId = vm.vnode.scopeId;
  return {
    scopeId: scopeId ? {
      [scopeId]: ""
    } : void 0
  };
}
const StackSymbol = Symbol.for("vuetify:stack");
const globalStack = reactive([]);
function useStack(isActive, zIndex, disableGlobalStack) {
  const vm = getCurrentInstance("useStack");
  const createStackEntry = !disableGlobalStack;
  const parent = inject$1(StackSymbol, void 0);
  const stack = reactive({
    activeChildren: /* @__PURE__ */ new Set()
  });
  provide(StackSymbol, stack);
  const _zIndex = shallowRef(+zIndex.value);
  useToggleScope(isActive, () => {
    const lastZIndex = globalStack.at(-1)?.[1];
    _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
    if (createStackEntry) {
      globalStack.push([vm.uid, _zIndex.value]);
    }
    parent?.activeChildren.add(vm.uid);
    onScopeDispose(() => {
      if (createStackEntry) {
        const idx = toRaw(globalStack).findIndex((v) => v[0] === vm.uid);
        globalStack.splice(idx, 1);
      }
      parent?.activeChildren.delete(vm.uid);
    });
  });
  const globalTop = shallowRef(true);
  if (createStackEntry) {
    watchEffect(() => {
      const _isTop = globalStack.at(-1)?.[0] === vm.uid;
      setTimeout(() => globalTop.value = _isTop);
    });
  }
  const localTop = computed(() => !stack.activeChildren.size);
  return {
    globalTop: readonly(globalTop),
    localTop,
    stackStyles: computed(() => ({
      zIndex: _zIndex.value
    }))
  };
}
function useTeleport(target) {
  const teleportTarget = computed(() => {
    const _target = target.value;
    if (_target === true || !IN_BROWSER)
      return void 0;
    const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
    if (targetElement == null) {
      return void 0;
    }
    let container = targetElement.querySelector(":scope > .v-overlay-container");
    if (!container) {
      container = document.createElement("div");
      container.className = "v-overlay-container";
      targetElement.appendChild(container);
    }
    return container;
  });
  return {
    teleportTarget
  };
}
function defaultConditional() {
  return true;
}
function checkEvent(e, el, binding) {
  if (!e || checkIsActive(e, binding) === false)
    return false;
  const root = attachedRoot(el);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
    return false;
  const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
  elements.push(el);
  return !elements.some((el2) => el2?.contains(e.target));
}
function checkIsActive(e, binding) {
  const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
  return isActive(e);
}
function directive(e, el, binding) {
  const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
  el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
    checkIsActive(e, binding) && handler && handler(e);
  }, 0);
}
function handleShadow(el, callback) {
  const root = attachedRoot(el);
  callback(document);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
    callback(root);
  }
}
const ClickOutside = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(el, binding) {
    const onClick = (e) => directive(e, el, binding);
    const onMousedown = (e) => {
      el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
    };
    handleShadow(el, (app2) => {
      app2.addEventListener("click", onClick, true);
      app2.addEventListener("mousedown", onMousedown, true);
    });
    if (!el._clickOutside) {
      el._clickOutside = {
        lastMousedownWasOutside: false
      };
    }
    el._clickOutside[binding.instance.$.uid] = {
      onClick,
      onMousedown
    };
  },
  unmounted(el, binding) {
    if (!el._clickOutside)
      return;
    handleShadow(el, (app2) => {
      if (!app2 || !el._clickOutside?.[binding.instance.$.uid])
        return;
      const {
        onClick,
        onMousedown
      } = el._clickOutside[binding.instance.$.uid];
      app2.removeEventListener("click", onClick, true);
      app2.removeEventListener("mousedown", onMousedown, true);
    });
    delete el._clickOutside[binding.instance.$.uid];
  }
};
function Scrim(props2) {
  const {
    modelValue,
    color,
    ...rest
  } = props2;
  return createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props2.modelValue && createVNode("div", mergeProps({
      "class": ["v-overlay__scrim", props2.color.backgroundColorClasses.value],
      "style": props2.color.backgroundColorStyles.value
    }, rest), null)]
  });
}
const makeVOverlayProps = propsFactory({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: true
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...makeActivatorProps(),
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeLazyProps(),
  ...makeLocationStrategyProps(),
  ...makeScrollStrategyProps(),
  ...makeThemeProps(),
  ...makeTransitionProps()
}, "VOverlay");
const VOverlay = genericComponent()({
  name: "VOverlay",
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: {
    _disableGlobalStack: Boolean,
    ...makeVOverlayProps()
  },
  emits: {
    "click:outside": (e) => true,
    "update:modelValue": (value) => true,
    afterLeave: () => true
  },
  setup(props2, _ref) {
    let {
      slots,
      attrs,
      emit: emit2
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const isActive = computed({
      get: () => model.value,
      set: (v) => {
        if (!(v && props2.disabled))
          model.value = v;
      }
    });
    const {
      teleportTarget
    } = useTeleport(computed(() => props2.attach || props2.contained));
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      rtlClasses,
      isRtl
    } = useRtl();
    const {
      hasContent,
      onAfterLeave: _onAfterLeave
    } = useLazy(props2, isActive);
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props2.scrim === "string" ? props2.scrim : null;
    }));
    const {
      globalTop,
      localTop,
      stackStyles
    } = useStack(isActive, toRef(props2, "zIndex"), props2._disableGlobalStack);
    const {
      activatorEl,
      activatorRef,
      target,
      targetEl,
      targetRef,
      activatorEvents,
      contentEvents,
      scrimEvents
    } = useActivator(props2, {
      isActive,
      isTop: localTop
    });
    const {
      dimensionStyles
    } = useDimension(props2);
    const isMounted = useHydration();
    const {
      scopeId
    } = useScopeId();
    watch(() => props2.disabled, (v) => {
      if (v)
        isActive.value = false;
    });
    const root = ref();
    const contentEl = ref();
    const {
      contentStyles,
      updateLocation
    } = useLocationStrategies(props2, {
      isRtl,
      contentEl,
      target,
      isActive
    });
    useScrollStrategies(props2, {
      root,
      contentEl,
      targetEl,
      isActive,
      updateLocation
    });
    function onClickOutside(e) {
      emit2("click:outside", e);
      if (!props2.persistent)
        isActive.value = false;
      else
        animateClick();
    }
    function closeConditional() {
      return isActive.value && globalTop.value;
    }
    IN_BROWSER && watch(isActive, (val) => {
      if (val) {
        window.addEventListener("keydown", onKeydown);
      } else {
        window.removeEventListener("keydown", onKeydown);
      }
    }, {
      immediate: true
    });
    onBeforeUnmount(() => {
      if (!IN_BROWSER)
        return;
      window.removeEventListener("keydown", onKeydown);
    });
    function onKeydown(e) {
      if (e.key === "Escape" && globalTop.value) {
        if (!props2.persistent) {
          isActive.value = false;
          if (contentEl.value?.contains(document.activeElement)) {
            activatorEl.value?.focus();
          }
        } else
          animateClick();
      }
    }
    const router2 = useRouter$1();
    useToggleScope(() => props2.closeOnBack, () => {
      useBackButton(router2, (next) => {
        if (globalTop.value && isActive.value) {
          next(false);
          if (!props2.persistent)
            isActive.value = false;
          else
            animateClick();
        } else {
          next();
        }
      });
    });
    const top = ref();
    watch(() => isActive.value && (props2.absolute || props2.contained) && teleportTarget.value == null, (val) => {
      if (val) {
        const scrollParent = getScrollParent$1(root.value);
        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    });
    function animateClick() {
      if (props2.noClickAnimation)
        return;
      contentEl.value && animate(contentEl.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: standardEasing
      });
    }
    function onAfterLeave() {
      _onAfterLeave();
      emit2("afterLeave");
    }
    useRender(() => createVNode(Fragment, null, [slots.activator?.({
      isActive: isActive.value,
      props: mergeProps({
        ref: activatorRef,
        targetRef
      }, activatorEvents.value, props2.activatorProps)
    }), isMounted.value && hasContent.value && createVNode(Teleport, {
      "disabled": !teleportTarget.value,
      "to": teleportTarget.value
    }, {
      default: () => [createVNode("div", mergeProps({
        "class": ["v-overlay", {
          "v-overlay--absolute": props2.absolute || props2.contained,
          "v-overlay--active": isActive.value,
          "v-overlay--contained": props2.contained
        }, themeClasses.value, rtlClasses.value, props2.class],
        "style": [stackStyles.value, {
          "--v-overlay-opacity": props2.opacity,
          top: convertToUnit(top.value)
        }, props2.style],
        "ref": root
      }, scopeId, attrs), [createVNode(Scrim, mergeProps({
        "color": scrimColor,
        "modelValue": isActive.value && !!props2.scrim
      }, scrimEvents.value), null), createVNode(MaybeTransition, {
        "appear": true,
        "persisted": true,
        "transition": props2.transition,
        "target": target.value,
        "onAfterLeave": onAfterLeave
      }, {
        default: () => [withDirectives(createVNode("div", mergeProps({
          "ref": contentEl,
          "class": ["v-overlay__content", props2.contentClass],
          "style": [dimensionStyles.value, contentStyles.value]
        }, contentEvents.value, props2.contentProps), [slots.default?.({
          isActive
        })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
          handler: onClickOutside,
          closeConditional,
          include: () => [activatorEl.value]
        }]])]
      })])]
    })]));
    return {
      activatorEl,
      target,
      animateClick,
      contentEl,
      globalTop,
      localTop,
      updateLocation
    };
  }
});
const Refs = Symbol("Forwarded refs");
function getDescriptor(obj, key) {
  let currentObj = obj;
  while (currentObj) {
    const descriptor = Reflect.getOwnPropertyDescriptor(currentObj, key);
    if (descriptor)
      return descriptor;
    currentObj = Object.getPrototypeOf(currentObj);
  }
  return void 0;
}
function forwardRefs(target) {
  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    refs[_key - 1] = arguments[_key];
  }
  target[Refs] = refs;
  return new Proxy(target, {
    get(target2, key) {
      if (Reflect.has(target2, key)) {
        return Reflect.get(target2, key);
      }
      if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          const val = Reflect.get(ref2.value, key);
          return typeof val === "function" ? val.bind(ref2.value) : val;
        }
      }
    },
    has(target2, key) {
      if (Reflect.has(target2, key)) {
        return true;
      }
      if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
        return false;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          return true;
        }
      }
      return false;
    },
    set(target2, key, value) {
      if (Reflect.has(target2, key)) {
        return Reflect.set(target2, key, value);
      }
      if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
        return false;
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          return Reflect.set(ref2.value, key, value);
        }
      }
      return false;
    },
    getOwnPropertyDescriptor(target2, key) {
      const descriptor = Reflect.getOwnPropertyDescriptor(target2, key);
      if (descriptor)
        return descriptor;
      if (typeof key === "symbol" || key.startsWith("$") || key.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (!ref2.value)
          continue;
        const descriptor2 = getDescriptor(ref2.value, key) ?? ("_" in ref2.value ? getDescriptor(ref2.value._?.setupState, key) : void 0);
        if (descriptor2)
          return descriptor2;
      }
      for (const ref2 of refs) {
        const childRefs = ref2.value && ref2.value[Refs];
        if (!childRefs)
          continue;
        const queue2 = childRefs.slice();
        while (queue2.length) {
          const ref3 = queue2.shift();
          const descriptor2 = getDescriptor(ref3.value, key);
          if (descriptor2)
            return descriptor2;
          const childRefs2 = ref3.value && ref3.value[Refs];
          if (childRefs2)
            queue2.push(...childRefs2);
        }
      }
      return void 0;
    }
  });
}
const makeVMenuProps = propsFactory({
  // TODO
  // disableKeys: Boolean,
  id: String,
  ...omit(makeVOverlayProps({
    closeDelay: 250,
    closeOnContentClick: true,
    locationStrategy: "connected",
    openDelay: 300,
    scrim: false,
    scrollStrategy: "reposition",
    transition: {
      component: VDialogTransition
    }
  }), ["absolute"])
}, "VMenu");
const VMenu = genericComponent()({
  name: "VMenu",
  props: makeVMenuProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props2.id || `v-menu-${uid2}`);
    const overlay = ref();
    const parent = inject$1(VMenuSymbol, null);
    const openChildren = shallowRef(0);
    provide(VMenuSymbol, {
      register() {
        ++openChildren.value;
      },
      unregister() {
        --openChildren.value;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren.value) {
            isActive.value = false;
            parent?.closeParents();
          }
        }, 40);
      }
    });
    async function onFocusIn(e) {
      const before = e.relatedTarget;
      const after = e.target;
      await nextTick();
      if (isActive.value && before !== after && overlay.value?.contentEl && // We're the topmost menu
      overlay.value?.globalTop && // It isn't the document or the menu body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the menu body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        focusable[0]?.focus();
      }
    }
    watch(isActive, (val) => {
      if (val) {
        parent?.register();
        document.addEventListener("focusin", onFocusIn, {
          once: true
        });
      } else {
        parent?.unregister();
        document.removeEventListener("focusin", onFocusIn);
      }
    });
    function onClickOutside() {
      parent?.closeParents();
    }
    function onKeydown(e) {
      if (props2.disabled)
        return;
      if (e.key === "Tab") {
        const nextElement = getNextElement(focusableChildren(overlay.value?.contentEl, false), e.shiftKey ? "prev" : "next", (el) => el.tabIndex >= 0);
        if (!nextElement) {
          isActive.value = false;
          overlay.value?.activatorEl?.focus();
        }
      }
    }
    function onActivatorKeydown(e) {
      if (props2.disabled)
        return;
      const el = overlay.value?.contentEl;
      if (el && isActive.value) {
        if (e.key === "ArrowDown") {
          e.preventDefault();
          focusChild(el, "next");
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          focusChild(el, "prev");
        }
      } else if (["ArrowDown", "ArrowUp"].includes(e.key)) {
        isActive.value = true;
        e.preventDefault();
        setTimeout(() => setTimeout(() => onActivatorKeydown(e)));
      }
    }
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "menu",
      "aria-expanded": String(isActive.value),
      "aria-owns": id.value,
      onKeydown: onActivatorKeydown
    }, props2.activatorProps));
    useRender(() => {
      const overlayProps = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "id": id.value,
        "class": ["v-menu", props2.class],
        "style": props2.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": activatorProps.value,
        "onClick:outside": onClickOutside,
        "onKeydown": onKeydown
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VMenu"
          }, {
            default: () => [slots.default?.(...args)]
          });
        }
      });
    });
    return forwardRefs({
      id,
      ΨopenChildren: openChildren
    }, overlay);
  }
});
const VSelect$1 = "";
const VTextField$1 = "";
const VCounter$1 = "";
const makeVCounterProps = propsFactory({
  active: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...makeComponentProps(),
  ...makeTransitionProps({
    transition: {
      component: VSlideYTransition
    }
  })
}, "VCounter");
const VCounter = genericComponent()({
  name: "VCounter",
  functional: true,
  props: makeVCounterProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const counter = computed(() => {
      return props2.max ? `${props2.value} / ${props2.max}` : String(props2.value);
    });
    useRender(() => createVNode(MaybeTransition, {
      "transition": props2.transition
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": ["v-counter", props2.class],
        "style": props2.style
      }, [slots.default ? slots.default({
        counter: counter.value,
        max: props2.max,
        value: props2.value
      }) : counter.value]), [[vShow, props2.active]])]
    }));
    return {};
  }
});
const VField$1 = "";
const makeVFieldLabelProps = propsFactory({
  floating: Boolean,
  ...makeComponentProps()
}, "VFieldLabel");
const VFieldLabel = genericComponent()({
  name: "VFieldLabel",
  props: makeVFieldLabelProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VLabel, {
      "class": ["v-field-label", {
        "v-field-label--floating": props2.floating
      }, props2.class],
      "style": props2.style,
      "aria-hidden": props2.floating || void 0
    }, slots));
    return {};
  }
});
const allowedVariants$1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"];
const makeVFieldProps = propsFactory({
  appendInnerIcon: IconValue,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: IconValue,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  flat: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: IconValue,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (v) => allowedVariants$1.includes(v)
  },
  "onClick:clear": EventProp(),
  "onClick:appendInner": EventProp(),
  "onClick:prependInner": EventProp(),
  ...makeComponentProps(),
  ...makeLoaderProps(),
  ...makeRoundedProps(),
  ...makeThemeProps()
}, "VField");
const VField = genericComponent()({
  name: "VField",
  inheritAttrs: false,
  props: {
    id: String,
    ...makeFocusProps(),
    ...makeVFieldProps()
  },
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      focusClasses,
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const {
      InputIcon
    } = useInputIcon(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      rtlClasses
    } = useRtl();
    const isActive = computed(() => props2.dirty || props2.active);
    const hasLabel = computed(() => !props2.singleLine && !!(props2.label || slots.label));
    const uid2 = getUid();
    const id = computed(() => props2.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return props2.error || props2.disabled ? void 0 : isActive.value && isFocused.value ? props2.color : props2.baseColor;
    }));
    watch(isActive, (val) => {
      if (hasLabel.value) {
        const el = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        requestAnimationFrame(() => {
          const rect = nullifyTransforms(el);
          const targetRect = targetEl.getBoundingClientRect();
          const x2 = targetRect.x - rect.x;
          const y = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
          const targetWidth = targetRect.width / 0.75;
          const width = Math.abs(targetWidth - rect.width) > 1 ? {
            maxWidth: convertToUnit(targetWidth)
          } : void 0;
          const style3 = getComputedStyle(el);
          const targetStyle = getComputedStyle(targetEl);
          const duration = parseFloat(style3.transitionDuration) * 1e3 || 150;
          const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
          const color = targetStyle.getPropertyValue("color");
          el.style.visibility = "visible";
          targetEl.style.visibility = "hidden";
          animate(el, {
            transform: `translate(${x2}px, ${y}px) scale(${scale})`,
            color,
            ...width
          }, {
            duration,
            easing: standardEasing,
            direction: val ? "normal" : "reverse"
          }).finished.then(() => {
            el.style.removeProperty("visibility");
            targetEl.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const slotProps = computed(() => ({
      isActive,
      isFocused,
      controlRef,
      blur,
      focus
    }));
    function onClick(e) {
      if (e.target !== document.activeElement) {
        e.preventDefault();
      }
    }
    useRender(() => {
      const isOutlined = props2.variant === "outlined";
      const hasPrepend = slots["prepend-inner"] || props2.prependInnerIcon;
      const hasClear = !!(props2.clearable || slots.clear);
      const hasAppend = !!(slots["append-inner"] || props2.appendInnerIcon || hasClear);
      const label = () => slots.label ? slots.label({
        ...slotProps.value,
        label: props2.label,
        props: {
          for: id.value
        }
      }) : props2.label;
      return createVNode("div", mergeProps({
        "class": ["v-field", {
          "v-field--active": isActive.value,
          "v-field--appended": hasAppend,
          "v-field--center-affix": props2.centerAffix ?? !isPlainOrUnderlined.value,
          "v-field--disabled": props2.disabled,
          "v-field--dirty": props2.dirty,
          "v-field--error": props2.error,
          "v-field--flat": props2.flat,
          "v-field--has-background": !!props2.bgColor,
          "v-field--persistent-clear": props2.persistentClear,
          "v-field--prepended": hasPrepend,
          "v-field--reverse": props2.reverse,
          "v-field--single-line": props2.singleLine,
          "v-field--no-label": !label(),
          [`v-field--variant-${props2.variant}`]: true
        }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value, roundedClasses.value, rtlClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style],
        "onClick": onClick
      }, attrs), [createVNode("div", {
        "class": "v-field__overlay"
      }, null), createVNode(LoaderSlot, {
        "name": "v-field",
        "active": !!props2.loading,
        "color": props2.error ? "error" : typeof props2.loading === "string" ? props2.loading : props2.color
      }, {
        default: slots.loader
      }), hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-field__prepend-inner"
      }, [props2.prependInnerIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prependInner"
      }, null), slots["prepend-inner"]?.(slotProps.value)]), createVNode("div", {
        "class": "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(props2.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "key": "floating-label",
        "ref": floatingLabelRef,
        "class": [textColorClasses.value],
        "floating": true,
        "for": id.value,
        "style": textColorStyles.value
      }, {
        default: () => [label()]
      }), createVNode(VFieldLabel, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label()]
      }), slots.default?.({
        ...slotProps.value,
        props: {
          id: id.value,
          class: "v-field__input",
          "aria-describedby": messagesId.value
        },
        focus,
        blur
      })]), hasClear && createVNode(VExpandXTransition, {
        "key": "clear"
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-field__clearable",
          "onMousedown": (e) => {
            e.preventDefault();
            e.stopPropagation();
          }
        }, [slots.clear ? slots.clear() : createVNode(InputIcon, {
          "name": "clear"
        }, null)]), [[vShow, props2.dirty]])]
      }), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-field__append-inner"
      }, [slots["append-inner"]?.(slotProps.value), props2.appendInnerIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "appendInner"
      }, null)]), createVNode("div", {
        "class": ["v-field__outline", textColorClasses.value],
        "style": textColorStyles.value
      }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
        "class": "v-field__outline__start"
      }, null), hasLabel.value && createVNode("div", {
        "class": "v-field__outline__notch"
      }, [createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label()]
      })]), createVNode("div", {
        "class": "v-field__outline__end"
      }, null)]), isPlainOrUnderlined.value && hasLabel.value && createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label()]
      })])]);
    });
    return {
      controlRef
    };
  }
});
function filterFieldProps(attrs) {
  const keys = Object.keys(VField.props).filter((k2) => !isOn(k2) && k2 !== "class" && k2 !== "style");
  return pick(attrs, keys);
}
const activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
const makeVTextFieldProps = propsFactory({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...makeVInputProps(),
  ...makeVFieldProps()
}, "VTextField");
const VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: Intersect$1
  },
  inheritAttrs: false,
  props: makeVTextFieldProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : typeof props2.counterValue === "number" ? props2.counterValue : (model.value ?? "").toString().length;
    });
    const max = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props2.counter || typeof props2.counter !== "number" && typeof props2.counter !== "string")
        return void 0;
      return props2.counter;
    });
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    function onIntersect(isIntersecting, entries) {
      if (!props2.autofocus || !isIntersecting)
        return;
      entries[0].target?.focus?.();
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props2.type) || props2.persistentPlaceholder || isFocused.value || props2.active);
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        inputRef.value?.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
      if (e.target === inputRef.value)
        return;
      onFocus();
      e.preventDefault();
    }
    function onControlClick(e) {
      onFocus();
      emit2("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = null;
        callEvent(props2["onClick:clear"], e);
      });
    }
    function onInput(e) {
      const el = e.target;
      model.value = el.value;
      if (props2.modelModifiers?.trim && ["text", "search", "password", "tel", "url"].includes(props2.type)) {
        const caretPosition = [el.selectionStart, el.selectionEnd];
        nextTick(() => {
          el.selectionStart = caretPosition[0];
          el.selectionEnd = caretPosition[1];
        });
      }
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props2.counter !== false && props2.counter != null);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const {
        modelValue: _,
        ...inputProps
      } = VInput.filterProps(props2);
      const fieldProps = filterFieldProps(props2);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--prefixed": props2.prefix,
          "v-text-field--suffixed": props2.suffix,
          "v-input--plain-underlined": isPlainOrUnderlined.value
        }, props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "centerAffix": !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": onControlMousedown,
            "onClick": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": props2["onClick:prependInner"],
            "onClick:appendInner": props2["onClick:appendInner"],
            "role": props2.role
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props2.dirty,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref3;
              const inputNode = withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "value": model.value,
                "onInput": onInput,
                "autofocus": props2.autofocus,
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "name": props2.name,
                "placeholder": props2.placeholder,
                "size": 1,
                "type": props2.type,
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]]);
              return createVNode(Fragment, null, [props2.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [createVNode("span", {
                "class": "v-text-field__prefix__text"
              }, [props2.prefix])]), slots.default ? createVNode("div", {
                "class": fieldClass,
                "data-no-activator": ""
              }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                class: fieldClass
              }), props2.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [createVNode("span", {
                "class": "v-text-field__suffix__text"
              }, [props2.suffix])])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => createVNode(Fragment, null, [slots.details?.(slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": props2.persistentCounter || isFocused.value,
          "value": counterValue.value,
          "max": max.value
        }, slots.counter)])]) : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, inputRef);
  }
});
const VVirtualScroll$1 = "";
const makeVVirtualScrollItemProps = propsFactory({
  renderless: Boolean,
  ...makeComponentProps()
}, "VVirtualScrollItem");
const VVirtualScrollItem = genericComponent()({
  name: "VVirtualScrollItem",
  inheritAttrs: false,
  props: makeVVirtualScrollItemProps(),
  emits: {
    "update:height": (height) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      resizeRef,
      contentRect
    } = useResizeObserver(void 0, "border");
    watch(() => contentRect.value?.height, (height) => {
      if (height != null)
        emit2("update:height", height);
    });
    useRender(() => props2.renderless ? createVNode(Fragment, null, [slots.default?.({
      itemRef: resizeRef
    })]) : createVNode("div", mergeProps({
      "ref": resizeRef,
      "class": ["v-virtual-scroll__item", props2.class],
      "style": props2.style
    }, attrs), [slots.default?.()]));
  }
});
const UP = -1;
const DOWN = 1;
const BUFFER_PX = 100;
const makeVirtualProps = propsFactory({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  height: [Number, String]
}, "virtual");
function useVirtual(props2, items) {
  const display = useDisplay();
  const itemHeight = shallowRef(0);
  watchEffect(() => {
    itemHeight.value = parseFloat(props2.itemHeight || 0);
  });
  const first = shallowRef(0);
  const last = shallowRef(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(props2.height) || display.height.value) / (itemHeight.value || 16)
  ) || 1);
  const paddingTop = shallowRef(0);
  const paddingBottom = shallowRef(0);
  const containerRef = ref();
  const markerRef = ref();
  let markerOffset = 0;
  const {
    resizeRef,
    contentRect
  } = useResizeObserver();
  watchEffect(() => {
    resizeRef.value = containerRef.value;
  });
  const viewportHeight = computed(() => {
    return containerRef.value === document.documentElement ? display.height.value : contentRect.value?.height || parseInt(props2.height) || 0;
  });
  const hasInitialRender = computed(() => {
    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);
  });
  let sizes = Array.from({
    length: items.value.length
  });
  let offsets = Array.from({
    length: items.value.length
  });
  const updateTime = shallowRef(0);
  let targetScrollIndex = -1;
  function getSize(index2) {
    return sizes[index2] || itemHeight.value;
  }
  const updateOffsets = debounce(() => {
    const start = performance.now();
    offsets[0] = 0;
    const length = items.value.length;
    for (let i = 1; i <= length - 1; i++) {
      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1);
    }
    updateTime.value = Math.max(updateTime.value, performance.now() - start);
  }, updateTime);
  const unwatch = watch(hasInitialRender, (v) => {
    if (!v)
      return;
    unwatch();
    markerOffset = markerRef.value.offsetTop;
    updateOffsets.immediate();
    calculateVisibleItems();
    if (!~targetScrollIndex)
      return;
    nextTick(() => {
      IN_BROWSER && window.requestAnimationFrame(() => {
        scrollToIndex(targetScrollIndex);
        targetScrollIndex = -1;
      });
    });
  });
  watch(viewportHeight, (val, oldVal) => {
    oldVal && calculateVisibleItems();
  });
  onScopeDispose(() => {
    updateOffsets.clear();
  });
  function handleItemResize(index2, height) {
    const prevHeight = sizes[index2];
    const prevMinHeight = itemHeight.value;
    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;
    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {
      sizes[index2] = height;
      updateOffsets();
    }
  }
  function calculateOffset(index2) {
    index2 = clamp(index2, 0, items.value.length - 1);
    return offsets[index2] || 0;
  }
  function calculateIndex(scrollTop) {
    return binaryClosest(offsets, scrollTop);
  }
  let lastScrollTop = 0;
  let scrollVelocity = 0;
  let lastScrollTime = 0;
  function handleScroll() {
    if (!containerRef.value || !markerRef.value)
      return;
    const scrollTop = containerRef.value.scrollTop;
    const scrollTime = performance.now();
    const scrollDeltaT = scrollTime - lastScrollTime;
    if (scrollDeltaT > 500) {
      scrollVelocity = Math.sign(scrollTop - lastScrollTop);
      markerOffset = markerRef.value.offsetTop;
    } else {
      scrollVelocity = scrollTop - lastScrollTop;
    }
    lastScrollTop = scrollTop;
    lastScrollTime = scrollTime;
    calculateVisibleItems();
  }
  function handleScrollend() {
    if (!containerRef.value || !markerRef.value)
      return;
    scrollVelocity = 0;
    lastScrollTime = 0;
    calculateVisibleItems();
  }
  let raf2 = -1;
  function calculateVisibleItems() {
    cancelAnimationFrame(raf2);
    raf2 = requestAnimationFrame(_calculateVisibleItems);
  }
  function _calculateVisibleItems() {
    if (!containerRef.value || !viewportHeight.value)
      return;
    const scrollTop = lastScrollTop - markerOffset;
    const direction = Math.sign(scrollVelocity);
    const startPx = Math.max(0, scrollTop - BUFFER_PX);
    const start = clamp(calculateIndex(startPx), 0, items.value.length);
    const endPx = scrollTop + viewportHeight.value + BUFFER_PX;
    const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (direction !== UP || start < first.value) && (direction !== DOWN || end > last.value)
    ) {
      const topOverflow = calculateOffset(first.value) - calculateOffset(start);
      const bottomOverflow = calculateOffset(end) - calculateOffset(last.value);
      const bufferOverflow = Math.max(topOverflow, bottomOverflow);
      if (bufferOverflow > BUFFER_PX) {
        first.value = start;
        last.value = end;
      } else {
        if (start <= 0)
          first.value = start;
        if (end >= items.value.length)
          last.value = end;
      }
    }
    paddingTop.value = calculateOffset(first.value);
    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);
  }
  function scrollToIndex(index2) {
    const offset = calculateOffset(index2);
    if (!containerRef.value || index2 && !offset) {
      targetScrollIndex = index2;
    } else {
      containerRef.value.scrollTop = offset;
    }
  }
  const computedItems = computed(() => {
    return items.value.slice(first.value, last.value).map((item, index2) => ({
      raw: item,
      index: index2 + first.value
    }));
  });
  watch(items, () => {
    sizes = Array.from({
      length: items.value.length
    });
    offsets = Array.from({
      length: items.value.length
    });
    updateOffsets.immediate();
    calculateVisibleItems();
  }, {
    deep: true
  });
  return {
    containerRef,
    markerRef,
    computedItems,
    paddingTop,
    paddingBottom,
    scrollToIndex,
    handleScroll,
    handleScrollend,
    handleItemResize
  };
}
function binaryClosest(arr, val) {
  let high = arr.length - 1;
  let low = 0;
  let mid = 0;
  let item = null;
  let target = -1;
  if (arr[high] < val) {
    return high;
  }
  while (low <= high) {
    mid = low + high >> 1;
    item = arr[mid];
    if (item > val) {
      high = mid - 1;
    } else if (item < val) {
      target = mid;
      low = mid + 1;
    } else if (item === val) {
      return mid;
    } else {
      return low;
    }
  }
  return target;
}
const makeVVirtualScrollProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...makeVirtualProps(),
  ...makeComponentProps(),
  ...makeDimensionProps()
}, "VVirtualScroll");
const VVirtualScroll = genericComponent()({
  name: "VVirtualScroll",
  props: makeVVirtualScrollProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const vm = getCurrentInstance("VVirtualScroll");
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      containerRef,
      markerRef,
      handleScroll,
      handleScrollend,
      handleItemResize,
      scrollToIndex,
      paddingTop,
      paddingBottom,
      computedItems
    } = useVirtual(props2, toRef(props2, "items"));
    useToggleScope(() => props2.renderless, () => {
      function handleListeners() {
        let add2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        const method = add2 ? "addEventListener" : "removeEventListener";
        if (containerRef.value === document.documentElement) {
          document[method]("scroll", handleScroll, {
            passive: true
          });
          document[method]("scrollend", handleScrollend);
        } else {
          containerRef.value?.[method]("scroll", handleScroll, {
            passive: true
          });
          containerRef.value?.[method]("scrollend", handleScrollend);
        }
      }
      onMounted(() => {
        containerRef.value = getScrollParent$1(vm.vnode.el, true);
        handleListeners(true);
      });
      onScopeDispose(handleListeners);
    });
    useRender(() => {
      const children = computedItems.value.map((item) => createVNode(VVirtualScrollItem, {
        "key": item.index,
        "renderless": props2.renderless,
        "onUpdate:height": (height) => handleItemResize(item.index, height)
      }, {
        default: (slotProps) => slots.default?.({
          item: item.raw,
          index: item.index,
          ...slotProps
        })
      }));
      return props2.renderless ? createVNode(Fragment, null, [createVNode("div", {
        "ref": markerRef,
        "class": "v-virtual-scroll__spacer",
        "style": {
          paddingTop: convertToUnit(paddingTop.value)
        }
      }, null), children, createVNode("div", {
        "class": "v-virtual-scroll__spacer",
        "style": {
          paddingBottom: convertToUnit(paddingBottom.value)
        }
      }, null)]) : createVNode("div", {
        "ref": containerRef,
        "class": ["v-virtual-scroll", props2.class],
        "onScrollPassive": handleScroll,
        "onScrollend": handleScrollend,
        "style": [dimensionStyles.value, props2.style]
      }, [createVNode("div", {
        "ref": markerRef,
        "class": "v-virtual-scroll__container",
        "style": {
          paddingTop: convertToUnit(paddingTop.value),
          paddingBottom: convertToUnit(paddingBottom.value)
        }
      }, [children])]);
    });
    return {
      scrollToIndex
    };
  }
});
function useScrolling(listRef, textFieldRef) {
  const isScrolling = shallowRef(false);
  let scrollTimeout;
  function onListScroll(e) {
    cancelAnimationFrame(scrollTimeout);
    isScrolling.value = true;
    scrollTimeout = requestAnimationFrame(() => {
      scrollTimeout = requestAnimationFrame(() => {
        isScrolling.value = false;
      });
    });
  }
  async function finishScrolling() {
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => requestAnimationFrame(resolve2));
    await new Promise((resolve2) => {
      if (isScrolling.value) {
        const stop2 = watch(isScrolling, () => {
          stop2();
          resolve2();
        });
      } else
        resolve2();
    });
  }
  async function onListKeydown(e) {
    if (e.key === "Tab") {
      textFieldRef.value?.focus();
    }
    if (!["PageDown", "PageUp", "Home", "End"].includes(e.key))
      return;
    const el = listRef.value?.$el;
    if (!el)
      return;
    if (e.key === "Home" || e.key === "End") {
      el.scrollTo({
        top: e.key === "Home" ? 0 : el.scrollHeight,
        behavior: "smooth"
      });
    }
    await finishScrolling();
    const children = el.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (e.key === "PageDown" || e.key === "Home") {
      const top = el.getBoundingClientRect().top;
      for (const child of children) {
        if (child.getBoundingClientRect().top >= top) {
          child.focus();
          break;
        }
      }
    } else {
      const bottom = el.getBoundingClientRect().bottom;
      for (const child of [...children].reverse()) {
        if (child.getBoundingClientRect().bottom <= bottom) {
          child.focus();
          break;
        }
      }
    }
  }
  return {
    onListScroll,
    onListKeydown
  };
}
const makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  },
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  ...makeItemsProps({
    itemChildren: false
  })
}, "Select");
const makeVSelectProps = propsFactory({
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: {
      component: VDialogTransition
    }
  })
}, "VSelect");
const VSelect = genericComponent()({
  name: "VSelect",
  props: makeVSelectProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (value) => true,
    "update:menu": (ue) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props2, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        if (_menu.value && !v && vMenuRef.value?.ΨopenChildren)
          return;
        _menu.value = v;
      }
    });
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props2);
    const model = useProxiedModel(props2, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props2.multiple ? transformed : transformed[0] ?? null;
    });
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : typeof props2.counterValue === "number" ? props2.counterValue : model.value.length;
    });
    const form = useForm();
    const selectedValues = computed(() => model.value.map((selection) => selection.value));
    const isFocused = shallowRef(false);
    const label = computed(() => menu.value ? props2.closeText : props2.openText);
    let keyboardLookupPrefix = "";
    let keyboardLookupLastTime;
    const displayItems = computed(() => {
      if (props2.hideSelected) {
        return items.value.filter((item) => !model.value.some((s) => s === item));
      }
      return items.value;
    });
    const menuDisabled = computed(() => props2.hideNoData && !displayItems.value.length || props2.readonly || form?.isReadonly.value);
    const computedMenuProps = computed(() => {
      return {
        ...props2.menuProps,
        activatorProps: {
          ...props2.menuProps?.activatorProps || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    });
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      if (props2.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (!e.key || props2.readonly || form?.isReadonly.value)
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e.key)) {
        menu.value = false;
      }
      if (e.key === "Home") {
        listRef.value?.focus("first");
      } else if (e.key === "End") {
        listRef.value?.focus("last");
      }
      const KEYBOARD_LOOKUP_THRESHOLD = 1e3;
      function checkPrintable(e2) {
        const isPrintableChar = e2.key.length === 1;
        const noModifier = !e2.ctrlKey && !e2.metaKey && !e2.altKey;
        return isPrintableChar && noModifier;
      }
      if (props2.multiple || !checkPrintable(e))
        return;
      const now = performance.now();
      if (now - keyboardLookupLastTime > KEYBOARD_LOOKUP_THRESHOLD) {
        keyboardLookupPrefix = "";
      }
      keyboardLookupPrefix += e.key.toLowerCase();
      keyboardLookupLastTime = now;
      const item = items.value.find((item2) => item2.title.toLowerCase().startsWith(keyboardLookupPrefix));
      if (item !== void 0) {
        model.value = [item];
      }
    }
    function select(item) {
      if (props2.multiple) {
        const index2 = model.value.findIndex((selection) => props2.valueComparator(selection.value, item.value));
        if (index2 === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index2, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e) {
      if (!listRef.value?.$el.contains(e.relatedTarget)) {
        menu.value = false;
      }
    }
    function onAfterLeave() {
      if (isFocused.value) {
        vTextFieldRef.value?.focus();
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
    }
    function onModelUpdate(v) {
      if (v == null)
        model.value = [];
      else if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
        const item = items.value.find((item2) => item2.title === v);
        if (item) {
          select(item);
        }
      } else if (vTextFieldRef.value) {
        vTextFieldRef.value.value = "";
      }
    }
    watch(menu, () => {
      if (!props2.hideSelected && menu.value && model.value.length) {
        const index2 = displayItems.value.findIndex((item) => model.value.some((s) => props2.valueComparator(s.value, item.value)));
        IN_BROWSER && window.requestAnimationFrame(() => {
          index2 >= 0 && vVirtualScrollRef.value?.scrollToIndex(index2);
        });
      }
    });
    watch(displayItems, (val, oldVal) => {
      if (!isFocused.value)
        return;
      if (!val.length && props2.hideNoData) {
        menu.value = false;
      }
      if (!oldVal.length && val.length) {
        menu.value = true;
      }
    });
    useRender(() => {
      const hasChips = !!(props2.chips || slots.chip);
      const hasList = !!(!props2.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const textFieldProps = VTextField.filterProps(props2);
      const placeholder = isDirty || !isFocused.value && props2.label && !props2.persistentPlaceholder ? void 0 : props2.placeholder;
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": onModelUpdate,
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": counterValue.value,
        "dirty": isDirty,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props2.chips,
          [`v-select--${props2.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length,
          "v-select--selection-slot": !!slots.selection
        }, props2.class],
        "style": props2.style,
        "inputmode": "none",
        "placeholder": placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown,
        "aria-label": t(label.value),
        "title": t(label.value)
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-select__content",
          "disabled": menuDisabled.value,
          "eager": props2.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props2.transition,
          "onAfterLeave": onAfterLeave
        }, computedMenuProps.value), {
          default: () => [hasList && createVNode(VList, mergeProps({
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props2.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "aria-live": "polite",
            "color": props2.itemColor ?? props2.color
          }, props2.listProps), {
            default: () => [slots["prepend-item"]?.(), !displayItems.value.length && !props2.hideNoData && (slots["no-data"]?.() ?? createVNode(VListItem, {
              "title": t(props2.noDataText)
            }, null)), createVNode(VVirtualScroll, {
              "ref": vVirtualScrollRef,
              "renderless": true,
              "items": displayItems.value
            }, {
              default: (_ref2) => {
                let {
                  item,
                  index: index2,
                  itemRef
                } = _ref2;
                const itemProps = mergeProps(item.props, {
                  ref: itemRef,
                  key: index2,
                  onClick: () => select(item)
                });
                return slots.item?.({
                  item,
                  index: index2,
                  props: itemProps
                }) ?? createVNode(VListItem, mergeProps(itemProps, {
                  "role": "option"
                }), {
                  prepend: (_ref3) => {
                    let {
                      isSelected
                    } = _ref3;
                    return createVNode(Fragment, null, [props2.multiple && !props2.hideSelected ? createVNode(VCheckboxBtn, {
                      "key": item.value,
                      "modelValue": isSelected,
                      "ripple": false,
                      "tabindex": "-1"
                    }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                      "image": item.props.prependAvatar
                    }, null), item.props.prependIcon && createVNode(VIcon, {
                      "icon": item.props.prependIcon
                    }, null)]);
                  }
                });
              }
            }), slots["append-item"]?.()]
          })]
        }), model.value.map((item, index2) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
          const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
            item,
            index: index2,
            props: slotProps
          }) : slots.selection({
            item,
            index: index2
          })) : void 0;
          if (hasSlot && !slotContent)
            return void 0;
          return createVNode("div", {
            "key": item.value,
            "class": "v-select__selection"
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props2.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props2.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => [slotContent]
          }) : slotContent ?? createVNode("span", {
            "class": "v-select__selection-text"
          }, [item.title, props2.multiple && index2 < model.value.length - 1 && createVNode("span", {
            "class": "v-select__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [slots["append-inner"]?.(...args), props2.menuIcon ? createVNode(VIcon, {
            "class": "v-select__menu-icon",
            "icon": props2.menuIcon
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      menu,
      select
    }, vTextFieldRef);
  }
});
const defaultFilter = (value, query, item) => {
  if (value == null || query == null)
    return -1;
  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());
};
const makeFilterProps = propsFactory({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function filterItems(items, query, options) {
  const array = [];
  const filter = options?.default ?? defaultFilter;
  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false;
  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length;
  if (!items?.length)
    return array;
  loop:
    for (let i = 0; i < items.length; i++) {
      const [item, transformed = item] = wrapInArray(items[i]);
      const customMatches = {};
      const defaultMatches = {};
      let match = -1;
      if (query && !options?.noFilter) {
        if (typeof item === "object") {
          const filterKeys = keys || Object.keys(transformed);
          for (const key of filterKeys) {
            const value = getPropertyFromItem(transformed, key, transformed);
            const keyFilter = options?.customKeyFilter?.[key];
            match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);
            if (match !== -1 && match !== false) {
              if (keyFilter)
                customMatches[key] = match;
              else
                defaultMatches[key] = match;
            } else if (options?.filterMode === "every") {
              continue loop;
            }
          }
        } else {
          match = filter(item, query, item);
          if (match !== -1 && match !== false) {
            defaultMatches.title = match;
          }
        }
        const defaultMatchesLength = Object.keys(defaultMatches).length;
        const customMatchesLength = Object.keys(customMatches).length;
        if (!defaultMatchesLength && !customMatchesLength)
          continue;
        if (options?.filterMode === "union" && customMatchesLength !== customFiltersLength && !defaultMatchesLength)
          continue;
        if (options?.filterMode === "intersection" && (customMatchesLength !== customFiltersLength || !defaultMatchesLength))
          continue;
      }
      array.push({
        index: i,
        matches: {
          ...defaultMatches,
          ...customMatches
        }
      });
    }
  return array;
}
function useFilter(props2, items, query, options) {
  const filteredItems = ref([]);
  const filteredMatches = ref(/* @__PURE__ */ new Map());
  const transformedItems = computed(() => options?.transform ? unref(items).map((item) => [item, options.transform(item)]) : unref(items));
  watchEffect(() => {
    const _query = typeof query === "function" ? query() : unref(query);
    const strQuery = typeof _query !== "string" && typeof _query !== "number" ? "" : String(_query);
    const results = filterItems(transformedItems.value, strQuery, {
      customKeyFilter: {
        ...props2.customKeyFilter,
        ...unref(options?.customKeyFilter)
      },
      default: props2.customFilter,
      filterKeys: props2.filterKeys,
      filterMode: props2.filterMode,
      noFilter: props2.noFilter
    });
    const originalItems = unref(items);
    const _filteredItems = [];
    const _filteredMatches = /* @__PURE__ */ new Map();
    results.forEach((_ref) => {
      let {
        index: index2,
        matches: matches2
      } = _ref;
      const item = originalItems[index2];
      _filteredItems.push(item);
      _filteredMatches.set(item.value, matches2);
    });
    filteredItems.value = _filteredItems;
    filteredMatches.value = _filteredMatches;
  });
  function getMatches(item) {
    return filteredMatches.value.get(item.value);
  }
  return {
    filteredItems,
    filteredMatches,
    getMatches
  };
}
function highlightResult$1(text, matches2, length) {
  if (matches2 == null)
    return text;
  if (Array.isArray(matches2))
    throw new Error("Multiple matches is not implemented");
  return typeof matches2 === "number" && ~matches2 ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(0, matches2)]), createVNode("span", {
    "class": "v-autocomplete__mask"
  }, [text.substr(matches2, length)]), createVNode("span", {
    "class": "v-autocomplete__unmask"
  }, [text.substr(matches2 + length)])]) : text;
}
const makeVAutocompleteProps = propsFactory({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeSelectProps(),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: false
  })
}, "VAutocomplete");
const VAutocomplete = genericComponent()({
  name: "VAutocomplete",
  props: makeVAutocompleteProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:search": (value) => true,
    "update:modelValue": (value) => true,
    "update:menu": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = shallowRef(false);
    const isPristine = shallowRef(true);
    const listHasFocus = shallowRef(false);
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props2, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        if (_menu.value && !v && vMenuRef.value?.ΨopenChildren)
          return;
        _menu.value = v;
      }
    });
    const selectionIndex = shallowRef(-1);
    const color = computed(() => vTextFieldRef.value?.color);
    const label = computed(() => menu.value ? props2.closeText : props2.openText);
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    const search = useProxiedModel(props2, "search", "");
    const model = useProxiedModel(props2, "modelValue", [], (v) => transformIn(v === null ? [null] : wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props2.multiple ? transformed : transformed[0] ?? null;
    });
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : typeof props2.counterValue === "number" ? props2.counterValue : model.value.length;
    });
    const form = useForm();
    const {
      filteredItems,
      getMatches
    } = useFilter(props2, items, () => isPristine.value ? "" : search.value);
    const displayItems = computed(() => {
      if (props2.hideSelected) {
        return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const selectedValues = computed(() => model.value.map((selection) => selection.props.value));
    const highlightFirst = computed(() => {
      const selectFirst = props2.autoSelectFirst === true || props2.autoSelectFirst === "exact" && search.value === displayItems.value[0]?.title;
      return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
    });
    const menuDisabled = computed(() => props2.hideNoData && !displayItems.value.length || props2.readonly || form?.isReadonly.value);
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      if (props2.openOnClear) {
        menu.value = true;
      }
      search.value = "";
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = true;
    }
    function onMousedownMenuIcon(e) {
      if (menuDisabled.value)
        return;
      if (isFocused.value) {
        e.preventDefault();
        e.stopPropagation();
      }
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (props2.readonly || form?.isReadonly.value)
        return;
      const selectionStart = vTextFieldRef.value.selectionStart;
      const length = model.value.length;
      if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
        select(displayItems.value[0]);
      }
      if (e.key === "ArrowDown" && highlightFirst.value) {
        listRef.value?.focus("next");
      }
      if (!props2.multiple)
        return;
      if (["Backspace", "Delete"].includes(e.key)) {
        if (selectionIndex.value < 0) {
          if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        const originalSelectionIndex = selectionIndex.value;
        const selectedItem = model.value[selectionIndex.value];
        if (selectedItem && !selectedItem.props.disabled)
          select(selectedItem);
        selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
      }
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart > 0)
          return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (model.value[prev]) {
          selectionIndex.value = prev;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(search.value?.length, search.value?.length);
        }
      }
      if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0)
          return;
        const next = selectionIndex.value + 1;
        if (model.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(0, 0);
        }
      }
    }
    function onChange(e) {
      if (matchesSelector(vTextFieldRef.value, ":autofill") || matchesSelector(vTextFieldRef.value, ":-webkit-autofill")) {
        const item = items.value.find((item2) => item2.title === e.target.value);
        if (item) {
          select(item);
        }
      }
    }
    function onAfterLeave() {
      if (isFocused.value) {
        isPristine.value = true;
        vTextFieldRef.value?.focus();
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
      setTimeout(() => {
        listHasFocus.value = true;
      });
    }
    function onFocusout(e) {
      listHasFocus.value = false;
    }
    function onUpdateModelValue(v) {
      if (v == null || v === "" && !props2.multiple)
        model.value = [];
    }
    const isSelecting = shallowRef(false);
    function select(item) {
      let add2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (item.props.disabled)
        return;
      if (props2.multiple) {
        const index2 = model.value.findIndex((selection) => props2.valueComparator(selection.value, item.value));
        if (index2 === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index2, 1);
          model.value = value;
        }
        if (props2.clearOnSelect) {
          search.value = "";
        }
      } else {
        model.value = add2 ? [item] : [];
        isSelecting.value = true;
        search.value = add2 ? item.title : "";
        menu.value = false;
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      }
    }
    watch(isFocused, (val, oldVal) => {
      if (val === oldVal)
        return;
      if (val) {
        isSelecting.value = true;
        search.value = props2.multiple ? "" : String(model.value.at(-1)?.props.title ?? "");
        isPristine.value = true;
        nextTick(() => isSelecting.value = false);
      } else {
        if (!props2.multiple && search.value == null)
          model.value = [];
        else if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
          let {
            value
          } = _ref2;
          return value === displayItems.value[0].value;
        })) {
          select(displayItems.value[0]);
        }
        menu.value = false;
        search.value = "";
        selectionIndex.value = -1;
      }
    });
    watch(search, (val) => {
      if (!isFocused.value || isSelecting.value)
        return;
      if (val)
        menu.value = true;
      isPristine.value = !val;
    });
    watch(menu, () => {
      if (!props2.hideSelected && menu.value && model.value.length) {
        const index2 = displayItems.value.findIndex((item) => model.value.some((s) => item.value === s.value));
        IN_BROWSER && window.requestAnimationFrame(() => {
          index2 >= 0 && vVirtualScrollRef.value?.scrollToIndex(index2);
        });
      }
    });
    watch(displayItems, (val, oldVal) => {
      if (!isFocused.value)
        return;
      if (!val.length && props2.hideNoData) {
        menu.value = false;
      }
      if (!oldVal.length && val.length) {
        menu.value = true;
      }
    });
    useRender(() => {
      const hasChips = !!(props2.chips || slots.chip);
      const hasList = !!(!props2.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const textFieldProps = VTextField.filterProps(props2);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": counterValue.value,
        "dirty": isDirty,
        "onChange": onChange,
        "class": ["v-autocomplete", `v-autocomplete--${props2.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": menu.value,
          "v-autocomplete--chips": !!props2.chips,
          "v-autocomplete--selection-slot": !!slots.selection,
          "v-autocomplete--selecting-index": selectionIndex.value > -1
        }, props2.class],
        "style": props2.style,
        "readonly": props2.readonly,
        "placeholder": isDirty ? void 0 : props2.placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-autocomplete__content",
          "disabled": menuDisabled.value,
          "eager": props2.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props2.transition,
          "onAfterLeave": onAfterLeave
        }, props2.menuProps), {
          default: () => [hasList && createVNode(VList, mergeProps({
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props2.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "aria-live": "polite",
            "color": props2.itemColor ?? props2.color
          }, props2.listProps), {
            default: () => [slots["prepend-item"]?.(), !displayItems.value.length && !props2.hideNoData && (slots["no-data"]?.() ?? createVNode(VListItem, {
              "title": t(props2.noDataText)
            }, null)), createVNode(VVirtualScroll, {
              "ref": vVirtualScrollRef,
              "renderless": true,
              "items": displayItems.value
            }, {
              default: (_ref3) => {
                let {
                  item,
                  index: index2,
                  itemRef
                } = _ref3;
                const itemProps = mergeProps(item.props, {
                  ref: itemRef,
                  key: index2,
                  active: highlightFirst.value && index2 === 0 ? true : void 0,
                  onClick: () => select(item)
                });
                return slots.item?.({
                  item,
                  index: index2,
                  props: itemProps
                }) ?? createVNode(VListItem, itemProps, {
                  prepend: (_ref4) => {
                    let {
                      isSelected
                    } = _ref4;
                    return createVNode(Fragment, null, [props2.multiple && !props2.hideSelected ? createVNode(VCheckboxBtn, {
                      "key": item.value,
                      "modelValue": isSelected,
                      "ripple": false,
                      "tabindex": "-1"
                    }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                      "image": item.props.prependAvatar
                    }, null), item.props.prependIcon && createVNode(VIcon, {
                      "icon": item.props.prependIcon
                    }, null)]);
                  },
                  title: () => {
                    return isPristine.value ? item.title : highlightResult$1(item.title, getMatches(item)?.title, search.value?.length ?? 0);
                  }
                });
              }
            }), slots["append-item"]?.()]
          })]
        }), model.value.map((item, index2) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item, false);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
          const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
            item,
            index: index2,
            props: slotProps
          }) : slots.selection({
            item,
            index: index2
          })) : void 0;
          if (hasSlot && !slotContent)
            return void 0;
          return createVNode("div", {
            "key": item.value,
            "class": ["v-autocomplete__selection", index2 === selectionIndex.value && ["v-autocomplete__selection--selected", textColorClasses.value]],
            "style": index2 === selectionIndex.value ? textColorStyles.value : {}
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props2.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props2.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => [slotContent]
          }) : slotContent ?? createVNode("span", {
            "class": "v-autocomplete__selection-text"
          }, [item.title, props2.multiple && index2 < model.value.length - 1 && createVNode("span", {
            "class": "v-autocomplete__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [slots["append-inner"]?.(...args), props2.menuIcon ? createVNode(VIcon, {
            "class": "v-autocomplete__menu-icon",
            "icon": props2.menuIcon,
            "onMousedown": onMousedownMenuIcon,
            "onClick": noop$1,
            "aria-label": t(label.value),
            "title": t(label.value)
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});
const VBadge$1 = "";
const makeVBadgeProps = propsFactory({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: IconValue,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: true
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...makeComponentProps(),
  ...makeLocationProps({
    location: "top end"
  }),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeTransitionProps({
    transition: "scale-rotate-transition"
  })
}, "VBadge");
const VBadge = genericComponent()({
  name: "VBadge",
  inheritAttrs: false,
  props: makeVBadgeProps(),
  setup(props2, ctx) {
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      t
    } = useLocale();
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props2, "textColor"));
    const {
      themeClasses
    } = useTheme();
    const {
      locationStyles
    } = useLocation(props2, true, (side) => {
      const base = props2.floating ? props2.dot ? 2 : 4 : props2.dot ? 8 : 12;
      return base + (["top", "bottom"].includes(side) ? +(props2.offsetY ?? 0) : ["left", "right"].includes(side) ? +(props2.offsetX ?? 0) : 0);
    });
    useRender(() => {
      const value = Number(props2.content);
      const content = !props2.max || isNaN(value) ? props2.content : value <= +props2.max ? value : `${props2.max}+`;
      const [badgeAttrs, attrs] = pickWithRest(ctx.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return createVNode(props2.tag, mergeProps({
        "class": ["v-badge", {
          "v-badge--bordered": props2.bordered,
          "v-badge--dot": props2.dot,
          "v-badge--floating": props2.floating,
          "v-badge--inline": props2.inline
        }, props2.class]
      }, attrs, {
        "style": props2.style
      }), {
        default: () => [createVNode("div", {
          "class": "v-badge__wrapper"
        }, [ctx.slots.default?.(), createVNode(MaybeTransition, {
          "transition": props2.transition
        }, {
          default: () => [withDirectives(createVNode("span", mergeProps({
            "class": ["v-badge__badge", themeClasses.value, backgroundColorClasses.value, roundedClasses.value, textColorClasses.value],
            "style": [backgroundColorStyles.value, textColorStyles.value, props2.inline ? {} : locationStyles.value],
            "aria-atomic": "true",
            "aria-label": t(props2.label, value),
            "aria-live": "polite",
            "role": "status"
          }, badgeAttrs), [props2.dot ? void 0 : ctx.slots.badge ? ctx.slots.badge?.() : props2.icon ? createVNode(VIcon, {
            "icon": props2.icon
          }, null) : content]), [[vShow, props2.modelValue]])]
        })])]
      });
    });
    return {};
  }
});
const VBanner$1 = "";
const makeVBannerActionsProps = propsFactory({
  color: String,
  density: String,
  ...makeComponentProps()
}, "VBannerActions");
const VBannerActions = genericComponent()({
  name: "VBannerActions",
  props: makeVBannerActionsProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        color: props2.color,
        density: props2.density,
        slim: true,
        variant: "text"
      }
    });
    useRender(() => createVNode("div", {
      "class": ["v-banner-actions", props2.class],
      "style": props2.style
    }, [slots.default?.()]));
    return {};
  }
});
const VBannerText = createSimpleFunctional("v-banner-text");
const makeVBannerProps = propsFactory({
  avatar: String,
  bgColor: String,
  color: String,
  icon: IconValue,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeDisplayProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VBanner");
const VBanner = genericComponent()({
  name: "VBanner",
  props: makeVBannerProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props2, "bgColor");
    const {
      borderClasses
    } = useBorder(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      displayClasses,
      mobile
    } = useDisplay(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const color = toRef(props2, "color");
    const density = toRef(props2, "density");
    provideDefaults({
      VBannerActions: {
        color,
        density
      }
    });
    useRender(() => {
      const hasText = !!(props2.text || slots.text);
      const hasPrependMedia = !!(props2.avatar || props2.icon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      return createVNode(props2.tag, {
        "class": ["v-banner", {
          "v-banner--stacked": props2.stacked || mobile.value,
          "v-banner--sticky": props2.sticky,
          [`v-banner--${props2.lines}-line`]: !!props2.lines
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, displayClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props2.style],
        "role": "banner"
      }, {
        default: () => [hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-banner__prepend"
        }, [!slots.prepend ? createVNode(VAvatar, {
          "key": "prepend-avatar",
          "color": color.value,
          "density": density.value,
          "icon": props2.icon,
          "image": props2.avatar
        }, null) : createVNode(VDefaultsProvider, {
          "key": "prepend-defaults",
          "disabled": !hasPrependMedia,
          "defaults": {
            VAvatar: {
              color: color.value,
              density: density.value,
              icon: props2.icon,
              image: props2.avatar
            }
          }
        }, slots.prepend)]), createVNode("div", {
          "class": "v-banner__content"
        }, [hasText && createVNode(VBannerText, {
          "key": "text"
        }, {
          default: () => [slots.text?.() ?? props2.text]
        }), slots.default?.()]), slots.actions && createVNode(VBannerActions, {
          "key": "actions"
        }, slots.actions)]
      });
    });
  }
});
const VDialog$1 = "";
const makeVDialogProps = propsFactory({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: true
  },
  scrollable: Boolean,
  ...makeVOverlayProps({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: VDialogTransition
    },
    zIndex: 2400
  })
}, "VDialog");
const VDialog = genericComponent()({
  name: "VDialog",
  props: makeVDialogProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const overlay = ref();
    function onFocusin(e) {
      const before = e.relatedTarget;
      const after = e.target;
      if (before !== after && overlay.value?.contentEl && // We're the topmost dialog
      overlay.value?.globalTop && // It isn't the document or the dialog body
      ![document, overlay.value.contentEl].includes(after) && // It isn't inside the dialog body
      !overlay.value.contentEl.contains(after)) {
        const focusable = focusableChildren(overlay.value.contentEl);
        if (!focusable.length)
          return;
        const firstElement = focusable[0];
        const lastElement = focusable[focusable.length - 1];
        if (before === firstElement) {
          lastElement.focus();
        } else {
          firstElement.focus();
        }
      }
    }
    if (IN_BROWSER) {
      watch(() => isActive.value && props2.retainFocus, (val) => {
        val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
      }, {
        immediate: true
      });
    }
    watch(isActive, async (val) => {
      await nextTick();
      if (val) {
        overlay.value.contentEl?.focus({
          preventScroll: true
        });
      } else {
        overlay.value.activatorEl?.focus({
          preventScroll: true
        });
      }
    });
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "dialog",
      "aria-expanded": String(isActive.value)
    }, props2.activatorProps));
    useRender(() => {
      const overlayProps = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props2.fullscreen,
          "v-dialog--scrollable": props2.scrollable
        }, props2.class],
        "style": props2.style
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "aria-modal": "true",
        "activatorProps": activatorProps.value,
        "role": "dialog"
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": "VDialog"
          }, {
            default: () => [slots.default?.(...args)]
          });
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const VCard$1 = "";
const VCardActions = genericComponent()({
  name: "VCardActions",
  props: makeComponentProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        slim: true,
        variant: "text"
      }
    });
    useRender(() => createVNode("div", {
      "class": ["v-card-actions", props2.class],
      "style": props2.style
    }, [slots.default?.()]));
    return {};
  }
});
const VCardSubtitle = createSimpleFunctional("v-card-subtitle");
const VCardTitle = createSimpleFunctional("v-card-title");
const makeCardItemProps = propsFactory({
  appendAvatar: String,
  appendIcon: IconValue,
  prependAvatar: String,
  prependIcon: IconValue,
  subtitle: [String, Number],
  title: [String, Number],
  ...makeComponentProps(),
  ...makeDensityProps()
}, "VCardItem");
const VCardItem = genericComponent()({
  name: "VCardItem",
  props: makeCardItemProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      const hasPrependMedia = !!(props2.prependAvatar || props2.prependIcon);
      const hasPrepend = !!(hasPrependMedia || slots.prepend);
      const hasAppendMedia = !!(props2.appendAvatar || props2.appendIcon);
      const hasAppend = !!(hasAppendMedia || slots.append);
      const hasTitle = !!(props2.title != null || slots.title);
      const hasSubtitle = !!(props2.subtitle != null || slots.subtitle);
      return createVNode("div", {
        "class": ["v-card-item", props2.class],
        "style": props2.style
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-card-item__prepend"
      }, [!slots.prepend ? createVNode(Fragment, null, [props2.prependAvatar && createVNode(VAvatar, {
        "key": "prepend-avatar",
        "density": props2.density,
        "image": props2.prependAvatar
      }, null), props2.prependIcon && createVNode(VIcon, {
        "key": "prepend-icon",
        "density": props2.density,
        "icon": props2.prependIcon
      }, null)]) : createVNode(VDefaultsProvider, {
        "key": "prepend-defaults",
        "disabled": !hasPrependMedia,
        "defaults": {
          VAvatar: {
            density: props2.density,
            image: props2.prependAvatar
          },
          VIcon: {
            density: props2.density,
            icon: props2.prependIcon
          }
        }
      }, slots.prepend)]), createVNode("div", {
        "class": "v-card-item__content"
      }, [hasTitle && createVNode(VCardTitle, {
        "key": "title"
      }, {
        default: () => [slots.title?.() ?? props2.title]
      }), hasSubtitle && createVNode(VCardSubtitle, {
        "key": "subtitle"
      }, {
        default: () => [slots.subtitle?.() ?? props2.subtitle]
      }), slots.default?.()]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-card-item__append"
      }, [!slots.append ? createVNode(Fragment, null, [props2.appendIcon && createVNode(VIcon, {
        "key": "append-icon",
        "density": props2.density,
        "icon": props2.appendIcon
      }, null), props2.appendAvatar && createVNode(VAvatar, {
        "key": "append-avatar",
        "density": props2.density,
        "image": props2.appendAvatar
      }, null)]) : createVNode(VDefaultsProvider, {
        "key": "append-defaults",
        "disabled": !hasAppendMedia,
        "defaults": {
          VAvatar: {
            density: props2.density,
            image: props2.appendAvatar
          },
          VIcon: {
            density: props2.density,
            icon: props2.appendIcon
          }
        }
      }, slots.append)])]);
    });
    return {};
  }
});
const VCardText = createSimpleFunctional("v-card-text");
const makeVCardProps = propsFactory({
  appendAvatar: String,
  appendIcon: IconValue,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: IconValue,
  ripple: {
    type: [Boolean, Object],
    default: true
  },
  subtitle: [String, Number],
  text: [String, Number],
  title: [String, Number],
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLoaderProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeRouterProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "elevated"
  })
}, "VCard");
const VCard = genericComponent()({
  name: "VCard",
  directives: {
    Ripple
  },
  props: makeVCardProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props2);
    const {
      densityClasses
    } = useDensity(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const link = useLink$1(props2, attrs);
    const isLink = computed(() => props2.link !== false && link.isLink.value);
    const isClickable = computed(() => !props2.disabled && props2.link !== false && (props2.link || link.isClickable.value));
    useRender(() => {
      const Tag = isLink.value ? "a" : props2.tag;
      const hasTitle = !!(slots.title || props2.title != null);
      const hasSubtitle = !!(slots.subtitle || props2.subtitle != null);
      const hasHeader = hasTitle || hasSubtitle;
      const hasAppend = !!(slots.append || props2.appendAvatar || props2.appendIcon);
      const hasPrepend = !!(slots.prepend || props2.prependAvatar || props2.prependIcon);
      const hasImage = !!(slots.image || props2.image);
      const hasCardItem = hasHeader || hasPrepend || hasAppend;
      const hasText = !!(slots.text || props2.text != null);
      return withDirectives(createVNode(Tag, {
        "class": ["v-card", {
          "v-card--disabled": props2.disabled,
          "v-card--flat": props2.flat,
          "v-card--hover": props2.hover && !(props2.disabled || props2.flat),
          "v-card--link": isClickable.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value, props2.class],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value, props2.style],
        "href": link.href.value,
        "onClick": isClickable.value && link.navigate,
        "tabindex": props2.disabled ? -1 : void 0
      }, {
        default: () => [hasImage && createVNode("div", {
          "key": "image",
          "class": "v-card__image"
        }, [!slots.image ? createVNode(VImg, {
          "key": "image-img",
          "cover": true,
          "src": props2.image
        }, null) : createVNode(VDefaultsProvider, {
          "key": "image-defaults",
          "disabled": !props2.image,
          "defaults": {
            VImg: {
              cover: true,
              src: props2.image
            }
          }
        }, slots.image)]), createVNode(LoaderSlot, {
          "name": "v-card",
          "active": !!props2.loading,
          "color": typeof props2.loading === "boolean" ? void 0 : props2.loading
        }, {
          default: slots.loader
        }), hasCardItem && createVNode(VCardItem, {
          "key": "item",
          "prependAvatar": props2.prependAvatar,
          "prependIcon": props2.prependIcon,
          "title": props2.title,
          "subtitle": props2.subtitle,
          "appendAvatar": props2.appendAvatar,
          "appendIcon": props2.appendIcon
        }, {
          default: slots.item,
          prepend: slots.prepend,
          title: slots.title,
          subtitle: slots.subtitle,
          append: slots.append
        }), hasText && createVNode(VCardText, {
          "key": "text"
        }, {
          default: () => [slots.text?.() ?? props2.text]
        }), slots.default?.(), slots.actions && createVNode(VCardActions, null, {
          default: slots.actions
        }), genOverlays(isClickable.value, "v-card")]
      }), [[resolveDirective("ripple"), isClickable.value && props2.ripple]]);
    });
    return {};
  }
});
const VSheet$1 = "";
const makeVSheetProps = propsFactory({
  color: String,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeLocationProps(),
  ...makePositionProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VSheet");
const VSheet = genericComponent()({
  name: "VSheet",
  props: makeVSheetProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      borderClasses
    } = useBorder(props2);
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      locationStyles
    } = useLocation(props2);
    const {
      positionClasses
    } = usePosition(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    useRender(() => createVNode(props2.tag, {
      "class": ["v-sheet", themeClasses.value, backgroundColorClasses.value, borderClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, props2.class],
      "style": [backgroundColorStyles.value, dimensionStyles.value, locationStyles.value, props2.style]
    }, slots));
    return {};
  }
});
const VCombobox$1 = "";
function highlightResult(text, matches2, length) {
  if (matches2 == null)
    return text;
  if (Array.isArray(matches2))
    throw new Error("Multiple matches is not implemented");
  return typeof matches2 === "number" && ~matches2 ? createVNode(Fragment, null, [createVNode("span", {
    "class": "v-combobox__unmask"
  }, [text.substr(0, matches2)]), createVNode("span", {
    "class": "v-combobox__mask"
  }, [text.substr(matches2, length)]), createVNode("span", {
    "class": "v-combobox__unmask"
  }, [text.substr(matches2 + length)])]) : text;
}
const makeVComboboxProps = propsFactory({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: true
  },
  delimiters: Array,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeSelectProps({
    hideNoData: true,
    returnObject: true
  }),
  ...omit(makeVTextFieldProps({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...makeTransitionProps({
    transition: false
  })
}, "VCombobox");
const VCombobox = genericComponent()({
  name: "VCombobox",
  props: makeVComboboxProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (value) => true,
    "update:search": (value) => true,
    "update:menu": (value) => true
  },
  setup(props2, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const isFocused = shallowRef(false);
    const isPristine = shallowRef(true);
    const listHasFocus = shallowRef(false);
    const vMenuRef = ref();
    const vVirtualScrollRef = ref();
    const _menu = useProxiedModel(props2, "menu");
    const menu = computed({
      get: () => _menu.value,
      set: (v) => {
        if (_menu.value && !v && vMenuRef.value?.ΨopenChildren)
          return;
        _menu.value = v;
      }
    });
    const selectionIndex = shallowRef(-1);
    let cleared = false;
    const color = computed(() => vTextFieldRef.value?.color);
    const label = computed(() => menu.value ? props2.closeText : props2.openText);
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props2);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(color);
    const model = useProxiedModel(props2, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      const transformed = transformOut(v);
      return props2.multiple ? transformed : transformed[0] ?? null;
    });
    const form = useForm();
    const _search = shallowRef(!props2.multiple ? model.value[0]?.title ?? "" : "");
    const search = computed({
      get: () => {
        return _search.value;
      },
      set: (val) => {
        _search.value = val ?? "";
        if (!props2.multiple) {
          model.value = [transformItem$2(props2, val)];
        }
        if (val && props2.multiple && props2.delimiters?.length) {
          const values = val.split(new RegExp(`(?:${props2.delimiters.join("|")})+`));
          if (values.length > 1) {
            values.forEach((v) => {
              v = v.trim();
              if (v)
                select(transformItem$2(props2, v));
            });
            _search.value = "";
          }
        }
        if (!val)
          selectionIndex.value = -1;
        isPristine.value = !val;
      }
    });
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : typeof props2.counterValue === "number" ? props2.counterValue : props2.multiple ? model.value.length : search.value.length;
    });
    watch(_search, (value) => {
      if (cleared) {
        nextTick(() => cleared = false);
      } else if (isFocused.value && !menu.value) {
        menu.value = true;
      }
      emit2("update:search", value);
    });
    watch(model, (value) => {
      if (!props2.multiple) {
        _search.value = value[0]?.title ?? "";
      }
    });
    const {
      filteredItems,
      getMatches
    } = useFilter(props2, items, () => isPristine.value ? "" : search.value);
    const displayItems = computed(() => {
      if (props2.hideSelected) {
        return filteredItems.value.filter((filteredItem) => !model.value.some((s) => s.value === filteredItem.value));
      }
      return filteredItems.value;
    });
    const selectedValues = computed(() => model.value.map((selection) => selection.value));
    const highlightFirst = computed(() => {
      const selectFirst = props2.autoSelectFirst === true || props2.autoSelectFirst === "exact" && search.value === displayItems.value[0]?.title;
      return selectFirst && displayItems.value.length > 0 && !isPristine.value && !listHasFocus.value;
    });
    const menuDisabled = computed(() => props2.hideNoData && !displayItems.value.length || props2.readonly || form?.isReadonly.value);
    const listRef = ref();
    const {
      onListScroll,
      onListKeydown
    } = useScrolling(listRef, vTextFieldRef);
    function onClear(e) {
      cleared = true;
      if (props2.openOnClear) {
        menu.value = true;
      }
    }
    function onMousedownControl() {
      if (menuDisabled.value)
        return;
      menu.value = true;
    }
    function onMousedownMenuIcon(e) {
      if (menuDisabled.value)
        return;
      if (isFocused.value) {
        e.preventDefault();
        e.stopPropagation();
      }
      menu.value = !menu.value;
    }
    function onKeydown(e) {
      if (isComposingIgnoreKey(e) || props2.readonly || form?.isReadonly.value)
        return;
      const selectionStart = vTextFieldRef.value.selectionStart;
      const length = model.value.length;
      if (selectionIndex.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(e.key)) {
        e.preventDefault();
      }
      if (["Enter", "ArrowDown"].includes(e.key)) {
        menu.value = true;
      }
      if (["Escape"].includes(e.key)) {
        menu.value = false;
      }
      if (["Enter", "Escape", "Tab"].includes(e.key)) {
        if (highlightFirst.value && ["Enter", "Tab"].includes(e.key)) {
          select(filteredItems.value[0]);
        }
        isPristine.value = true;
      }
      if (e.key === "ArrowDown" && highlightFirst.value) {
        listRef.value?.focus("next");
      }
      if (!props2.multiple)
        return;
      if (["Backspace", "Delete"].includes(e.key)) {
        if (selectionIndex.value < 0) {
          if (e.key === "Backspace" && !search.value) {
            selectionIndex.value = length - 1;
          }
          return;
        }
        const originalSelectionIndex = selectionIndex.value;
        const selectedItem = model.value[selectionIndex.value];
        if (selectedItem && !selectedItem.props.disabled)
          select(selectedItem, false);
        selectionIndex.value = originalSelectionIndex >= length - 1 ? length - 2 : originalSelectionIndex;
      }
      if (e.key === "ArrowLeft") {
        if (selectionIndex.value < 0 && selectionStart > 0)
          return;
        const prev = selectionIndex.value > -1 ? selectionIndex.value - 1 : length - 1;
        if (model.value[prev]) {
          selectionIndex.value = prev;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(search.value.length, search.value.length);
        }
      }
      if (e.key === "ArrowRight") {
        if (selectionIndex.value < 0)
          return;
        const next = selectionIndex.value + 1;
        if (model.value[next]) {
          selectionIndex.value = next;
        } else {
          selectionIndex.value = -1;
          vTextFieldRef.value.setSelectionRange(0, 0);
        }
      }
      if (e.key === "Enter" && search.value) {
        select(transformItem$2(props2, search.value));
        search.value = "";
      }
    }
    function onAfterLeave() {
      if (isFocused.value) {
        isPristine.value = true;
        vTextFieldRef.value?.focus();
      }
    }
    function select(item) {
      let set2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (props2.multiple) {
        const index2 = model.value.findIndex((selection) => props2.valueComparator(selection.value, item.value));
        const add2 = set2 == null ? !~index2 : set2;
        if (~index2) {
          const value = add2 ? [...model.value, item] : [...model.value];
          value.splice(index2, 1);
          model.value = value;
        } else if (add2) {
          model.value = [...model.value, item];
        }
        if (props2.clearOnSelect) {
          search.value = "";
        }
      } else {
        const add2 = set2 !== false;
        model.value = add2 ? [item] : [];
        _search.value = add2 ? item.title : "";
        nextTick(() => {
          menu.value = false;
          isPristine.value = true;
        });
      }
    }
    function onFocusin(e) {
      isFocused.value = true;
      setTimeout(() => {
        listHasFocus.value = true;
      });
    }
    function onFocusout(e) {
      listHasFocus.value = false;
    }
    function onUpdateModelValue(v) {
      if (v == null || v === "" && !props2.multiple)
        model.value = [];
    }
    watch(isFocused, (val, oldVal) => {
      if (val || val === oldVal)
        return;
      selectionIndex.value = -1;
      menu.value = false;
      if (highlightFirst.value && !listHasFocus.value && !model.value.some((_ref2) => {
        let {
          value
        } = _ref2;
        return value === displayItems.value[0].value;
      })) {
        select(displayItems.value[0]);
      } else if (props2.multiple && search.value) {
        select(transformItem$2(props2, search.value));
      }
    });
    watch(menu, () => {
      if (!props2.hideSelected && menu.value && model.value.length) {
        const index2 = displayItems.value.findIndex((item) => model.value.some((s) => props2.valueComparator(s.value, item.value)));
        IN_BROWSER && window.requestAnimationFrame(() => {
          index2 >= 0 && vVirtualScrollRef.value?.scrollToIndex(index2);
        });
      }
    });
    watch(displayItems, (val, oldVal) => {
      if (!isFocused.value)
        return;
      if (!val.length && props2.hideNoData) {
        menu.value = false;
      }
      if (!oldVal.length && val.length) {
        menu.value = true;
      }
    });
    useRender(() => {
      const hasChips = !!(props2.chips || slots.chip);
      const hasList = !!(!props2.hideNoData || displayItems.value.length || slots["prepend-item"] || slots["append-item"] || slots["no-data"]);
      const isDirty = model.value.length > 0;
      const textFieldProps = VTextField.filterProps(props2);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": search.value,
        "onUpdate:modelValue": [($event) => search.value = $event, onUpdateModelValue],
        "focused": isFocused.value,
        "onUpdate:focused": ($event) => isFocused.value = $event,
        "validationValue": model.externalValue,
        "counterValue": counterValue.value,
        "dirty": isDirty,
        "class": ["v-combobox", {
          "v-combobox--active-menu": menu.value,
          "v-combobox--chips": !!props2.chips,
          "v-combobox--selection-slot": !!slots.selection,
          "v-combobox--selecting-index": selectionIndex.value > -1,
          [`v-combobox--${props2.multiple ? "multiple" : "single"}`]: true
        }, props2.class],
        "style": props2.style,
        "readonly": props2.readonly,
        "placeholder": isDirty ? void 0 : props2.placeholder,
        "onClick:clear": onClear,
        "onMousedown:control": onMousedownControl,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
          "ref": vMenuRef,
          "modelValue": menu.value,
          "onUpdate:modelValue": ($event) => menu.value = $event,
          "activator": "parent",
          "contentClass": "v-combobox__content",
          "disabled": menuDisabled.value,
          "eager": props2.eager,
          "maxHeight": 310,
          "openOnClick": false,
          "closeOnContentClick": false,
          "transition": props2.transition,
          "onAfterLeave": onAfterLeave
        }, props2.menuProps), {
          default: () => [hasList && createVNode(VList, mergeProps({
            "ref": listRef,
            "selected": selectedValues.value,
            "selectStrategy": props2.multiple ? "independent" : "single-independent",
            "onMousedown": (e) => e.preventDefault(),
            "onKeydown": onListKeydown,
            "onFocusin": onFocusin,
            "onFocusout": onFocusout,
            "onScrollPassive": onListScroll,
            "tabindex": "-1",
            "aria-live": "polite",
            "color": props2.itemColor ?? props2.color
          }, props2.listProps), {
            default: () => [slots["prepend-item"]?.(), !displayItems.value.length && !props2.hideNoData && (slots["no-data"]?.() ?? createVNode(VListItem, {
              "title": t(props2.noDataText)
            }, null)), createVNode(VVirtualScroll, {
              "ref": vVirtualScrollRef,
              "renderless": true,
              "items": displayItems.value
            }, {
              default: (_ref3) => {
                let {
                  item,
                  index: index2,
                  itemRef
                } = _ref3;
                const itemProps = mergeProps(item.props, {
                  ref: itemRef,
                  key: index2,
                  active: highlightFirst.value && index2 === 0 ? true : void 0,
                  onClick: () => select(item, null)
                });
                return slots.item?.({
                  item,
                  index: index2,
                  props: itemProps
                }) ?? createVNode(VListItem, itemProps, {
                  prepend: (_ref4) => {
                    let {
                      isSelected
                    } = _ref4;
                    return createVNode(Fragment, null, [props2.multiple && !props2.hideSelected ? createVNode(VCheckboxBtn, {
                      "key": item.value,
                      "modelValue": isSelected,
                      "ripple": false,
                      "tabindex": "-1"
                    }, null) : void 0, item.props.prependAvatar && createVNode(VAvatar, {
                      "image": item.props.prependAvatar
                    }, null), item.props.prependIcon && createVNode(VIcon, {
                      "icon": item.props.prependIcon
                    }, null)]);
                  },
                  title: () => {
                    return isPristine.value ? item.title : highlightResult(item.title, getMatches(item)?.title, search.value?.length ?? 0);
                  }
                });
              }
            }), slots["append-item"]?.()]
          })]
        }), model.value.map((item, index2) => {
          function onChipClose(e) {
            e.stopPropagation();
            e.preventDefault();
            select(item, false);
          }
          const slotProps = {
            "onClick:close": onChipClose,
            onMousedown(e) {
              e.preventDefault();
              e.stopPropagation();
            },
            modelValue: true,
            "onUpdate:modelValue": void 0
          };
          const hasSlot = hasChips ? !!slots.chip : !!slots.selection;
          const slotContent = hasSlot ? ensureValidVNode(hasChips ? slots.chip({
            item,
            index: index2,
            props: slotProps
          }) : slots.selection({
            item,
            index: index2
          })) : void 0;
          if (hasSlot && !slotContent)
            return void 0;
          return createVNode("div", {
            "key": item.value,
            "class": ["v-combobox__selection", index2 === selectionIndex.value && ["v-combobox__selection--selected", textColorClasses.value]],
            "style": index2 === selectionIndex.value ? textColorStyles.value : {}
          }, [hasChips ? !slots.chip ? createVNode(VChip, mergeProps({
            "key": "chip",
            "closable": props2.closableChips,
            "size": "small",
            "text": item.title,
            "disabled": item.props.disabled
          }, slotProps), null) : createVNode(VDefaultsProvider, {
            "key": "chip-defaults",
            "defaults": {
              VChip: {
                closable: props2.closableChips,
                size: "small",
                text: item.title
              }
            }
          }, {
            default: () => [slotContent]
          }) : slotContent ?? createVNode("span", {
            "class": "v-combobox__selection-text"
          }, [item.title, props2.multiple && index2 < model.value.length - 1 && createVNode("span", {
            "class": "v-combobox__selection-comma"
          }, [createTextVNode(",")])])]);
        })]),
        "append-inner": function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(Fragment, null, [slots["append-inner"]?.(...args), (!props2.hideNoData || props2.items.length) && props2.menuIcon ? createVNode(VIcon, {
            "class": "v-combobox__menu-icon",
            "icon": props2.menuIcon,
            "onMousedown": onMousedownMenuIcon,
            "onClick": noop$1,
            "aria-label": t(label.value),
            "title": t(label.value)
          }, null) : void 0]);
        }
      });
    });
    return forwardRefs({
      isFocused,
      isPristine,
      menu,
      search,
      selectionIndex,
      filteredItems,
      select
    }, vTextFieldRef);
  }
});
const makeDataTableExpandProps = propsFactory({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "DataTable-expand");
const VDataTableExpandedKey = Symbol.for("vuetify:datatable:expanded");
function provideExpanded(props2) {
  const expandOnClick = toRef(props2, "expandOnClick");
  const expanded = useProxiedModel(props2, "expanded", props2.expanded, (v) => {
    return new Set(v);
  }, (v) => {
    return [...v.values()];
  });
  function expand(item, value) {
    const newExpanded = new Set(expanded.value);
    if (!value) {
      newExpanded.delete(item.value);
    } else {
      newExpanded.add(item.value);
    }
    expanded.value = newExpanded;
  }
  function isExpanded(item) {
    return expanded.value.has(item.value);
  }
  function toggleExpand(item) {
    expand(item, !isExpanded(item));
  }
  const data = {
    expand,
    expanded,
    expandOnClick,
    isExpanded,
    toggleExpand
  };
  provide(VDataTableExpandedKey, data);
  return data;
}
function useExpanded() {
  const data = inject$1(VDataTableExpandedKey);
  if (!data)
    throw new Error("foo");
  return data;
}
const makeDataTableGroupProps = propsFactory({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "DataTable-group");
const VDataTableGroupSymbol = Symbol.for("vuetify:data-table-group");
function createGroupBy(props2) {
  const groupBy = useProxiedModel(props2, "groupBy");
  return {
    groupBy
  };
}
function provideGroupBy(options) {
  const {
    groupBy,
    sortBy
  } = options;
  const opened = ref(/* @__PURE__ */ new Set());
  const sortByWithGroups = computed(() => {
    return groupBy.value.map((val) => ({
      ...val,
      order: val.order ?? false
    })).concat(sortBy.value);
  });
  function isGroupOpen(group) {
    return opened.value.has(group.id);
  }
  function toggleGroup(group) {
    const newOpened = new Set(opened.value);
    if (!isGroupOpen(group))
      newOpened.add(group.id);
    else
      newOpened.delete(group.id);
    opened.value = newOpened;
  }
  function extractRows(items) {
    function dive(group) {
      const arr = [];
      for (const item of group.items) {
        if ("type" in item && item.type === "group") {
          arr.push(...dive(item));
        } else {
          arr.push(item);
        }
      }
      return arr;
    }
    return dive({
      type: "group",
      items,
      id: "dummy",
      key: "dummy",
      value: "dummy",
      depth: 0
    });
  }
  const data = {
    sortByWithGroups,
    toggleGroup,
    opened,
    groupBy,
    extractRows,
    isGroupOpen
  };
  provide(VDataTableGroupSymbol, data);
  return data;
}
function useGroupBy() {
  const data = inject$1(VDataTableGroupSymbol);
  if (!data)
    throw new Error("Missing group!");
  return data;
}
function groupItemsByProperty(items, groupBy) {
  if (!items.length)
    return [];
  const groups = /* @__PURE__ */ new Map();
  for (const item of items) {
    const value = getObjectValueByPath(item.raw, groupBy);
    if (!groups.has(value)) {
      groups.set(value, []);
    }
    groups.get(value).push(item);
  }
  return groups;
}
function groupItems(items, groupBy) {
  let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  let prefix = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!groupBy.length)
    return [];
  const groupedItems = groupItemsByProperty(items, groupBy[0]);
  const groups = [];
  const rest = groupBy.slice(1);
  groupedItems.forEach((items2, value) => {
    const key = groupBy[0];
    const id = `${prefix}_${key}_${value}`;
    groups.push({
      depth,
      id,
      key,
      value,
      items: rest.length ? groupItems(items2, rest, depth + 1, id) : items2,
      type: "group"
    });
  });
  return groups;
}
function flattenItems(items, opened) {
  const flatItems = [];
  for (const item of items) {
    if ("type" in item && item.type === "group") {
      if (item.value != null) {
        flatItems.push(item);
      }
      if (opened.has(item.id) || item.value == null) {
        flatItems.push(...flattenItems(item.items, opened));
      }
    } else {
      flatItems.push(item);
    }
  }
  return flatItems;
}
function useGroupedItems(items, groupBy, opened) {
  const flatItems = computed(() => {
    if (!groupBy.value.length)
      return items.value;
    const groupedItems = groupItems(items.value, groupBy.value.map((item) => item.key));
    return flattenItems(groupedItems, opened.value);
  });
  return {
    flatItems
  };
}
function useOptions(_ref) {
  let {
    page,
    itemsPerPage,
    sortBy,
    groupBy,
    search
  } = _ref;
  const vm = getCurrentInstance("VDataTable");
  const options = computed(() => ({
    page: page.value,
    itemsPerPage: itemsPerPage.value,
    sortBy: sortBy.value,
    groupBy: groupBy.value,
    search: search.value
  }));
  let oldOptions = null;
  watch(options, () => {
    if (deepEqual$1(oldOptions, options.value))
      return;
    if (oldOptions?.search !== options.value.search) {
      page.value = 1;
    }
    vm.emit("update:options", options.value);
    oldOptions = options.value;
  }, {
    deep: true,
    immediate: true
  });
}
const makeDataTablePaginateProps = propsFactory({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "DataTable-paginate");
const VDataTablePaginationSymbol = Symbol.for("vuetify:data-table-pagination");
function createPagination(props2) {
  const page = useProxiedModel(props2, "page", void 0, (value) => +(value ?? 1));
  const itemsPerPage = useProxiedModel(props2, "itemsPerPage", void 0, (value) => +(value ?? 10));
  return {
    page,
    itemsPerPage
  };
}
function providePagination(options) {
  const {
    page,
    itemsPerPage,
    itemsLength
  } = options;
  const startIndex = computed(() => {
    if (itemsPerPage.value === -1)
      return 0;
    return itemsPerPage.value * (page.value - 1);
  });
  const stopIndex = computed(() => {
    if (itemsPerPage.value === -1)
      return itemsLength.value;
    return Math.min(itemsLength.value, startIndex.value + itemsPerPage.value);
  });
  const pageCount = computed(() => {
    if (itemsPerPage.value === -1 || itemsLength.value === 0)
      return 1;
    return Math.ceil(itemsLength.value / itemsPerPage.value);
  });
  watchEffect(() => {
    if (page.value > pageCount.value) {
      page.value = pageCount.value;
    }
  });
  function setItemsPerPage(value) {
    itemsPerPage.value = value;
    page.value = 1;
  }
  function nextPage() {
    page.value = clamp(page.value + 1, 1, pageCount.value);
  }
  function prevPage() {
    page.value = clamp(page.value - 1, 1, pageCount.value);
  }
  function setPage(value) {
    page.value = clamp(value, 1, pageCount.value);
  }
  const data = {
    page,
    itemsPerPage,
    startIndex,
    stopIndex,
    pageCount,
    itemsLength,
    nextPage,
    prevPage,
    setPage,
    setItemsPerPage
  };
  provide(VDataTablePaginationSymbol, data);
  return data;
}
function usePagination() {
  const data = inject$1(VDataTablePaginationSymbol);
  if (!data)
    throw new Error("Missing pagination!");
  return data;
}
function usePaginatedItems(options) {
  const vm = getCurrentInstance("usePaginatedItems");
  const {
    items,
    startIndex,
    stopIndex,
    itemsPerPage
  } = options;
  const paginatedItems = computed(() => {
    if (itemsPerPage.value <= 0)
      return items.value;
    return items.value.slice(startIndex.value, stopIndex.value);
  });
  watch(paginatedItems, (val) => {
    vm.emit("update:currentItems", val);
  });
  return {
    paginatedItems
  };
}
const singleSelectStrategy = {
  showSelectAll: false,
  allSelected: () => [],
  select: (_ref) => {
    let {
      items,
      value
    } = _ref;
    return new Set(value ? [items[0]?.value] : []);
  },
  selectAll: (_ref2) => {
    let {
      selected
    } = _ref2;
    return selected;
  }
};
const pageSelectStrategy = {
  showSelectAll: true,
  allSelected: (_ref3) => {
    let {
      currentPage
    } = _ref3;
    return currentPage;
  },
  select: (_ref4) => {
    let {
      items,
      value,
      selected
    } = _ref4;
    for (const item of items) {
      if (value)
        selected.add(item.value);
      else
        selected.delete(item.value);
    }
    return selected;
  },
  selectAll: (_ref5) => {
    let {
      value,
      currentPage,
      selected
    } = _ref5;
    return pageSelectStrategy.select({
      items: currentPage,
      value,
      selected
    });
  }
};
const allSelectStrategy = {
  showSelectAll: true,
  allSelected: (_ref6) => {
    let {
      allItems
    } = _ref6;
    return allItems;
  },
  select: (_ref7) => {
    let {
      items,
      value,
      selected
    } = _ref7;
    for (const item of items) {
      if (value)
        selected.add(item.value);
      else
        selected.delete(item.value);
    }
    return selected;
  },
  selectAll: (_ref8) => {
    let {
      value,
      allItems,
      selected
    } = _ref8;
    return allSelectStrategy.select({
      items: allItems,
      value,
      selected
    });
  }
};
const makeDataTableSelectProps = propsFactory({
  showSelect: Boolean,
  selectStrategy: {
    type: [String, Object],
    default: "page"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  valueComparator: {
    type: Function,
    default: deepEqual$1
  }
}, "DataTable-select");
const VDataTableSelectionSymbol = Symbol.for("vuetify:data-table-selection");
function provideSelection(props2, _ref9) {
  let {
    allItems,
    currentPage
  } = _ref9;
  const selected = useProxiedModel(props2, "modelValue", props2.modelValue, (v) => {
    return new Set(wrapInArray(v).map((v2) => {
      return allItems.value.find((item) => props2.valueComparator(v2, item.value))?.value ?? v2;
    }));
  }, (v) => {
    return [...v.values()];
  });
  const allSelectable = computed(() => allItems.value.filter((item) => item.selectable));
  const currentPageSelectable = computed(() => currentPage.value.filter((item) => item.selectable));
  const selectStrategy = computed(() => {
    if (typeof props2.selectStrategy === "object")
      return props2.selectStrategy;
    switch (props2.selectStrategy) {
      case "single":
        return singleSelectStrategy;
      case "all":
        return allSelectStrategy;
      case "page":
      default:
        return pageSelectStrategy;
    }
  });
  function isSelected(items) {
    return wrapInArray(items).every((item) => selected.value.has(item.value));
  }
  function isSomeSelected(items) {
    return wrapInArray(items).some((item) => selected.value.has(item.value));
  }
  function select(items, value) {
    const newSelected = selectStrategy.value.select({
      items,
      value,
      selected: new Set(selected.value)
    });
    selected.value = newSelected;
  }
  function toggleSelect(item) {
    select([item], !isSelected([item]));
  }
  function selectAll(value) {
    const newSelected = selectStrategy.value.selectAll({
      value,
      allItems: allSelectable.value,
      currentPage: currentPageSelectable.value,
      selected: new Set(selected.value)
    });
    selected.value = newSelected;
  }
  const someSelected = computed(() => selected.value.size > 0);
  const allSelected = computed(() => {
    const items = selectStrategy.value.allSelected({
      allItems: allSelectable.value,
      currentPage: currentPageSelectable.value
    });
    return !!items.length && isSelected(items);
  });
  const data = {
    toggleSelect,
    select,
    selectAll,
    isSelected,
    isSomeSelected,
    someSelected,
    allSelected,
    showSelectAll: selectStrategy.value.showSelectAll
  };
  provide(VDataTableSelectionSymbol, data);
  return data;
}
function useSelection() {
  const data = inject$1(VDataTableSelectionSymbol);
  if (!data)
    throw new Error("Missing selection!");
  return data;
}
const makeDataTableSortProps = propsFactory({
  sortBy: {
    type: Array,
    default: () => []
  },
  customKeySort: Object,
  multiSort: Boolean,
  mustSort: Boolean
}, "DataTable-sort");
const VDataTableSortSymbol = Symbol.for("vuetify:data-table-sort");
function createSort(props2) {
  const sortBy = useProxiedModel(props2, "sortBy");
  const mustSort = toRef(props2, "mustSort");
  const multiSort = toRef(props2, "multiSort");
  return {
    sortBy,
    mustSort,
    multiSort
  };
}
function provideSort(options) {
  const {
    sortBy,
    mustSort,
    multiSort,
    page
  } = options;
  const toggleSort = (column) => {
    if (column.key == null)
      return;
    let newSortBy = sortBy.value.map((x2) => ({
      ...x2
    })) ?? [];
    const item = newSortBy.find((x2) => x2.key === column.key);
    if (!item) {
      if (multiSort.value)
        newSortBy = [...newSortBy, {
          key: column.key,
          order: "asc"
        }];
      else
        newSortBy = [{
          key: column.key,
          order: "asc"
        }];
    } else if (item.order === "desc") {
      if (mustSort.value) {
        item.order = "asc";
      } else {
        newSortBy = newSortBy.filter((x2) => x2.key !== column.key);
      }
    } else {
      item.order = "desc";
    }
    sortBy.value = newSortBy;
    if (page)
      page.value = 1;
  };
  function isSorted(column) {
    return !!sortBy.value.find((item) => item.key === column.key);
  }
  const data = {
    sortBy,
    toggleSort,
    isSorted
  };
  provide(VDataTableSortSymbol, data);
  return data;
}
function useSort() {
  const data = inject$1(VDataTableSortSymbol);
  if (!data)
    throw new Error("Missing sort!");
  return data;
}
function useSortedItems(props2, items, sortBy, sortFunctions, sortRawFunctions) {
  const locale = useLocale();
  const sortedItems = computed(() => {
    if (!sortBy.value.length)
      return items.value;
    return sortItems(items.value, sortBy.value, locale.current.value, {
      ...props2.customKeySort,
      ...sortFunctions?.value
    }, sortRawFunctions?.value);
  });
  return {
    sortedItems
  };
}
function sortItems(items, sortByItems, locale, customSorters, customRawSorters) {
  const stringCollator = new Intl.Collator(locale, {
    sensitivity: "accent",
    usage: "sort"
  });
  return [...items].sort((a, b) => {
    for (let i = 0; i < sortByItems.length; i++) {
      const sortKey = sortByItems[i].key;
      const sortOrder = sortByItems[i].order ?? "asc";
      if (sortOrder === false)
        continue;
      let sortA = getObjectValueByPath(a.raw, sortKey);
      let sortB = getObjectValueByPath(b.raw, sortKey);
      let sortARaw = a.raw;
      let sortBRaw = b.raw;
      if (sortOrder === "desc") {
        [sortA, sortB] = [sortB, sortA];
        [sortARaw, sortBRaw] = [sortBRaw, sortARaw];
      }
      if (customRawSorters?.[sortKey]) {
        const customResult = customRawSorters[sortKey](sortARaw, sortBRaw);
        if (!customResult)
          continue;
        return customResult;
      }
      if (customSorters?.[sortKey]) {
        const customResult = customSorters[sortKey](sortA, sortB);
        if (!customResult)
          continue;
        return customResult;
      }
      if (sortA instanceof Date && sortB instanceof Date) {
        return sortA.getTime() - sortB.getTime();
      }
      [sortA, sortB] = [sortA, sortB].map((s) => s != null ? s.toString().toLocaleLowerCase() : s);
      if (sortA !== sortB) {
        if (isEmpty(sortA) && isEmpty(sortB))
          return 0;
        if (isEmpty(sortA))
          return -1;
        if (isEmpty(sortB))
          return 1;
        if (!isNaN(sortA) && !isNaN(sortB))
          return Number(sortA) - Number(sortB);
        return stringCollator.compare(sortA, sortB);
      }
    }
    return 0;
  });
}
const VDataTable = "";
const VDataTableFooter$1 = "";
const VPagination$1 = "";
function useRefs() {
  const refs = ref([]);
  onBeforeUpdate(() => refs.value = []);
  function updateRef(e, i) {
    refs.value[i] = e;
  }
  return {
    refs,
    updateRef
  };
}
const makeVPaginationProps = propsFactory({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (props2) => props2.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (val) => val % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: IconValue,
    default: "$first"
  },
  prevIcon: {
    type: IconValue,
    default: "$prev"
  },
  nextIcon: {
    type: IconValue,
    default: "$next"
  },
  lastIcon: {
    type: IconValue,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "nav"
  }),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "text"
  })
}, "VPagination");
const VPagination = genericComponent()({
  name: "VPagination",
  props: makeVPaginationProps(),
  emits: {
    "update:modelValue": (value) => true,
    first: (value) => true,
    prev: (value) => true,
    next: (value) => true,
    last: (value) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const page = useProxiedModel(props2, "modelValue");
    const {
      t,
      n
    } = useLocale();
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      width
    } = useDisplay();
    const maxButtons = shallowRef(-1);
    provideDefaults(void 0, {
      scoped: true
    });
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      if (!entries.length)
        return;
      const {
        target,
        contentRect
      } = entries[0];
      const firstItem = target.querySelector(".v-pagination__list > *");
      if (!firstItem)
        return;
      const totalWidth = contentRect.width;
      const itemWidth = firstItem.offsetWidth + parseFloat(getComputedStyle(firstItem).marginRight) * 2;
      maxButtons.value = getMax(totalWidth, itemWidth);
    });
    const length = computed(() => parseInt(props2.length, 10));
    const start = computed(() => parseInt(props2.start, 10));
    const totalVisible = computed(() => {
      if (props2.totalVisible != null)
        return parseInt(props2.totalVisible, 10);
      else if (maxButtons.value >= 0)
        return maxButtons.value;
      return getMax(width.value, 58);
    });
    function getMax(totalWidth, itemWidth) {
      const minButtons = props2.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        +((totalWidth - itemWidth * minButtons) / itemWidth).toFixed(2)
      ));
    }
    const range = computed(() => {
      if (length.value <= 0 || isNaN(length.value) || length.value > Number.MAX_SAFE_INTEGER)
        return [];
      if (totalVisible.value <= 0)
        return [];
      else if (totalVisible.value === 1)
        return [page.value];
      if (length.value <= totalVisible.value) {
        return createRange(length.value, start.value);
      }
      const even = totalVisible.value % 2 === 0;
      const middle = even ? totalVisible.value / 2 : Math.floor(totalVisible.value / 2);
      const left = even ? middle : middle + 1;
      const right = length.value - middle;
      if (left - page.value >= 0) {
        return [...createRange(Math.max(1, totalVisible.value - 1), start.value), props2.ellipsis, length.value];
      } else if (page.value - right >= (even ? 1 : 0)) {
        const rangeLength = totalVisible.value - 1;
        const rangeStart = length.value - rangeLength + start.value;
        return [start.value, props2.ellipsis, ...createRange(rangeLength, rangeStart)];
      } else {
        const rangeLength = Math.max(1, totalVisible.value - 3);
        const rangeStart = rangeLength === 1 ? page.value : page.value - Math.ceil(rangeLength / 2) + start.value;
        return [start.value, props2.ellipsis, ...createRange(rangeLength, rangeStart), props2.ellipsis, length.value];
      }
    });
    function setValue(e, value, event) {
      e.preventDefault();
      page.value = value;
      event && emit2(event, value);
    }
    const {
      refs,
      updateRef
    } = useRefs();
    provideDefaults({
      VPaginationBtn: {
        color: toRef(props2, "color"),
        border: toRef(props2, "border"),
        density: toRef(props2, "density"),
        size: toRef(props2, "size"),
        variant: toRef(props2, "variant"),
        rounded: toRef(props2, "rounded"),
        elevation: toRef(props2, "elevation")
      }
    });
    const items = computed(() => {
      return range.value.map((item, index2) => {
        const ref2 = (e) => updateRef(e, index2);
        if (typeof item === "string") {
          return {
            isActive: false,
            key: `ellipsis-${index2}`,
            page: item,
            props: {
              ref: ref2,
              ellipsis: true,
              icon: true,
              disabled: true
            }
          };
        } else {
          const isActive = item === page.value;
          return {
            isActive,
            key: item,
            page: n(item),
            props: {
              ref: ref2,
              ellipsis: false,
              icon: true,
              disabled: !!props2.disabled || +props2.length < 2,
              color: isActive ? props2.activeColor : props2.color,
              "aria-current": isActive,
              "aria-label": t(isActive ? props2.currentPageAriaLabel : props2.pageAriaLabel, item),
              onClick: (e) => setValue(e, item)
            }
          };
        }
      });
    });
    const controls = computed(() => {
      const prevDisabled = !!props2.disabled || page.value <= start.value;
      const nextDisabled = !!props2.disabled || page.value >= start.value + length.value - 1;
      return {
        first: props2.showFirstLastPage ? {
          icon: isRtl.value ? props2.lastIcon : props2.firstIcon,
          onClick: (e) => setValue(e, start.value, "first"),
          disabled: prevDisabled,
          "aria-label": t(props2.firstAriaLabel),
          "aria-disabled": prevDisabled
        } : void 0,
        prev: {
          icon: isRtl.value ? props2.nextIcon : props2.prevIcon,
          onClick: (e) => setValue(e, page.value - 1, "prev"),
          disabled: prevDisabled,
          "aria-label": t(props2.previousAriaLabel),
          "aria-disabled": prevDisabled
        },
        next: {
          icon: isRtl.value ? props2.prevIcon : props2.nextIcon,
          onClick: (e) => setValue(e, page.value + 1, "next"),
          disabled: nextDisabled,
          "aria-label": t(props2.nextAriaLabel),
          "aria-disabled": nextDisabled
        },
        last: props2.showFirstLastPage ? {
          icon: isRtl.value ? props2.firstIcon : props2.lastIcon,
          onClick: (e) => setValue(e, start.value + length.value - 1, "last"),
          disabled: nextDisabled,
          "aria-label": t(props2.lastAriaLabel),
          "aria-disabled": nextDisabled
        } : void 0
      };
    });
    function updateFocus() {
      const currentIndex = page.value - start.value;
      refs.value[currentIndex]?.$el.focus();
    }
    function onKeydown(e) {
      if (e.key === keyValues.left && !props2.disabled && page.value > +props2.start) {
        page.value = page.value - 1;
        nextTick(updateFocus);
      } else if (e.key === keyValues.right && !props2.disabled && page.value < start.value + length.value - 1) {
        page.value = page.value + 1;
        nextTick(updateFocus);
      }
    }
    useRender(() => createVNode(props2.tag, {
      "ref": resizeRef,
      "class": ["v-pagination", themeClasses.value, props2.class],
      "style": props2.style,
      "role": "navigation",
      "aria-label": t(props2.ariaLabel),
      "onKeydown": onKeydown,
      "data-test": "v-pagination-root"
    }, {
      default: () => [createVNode("ul", {
        "class": "v-pagination__list"
      }, [props2.showFirstLastPage && createVNode("li", {
        "key": "first",
        "class": "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [slots.first ? slots.first(controls.value.first) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.first), null)]), createVNode("li", {
        "key": "prev",
        "class": "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [slots.prev ? slots.prev(controls.value.prev) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.prev), null)]), items.value.map((item, index2) => createVNode("li", {
        "key": item.key,
        "class": ["v-pagination__item", {
          "v-pagination__item--is-active": item.isActive
        }],
        "data-test": "v-pagination-item"
      }, [slots.item ? slots.item(item) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, item.props), {
        default: () => [item.page]
      })])), createVNode("li", {
        "key": "next",
        "class": "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [slots.next ? slots.next(controls.value.next) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.next), null)]), props2.showFirstLastPage && createVNode("li", {
        "key": "last",
        "class": "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [slots.last ? slots.last(controls.value.last) : createVNode(VBtn, mergeProps({
        "_as": "VPaginationBtn"
      }, controls.value.last), null)])])]
    }));
    return {};
  }
});
const makeVDataTableFooterProps = propsFactory({
  prevIcon: {
    type: String,
    default: "$prev"
  },
  nextIcon: {
    type: String,
    default: "$next"
  },
  firstIcon: {
    type: String,
    default: "$first"
  },
  lastIcon: {
    type: String,
    default: "$last"
  },
  itemsPerPageText: {
    type: String,
    default: "$vuetify.dataFooter.itemsPerPageText"
  },
  pageText: {
    type: String,
    default: "$vuetify.dataFooter.pageText"
  },
  firstPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.firstPage"
  },
  prevPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.prevPage"
  },
  nextPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.nextPage"
  },
  lastPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.lastPage"
  },
  itemsPerPageOptions: {
    type: Array,
    default: () => [{
      value: 10,
      title: "10"
    }, {
      value: 25,
      title: "25"
    }, {
      value: 50,
      title: "50"
    }, {
      value: 100,
      title: "100"
    }, {
      value: -1,
      title: "$vuetify.dataFooter.itemsPerPageAll"
    }]
  },
  showCurrentPage: Boolean
}, "VDataTableFooter");
const VDataTableFooter = genericComponent()({
  name: "VDataTableFooter",
  props: makeVDataTableFooterProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const {
      page,
      pageCount,
      startIndex,
      stopIndex,
      itemsLength,
      itemsPerPage,
      setItemsPerPage
    } = usePagination();
    const itemsPerPageOptions = computed(() => props2.itemsPerPageOptions.map((option) => {
      if (typeof option === "number") {
        return {
          value: option,
          title: option === -1 ? t("$vuetify.dataFooter.itemsPerPageAll") : String(option)
        };
      }
      return {
        ...option,
        title: t(option.title)
      };
    }));
    useRender(() => {
      const paginationProps = VPagination.filterProps(props2);
      return createVNode("div", {
        "class": "v-data-table-footer"
      }, [slots.prepend?.(), createVNode("div", {
        "class": "v-data-table-footer__items-per-page"
      }, [createVNode("span", null, [t(props2.itemsPerPageText)]), createVNode(VSelect, {
        "items": itemsPerPageOptions.value,
        "modelValue": itemsPerPage.value,
        "onUpdate:modelValue": (v) => setItemsPerPage(Number(v)),
        "density": "compact",
        "variant": "outlined",
        "hide-details": true
      }, null)]), createVNode("div", {
        "class": "v-data-table-footer__info"
      }, [createVNode("div", null, [t(props2.pageText, !itemsLength.value ? 0 : startIndex.value + 1, stopIndex.value, itemsLength.value)])]), createVNode("div", {
        "class": "v-data-table-footer__pagination"
      }, [createVNode(VPagination, mergeProps({
        "modelValue": page.value,
        "onUpdate:modelValue": ($event) => page.value = $event,
        "density": "comfortable",
        "first-aria-label": props2.firstPageLabel,
        "last-aria-label": props2.lastPageLabel,
        "length": pageCount.value,
        "next-aria-label": props2.nextPageLabel,
        "previous-aria-label": props2.prevPageLabel,
        "rounded": true,
        "show-first-last-page": true,
        "total-visible": props2.showCurrentPage ? 1 : 0,
        "variant": "plain"
      }, paginationProps), null)])]);
    });
    return {};
  }
});
const VDataTableColumn = defineFunctionalComponent({
  align: {
    type: String,
    default: "start"
  },
  fixed: Boolean,
  fixedOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  noPadding: Boolean,
  tag: String,
  width: [Number, String]
}, (props2, _ref) => {
  let {
    slots
  } = _ref;
  const Tag = props2.tag ?? "td";
  return createVNode(Tag, {
    "class": ["v-data-table__td", {
      "v-data-table-column--fixed": props2.fixed,
      "v-data-table-column--last-fixed": props2.lastFixed,
      "v-data-table-column--no-padding": props2.noPadding
    }, `v-data-table-column--align-${props2.align}`],
    "style": {
      height: convertToUnit(props2.height),
      width: convertToUnit(props2.width),
      left: convertToUnit(props2.fixedOffset || null)
    }
  }, {
    default: () => [slots.default?.()]
  });
});
const makeDataTableHeaderProps = propsFactory({
  headers: Array
}, "DataTable-header");
const VDataTableHeadersSymbol = Symbol.for("vuetify:data-table-headers");
const defaultHeader = {
  title: "",
  sortable: false
};
const defaultActionHeader = {
  ...defaultHeader,
  width: 48
};
function priorityQueue() {
  let arr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const queue2 = arr.map((element) => ({
    element,
    priority: 0
  }));
  return {
    enqueue: (element, priority) => {
      let added = false;
      for (let i = 0; i < queue2.length; i++) {
        const item = queue2[i];
        if (item.priority > priority) {
          queue2.splice(i, 0, {
            element,
            priority
          });
          added = true;
          break;
        }
      }
      if (!added)
        queue2.push({
          element,
          priority
        });
    },
    size: () => queue2.length,
    count: () => {
      let count = 0;
      if (!queue2.length)
        return 0;
      const whole = Math.floor(queue2[0].priority);
      for (let i = 0; i < queue2.length; i++) {
        if (Math.floor(queue2[i].priority) === whole)
          count += 1;
      }
      return count;
    },
    dequeue: () => {
      return queue2.shift();
    }
  };
}
function extractLeaves(item) {
  let columns = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!item.children) {
    columns.push(item);
  } else {
    for (const child of item.children) {
      extractLeaves(child, columns);
    }
  }
  return columns;
}
function extractKeys(headers) {
  let keys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  for (const item of headers) {
    if (item.key)
      keys.add(item.key);
    if (item.children) {
      extractKeys(item.children, keys);
    }
  }
  return keys;
}
function getDefaultItem(item) {
  if (!item.key)
    return void 0;
  if (item.key === "data-table-group")
    return defaultHeader;
  if (["data-table-expand", "data-table-select"].includes(item.key))
    return defaultActionHeader;
  return void 0;
}
function getDepth(item) {
  let depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!item.children)
    return depth;
  return Math.max(depth, ...item.children.map((child) => getDepth(child, depth + 1)));
}
function parseFixedColumns(items) {
  let seenFixed = false;
  function setFixed(item) {
    let parentFixed = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!item)
      return;
    if (parentFixed) {
      item.fixed = true;
    }
    if (item.fixed) {
      if (item.children) {
        for (let i = item.children.length - 1; i >= 0; i--) {
          setFixed(item.children[i], true);
        }
      } else {
        if (!seenFixed) {
          item.lastFixed = true;
        } else if (isNaN(+item.width)) {
          consoleError(`Multiple fixed columns should have a static width (key: ${item.key})`);
        }
        seenFixed = true;
      }
    } else {
      if (item.children) {
        for (let i = item.children.length - 1; i >= 0; i--) {
          setFixed(item.children[i]);
        }
      } else {
        seenFixed = false;
      }
    }
  }
  for (let i = items.length - 1; i >= 0; i--) {
    setFixed(items[i]);
  }
  function setFixedOffset(item) {
    let fixedOffset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!item)
      return fixedOffset2;
    if (item.children) {
      item.fixedOffset = fixedOffset2;
      for (const child of item.children) {
        fixedOffset2 = setFixedOffset(child, fixedOffset2);
      }
    } else if (item.fixed) {
      item.fixedOffset = fixedOffset2;
      fixedOffset2 += parseFloat(item.width || "0") || 0;
    }
    return fixedOffset2;
  }
  let fixedOffset = 0;
  for (const item of items) {
    fixedOffset = setFixedOffset(item, fixedOffset);
  }
}
function parse(items, maxDepth) {
  const headers = [];
  let currentDepth = 0;
  const queue2 = priorityQueue(items);
  while (queue2.size() > 0) {
    let rowSize = queue2.count();
    const row = [];
    let fraction = 1;
    while (rowSize > 0) {
      const {
        element: item,
        priority
      } = queue2.dequeue();
      const diff = maxDepth - currentDepth - getDepth(item);
      row.push({
        ...item,
        rowspan: diff ?? 1,
        colspan: item.children ? extractLeaves(item).length : 1
      });
      if (item.children) {
        for (const child of item.children) {
          const sort = priority % 1 + fraction / Math.pow(10, currentDepth + 2);
          queue2.enqueue(child, currentDepth + diff + sort);
        }
      }
      fraction += 1;
      rowSize -= 1;
    }
    currentDepth += 1;
    headers.push(row);
  }
  const columns = items.map((item) => extractLeaves(item)).flat();
  return {
    columns,
    headers
  };
}
function convertToInternalHeaders(items) {
  const internalHeaders = [];
  for (const item of items) {
    const defaultItem = {
      ...getDefaultItem(item),
      ...item
    };
    const key = defaultItem.key ?? (typeof defaultItem.value === "string" ? defaultItem.value : null);
    const value = defaultItem.value ?? key ?? null;
    const internalItem = {
      ...defaultItem,
      key,
      value,
      sortable: defaultItem.sortable ?? (defaultItem.key != null || !!defaultItem.sort),
      children: defaultItem.children ? convertToInternalHeaders(defaultItem.children) : void 0
    };
    internalHeaders.push(internalItem);
  }
  return internalHeaders;
}
function createHeaders(props2, options) {
  const headers = ref([]);
  const columns = ref([]);
  const sortFunctions = ref({});
  const sortRawFunctions = ref({});
  const filterFunctions = ref({});
  watchEffect(() => {
    const _headers = props2.headers || Object.keys(props2.items[0] ?? {}).map((key) => ({
      key,
      title: capitalize(key)
    }));
    const items = _headers.slice();
    const keys = extractKeys(items);
    if (options?.groupBy?.value.length && !keys.has("data-table-group")) {
      items.unshift({
        key: "data-table-group",
        title: "Group"
      });
    }
    if (options?.showSelect?.value && !keys.has("data-table-select")) {
      items.unshift({
        key: "data-table-select"
      });
    }
    if (options?.showExpand?.value && !keys.has("data-table-expand")) {
      items.push({
        key: "data-table-expand"
      });
    }
    const internalHeaders = convertToInternalHeaders(items);
    parseFixedColumns(internalHeaders);
    const maxDepth = Math.max(...internalHeaders.map((item) => getDepth(item))) + 1;
    const parsed = parse(internalHeaders, maxDepth);
    headers.value = parsed.headers;
    columns.value = parsed.columns;
    const flatHeaders = parsed.headers.flat(1);
    for (const header of flatHeaders) {
      if (!header.key)
        continue;
      if (header.sortable) {
        if (header.sort) {
          sortFunctions.value[header.key] = header.sort;
        }
        if (header.sortRaw) {
          sortRawFunctions.value[header.key] = header.sortRaw;
        }
      }
      if (header.filter) {
        filterFunctions.value[header.key] = header.filter;
      }
    }
  });
  const data = {
    headers,
    columns,
    sortFunctions,
    sortRawFunctions,
    filterFunctions
  };
  provide(VDataTableHeadersSymbol, data);
  return data;
}
function useHeaders() {
  const data = inject$1(VDataTableHeadersSymbol);
  if (!data)
    throw new Error("Missing headers!");
  return data;
}
const makeVDataTableHeadersProps = propsFactory({
  color: String,
  sticky: Boolean,
  multiSort: Boolean,
  sortAscIcon: {
    type: IconValue,
    default: "$sortAsc"
  },
  sortDescIcon: {
    type: IconValue,
    default: "$sortDesc"
  },
  headerProps: {
    type: Object
  },
  ...makeLoaderProps()
}, "VDataTableHeaders");
const VDataTableHeaders = genericComponent()({
  name: "VDataTableHeaders",
  props: makeVDataTableHeadersProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      toggleSort,
      sortBy,
      isSorted
    } = useSort();
    const {
      someSelected,
      allSelected,
      selectAll,
      showSelectAll
    } = useSelection();
    const {
      columns,
      headers
    } = useHeaders();
    const {
      loaderClasses
    } = useLoader(props2);
    function getFixedStyles(column, y) {
      if (!props2.sticky && !column.fixed)
        return void 0;
      return {
        position: "sticky",
        left: column.fixed ? convertToUnit(column.fixedOffset) : void 0,
        top: props2.sticky ? `calc(var(--v-table-header-height) * ${y})` : void 0
      };
    }
    function getSortIcon(column) {
      const item = sortBy.value.find((item2) => item2.key === column.key);
      if (!item)
        return props2.sortAscIcon;
      return item.order === "asc" ? props2.sortAscIcon : props2.sortDescIcon;
    }
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props2, "color");
    const slotProps = computed(() => ({
      headers: headers.value,
      columns: columns.value,
      toggleSort,
      isSorted,
      sortBy: sortBy.value,
      someSelected: someSelected.value,
      allSelected: allSelected.value,
      selectAll,
      getSortIcon
    }));
    const VDataTableHeaderCell = (_ref2) => {
      let {
        column,
        x: x2,
        y
      } = _ref2;
      const noPadding = column.key === "data-table-select" || column.key === "data-table-expand";
      const headerProps = mergeProps(props2.headerProps ?? {}, column.headerProps ?? {});
      return createVNode(VDataTableColumn, mergeProps({
        "tag": "th",
        "align": column.align,
        "class": ["v-data-table__th", {
          "v-data-table__th--sortable": column.sortable,
          "v-data-table__th--sorted": isSorted(column),
          "v-data-table__th--fixed": column.fixed,
          "v-data-table__th--sticky": props2.sticky
        }, loaderClasses.value],
        "style": {
          width: convertToUnit(column.width),
          minWidth: convertToUnit(column.minWidth),
          ...getFixedStyles(column, y)
        },
        "colspan": column.colspan,
        "rowspan": column.rowspan,
        "onClick": column.sortable ? () => toggleSort(column) : void 0,
        "fixed": column.fixed,
        "lastFixed": column.lastFixed,
        "noPadding": noPadding
      }, headerProps), {
        default: () => {
          const columnSlotName = `header.${column.key}`;
          const columnSlotProps = {
            column,
            selectAll,
            isSorted,
            toggleSort,
            sortBy: sortBy.value,
            someSelected: someSelected.value,
            allSelected: allSelected.value,
            getSortIcon
          };
          if (slots[columnSlotName])
            return slots[columnSlotName](columnSlotProps);
          if (column.key === "data-table-select") {
            return slots["header.data-table-select"]?.(columnSlotProps) ?? (showSelectAll && createVNode(VCheckboxBtn, {
              "modelValue": allSelected.value,
              "indeterminate": someSelected.value && !allSelected.value,
              "onUpdate:modelValue": selectAll
            }, null));
          }
          return createVNode("div", {
            "class": "v-data-table-header__content"
          }, [createVNode("span", null, [column.title]), column.sortable && createVNode(VIcon, {
            "key": "icon",
            "class": "v-data-table-header__sort-icon",
            "icon": getSortIcon(column)
          }, null), props2.multiSort && isSorted(column) && createVNode("div", {
            "key": "badge",
            "class": ["v-data-table-header__sort-badge", ...backgroundColorClasses.value],
            "style": backgroundColorStyles.value
          }, [sortBy.value.findIndex((x3) => x3.key === column.key) + 1])]);
        }
      });
    };
    useRender(() => {
      return createVNode(Fragment, null, [slots.headers ? slots.headers(slotProps.value) : headers.value.map((row, y) => createVNode("tr", null, [row.map((column, x2) => createVNode(VDataTableHeaderCell, {
        "column": column,
        "x": x2,
        "y": y
      }, null))])), props2.loading && createVNode("tr", {
        "class": "v-data-table-progress"
      }, [createVNode("th", {
        "colspan": columns.value.length
      }, [createVNode(LoaderSlot, {
        "name": "v-data-table-progress",
        "absolute": true,
        "active": true,
        "color": typeof props2.loading === "boolean" ? void 0 : props2.loading,
        "indeterminate": true
      }, {
        default: slots.loader
      })])])]);
    });
  }
});
const makeVDataTableGroupHeaderRowProps = propsFactory({
  item: {
    type: Object,
    required: true
  }
}, "VDataTableGroupHeaderRow");
const VDataTableGroupHeaderRow = genericComponent()({
  name: "VDataTableGroupHeaderRow",
  props: makeVDataTableGroupHeaderRowProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isGroupOpen,
      toggleGroup,
      extractRows
    } = useGroupBy();
    const {
      isSelected,
      isSomeSelected,
      select
    } = useSelection();
    const {
      columns
    } = useHeaders();
    const rows = computed(() => {
      return extractRows([props2.item]);
    });
    return () => createVNode("tr", {
      "class": "v-data-table-group-header-row",
      "style": {
        "--v-data-table-group-header-row-depth": props2.item.depth
      }
    }, [columns.value.map((column) => {
      if (column.key === "data-table-group") {
        const icon = isGroupOpen(props2.item) ? "$expand" : "$next";
        const onClick = () => toggleGroup(props2.item);
        return slots["data-table-group"]?.({
          item: props2.item,
          count: rows.value.length,
          props: {
            icon,
            onClick
          }
        }) ?? createVNode(VDataTableColumn, {
          "class": "v-data-table-group-header-row__column"
        }, {
          default: () => [createVNode(VBtn, {
            "size": "small",
            "variant": "text",
            "icon": icon,
            "onClick": onClick
          }, null), createVNode("span", null, [props2.item.value]), createVNode("span", null, [createTextVNode("("), rows.value.length, createTextVNode(")")])]
        });
      }
      if (column.key === "data-table-select") {
        const modelValue = isSelected(rows.value);
        const indeterminate = isSomeSelected(rows.value) && !modelValue;
        const selectGroup = (v) => select(rows.value, v);
        return slots["data-table-select"]?.({
          props: {
            modelValue,
            indeterminate,
            "onUpdate:modelValue": selectGroup
          }
        }) ?? createVNode("td", null, [createVNode(VCheckboxBtn, {
          "modelValue": modelValue,
          "indeterminate": indeterminate,
          "onUpdate:modelValue": selectGroup
        }, null)]);
      }
      return createVNode("td", null, null);
    })]);
  }
});
const makeVDataTableRowProps = propsFactory({
  index: Number,
  item: Object,
  cellProps: [Object, Function],
  onClick: EventProp(),
  onContextmenu: EventProp(),
  onDblclick: EventProp()
}, "VDataTableRow");
const VDataTableRow = genericComponent()({
  name: "VDataTableRow",
  props: makeVDataTableRowProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      toggleSelect
    } = useSelection();
    const {
      isExpanded,
      toggleExpand
    } = useExpanded();
    const {
      columns
    } = useHeaders();
    useRender(() => createVNode("tr", {
      "class": ["v-data-table__tr", {
        "v-data-table__tr--clickable": !!(props2.onClick || props2.onContextmenu || props2.onDblclick)
      }],
      "onClick": props2.onClick,
      "onContextmenu": props2.onContextmenu,
      "onDblclick": props2.onDblclick
    }, [props2.item && columns.value.map((column, i) => {
      const item = props2.item;
      const slotName = `item.${column.key}`;
      const slotProps = {
        index: props2.index,
        item: item.raw,
        internalItem: item,
        value: getObjectValueByPath(item.columns, column.key),
        column,
        isSelected,
        toggleSelect,
        isExpanded,
        toggleExpand
      };
      const cellProps = typeof props2.cellProps === "function" ? props2.cellProps({
        index: slotProps.index,
        item: slotProps.item,
        internalItem: slotProps.internalItem,
        value: slotProps.value,
        column
      }) : props2.cellProps;
      const columnCellProps = typeof column.cellProps === "function" ? column.cellProps({
        index: slotProps.index,
        item: slotProps.item,
        internalItem: slotProps.internalItem,
        value: slotProps.value
      }) : column.cellProps;
      return createVNode(VDataTableColumn, mergeProps({
        "align": column.align,
        "fixed": column.fixed,
        "fixedOffset": column.fixedOffset,
        "lastFixed": column.lastFixed,
        "noPadding": column.key === "data-table-select" || column.key === "data-table-expand",
        "width": column.width
      }, cellProps, columnCellProps), {
        default: () => {
          if (slots[slotName])
            return slots[slotName](slotProps);
          if (column.key === "data-table-select") {
            return slots["item.data-table-select"]?.(slotProps) ?? createVNode(VCheckboxBtn, {
              "disabled": !item.selectable,
              "modelValue": isSelected([item]),
              "onClick": withModifiers(() => toggleSelect(item), ["stop"])
            }, null);
          }
          if (column.key === "data-table-expand") {
            return slots["item.data-table-expand"]?.(slotProps) ?? createVNode(VBtn, {
              "icon": isExpanded(item) ? "$collapse" : "$expand",
              "size": "small",
              "variant": "text",
              "onClick": withModifiers(() => toggleExpand(item), ["stop"])
            }, null);
          }
          return toDisplayString(slotProps.value);
        }
      });
    })]));
  }
});
const makeVDataTableRowsProps = propsFactory({
  loading: [Boolean, String],
  loadingText: {
    type: String,
    default: "$vuetify.dataIterator.loadingText"
  },
  hideNoData: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function]
}, "VDataTableRows");
const VDataTableRows = genericComponent()({
  name: "VDataTableRows",
  inheritAttrs: false,
  props: makeVDataTableRowsProps(),
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      columns
    } = useHeaders();
    const {
      expandOnClick,
      toggleExpand,
      isExpanded
    } = useExpanded();
    const {
      isSelected,
      toggleSelect
    } = useSelection();
    const {
      toggleGroup,
      isGroupOpen
    } = useGroupBy();
    const {
      t
    } = useLocale();
    useRender(() => {
      if (props2.loading && (!props2.items.length || slots.loading)) {
        return createVNode("tr", {
          "class": "v-data-table-rows-loading",
          "key": "loading"
        }, [createVNode("td", {
          "colspan": columns.value.length
        }, [slots.loading?.() ?? t(props2.loadingText)])]);
      }
      if (!props2.loading && !props2.items.length && !props2.hideNoData) {
        return createVNode("tr", {
          "class": "v-data-table-rows-no-data",
          "key": "no-data"
        }, [createVNode("td", {
          "colspan": columns.value.length
        }, [slots["no-data"]?.() ?? t(props2.noDataText)])]);
      }
      return createVNode(Fragment, null, [props2.items.map((item, index2) => {
        if (item.type === "group") {
          const slotProps2 = {
            index: index2,
            item,
            columns: columns.value,
            isExpanded,
            toggleExpand,
            isSelected,
            toggleSelect,
            toggleGroup,
            isGroupOpen
          };
          return slots["group-header"] ? slots["group-header"](slotProps2) : createVNode(VDataTableGroupHeaderRow, mergeProps({
            "key": `group-header_${item.id}`,
            "item": item
          }, getPrefixedEventHandlers(attrs, ":group-header", () => slotProps2)), slots);
        }
        const slotProps = {
          index: index2,
          item: item.raw,
          internalItem: item,
          columns: columns.value,
          isExpanded,
          toggleExpand,
          isSelected,
          toggleSelect
        };
        const itemSlotProps = {
          ...slotProps,
          props: mergeProps({
            key: `item_${item.key ?? item.index}`,
            onClick: expandOnClick.value ? () => {
              toggleExpand(item);
            } : void 0,
            index: index2,
            item,
            cellProps: props2.cellProps
          }, getPrefixedEventHandlers(attrs, ":row", () => slotProps), typeof props2.rowProps === "function" ? props2.rowProps({
            item: slotProps.item,
            index: slotProps.index,
            internalItem: slotProps.internalItem
          }) : props2.rowProps)
        };
        return createVNode(Fragment, {
          "key": itemSlotProps.props.key
        }, [slots.item ? slots.item(itemSlotProps) : createVNode(VDataTableRow, itemSlotProps.props, slots), isExpanded(item) && slots["expanded-row"]?.(slotProps)]);
      })]);
    });
    return {};
  }
});
const VTable$1 = "";
const makeVTableProps = propsFactory({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  ...makeComponentProps(),
  ...makeDensityProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VTable");
const VTable = genericComponent()({
  name: "VTable",
  props: makeVTableProps(),
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      densityClasses
    } = useDensity(props2);
    useRender(() => createVNode(props2.tag, {
      "class": ["v-table", {
        "v-table--fixed-height": !!props2.height,
        "v-table--fixed-header": props2.fixedHeader,
        "v-table--fixed-footer": props2.fixedFooter,
        "v-table--has-top": !!slots.top,
        "v-table--has-bottom": !!slots.bottom,
        "v-table--hover": props2.hover
      }, themeClasses.value, densityClasses.value, props2.class],
      "style": props2.style
    }, {
      default: () => [slots.top?.(), slots.default ? createVNode("div", {
        "class": "v-table__wrapper",
        "style": {
          height: convertToUnit(props2.height)
        }
      }, [createVNode("table", null, [slots.default()])]) : slots.wrapper?.(), slots.bottom?.()]
    }));
    return {};
  }
});
const makeDataTableItemsProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  returnObject: Boolean
}, "DataTable-items");
function transformItem(props2, item, index2, columns) {
  const value = props2.returnObject ? item : getPropertyFromItem(item, props2.itemValue);
  const selectable = getPropertyFromItem(item, props2.itemSelectable, true);
  const itemColumns = columns.reduce((obj, column) => {
    if (column.key != null)
      obj[column.key] = getPropertyFromItem(item, column.value);
    return obj;
  }, {});
  return {
    type: "item",
    key: props2.returnObject ? getPropertyFromItem(item, props2.itemValue) : value,
    index: index2,
    value,
    selectable,
    columns: itemColumns,
    raw: item
  };
}
function transformItems(props2, items, columns) {
  return items.map((item, index2) => transformItem(props2, item, index2, columns));
}
function useDataTableItems(props2, columns) {
  const items = computed(() => transformItems(props2, props2.items, columns.value));
  return {
    items
  };
}
const makeDataTableProps = propsFactory({
  ...makeVDataTableRowsProps(),
  width: [String, Number],
  search: String,
  ...makeDataTableExpandProps(),
  ...makeDataTableGroupProps(),
  ...makeDataTableHeaderProps(),
  ...makeDataTableItemsProps(),
  ...makeDataTableSelectProps(),
  ...makeDataTableSortProps(),
  ...makeVDataTableHeadersProps(),
  ...makeVTableProps()
}, "DataTable");
const makeVDataTableProps = propsFactory({
  ...makeDataTablePaginateProps(),
  ...makeDataTableProps(),
  ...makeFilterProps(),
  ...makeVDataTableFooterProps()
}, "VDataTable");
genericComponent()({
  name: "VDataTable",
  props: makeVDataTableProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:page": (value) => true,
    "update:itemsPerPage": (value) => true,
    "update:sortBy": (value) => true,
    "update:options": (value) => true,
    "update:groupBy": (value) => true,
    "update:expanded": (value) => true,
    "update:currentItems": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      groupBy
    } = createGroupBy(props2);
    const {
      sortBy,
      multiSort,
      mustSort
    } = createSort(props2);
    const {
      page,
      itemsPerPage
    } = createPagination(props2);
    const {
      columns,
      headers,
      sortFunctions,
      sortRawFunctions,
      filterFunctions
    } = createHeaders(props2, {
      groupBy,
      showSelect: toRef(props2, "showSelect"),
      showExpand: toRef(props2, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props2, columns);
    const search = toRef(props2, "search");
    const {
      filteredItems
    } = useFilter(props2, items, search, {
      transform: (item) => item.columns,
      customKeyFilter: filterFunctions
    });
    const {
      toggleSort
    } = provideSort({
      sortBy,
      multiSort,
      mustSort,
      page
    });
    const {
      sortByWithGroups,
      opened,
      extractRows,
      isGroupOpen,
      toggleGroup
    } = provideGroupBy({
      groupBy,
      sortBy
    });
    const {
      sortedItems
    } = useSortedItems(props2, filteredItems, sortByWithGroups, sortFunctions, sortRawFunctions);
    const {
      flatItems
    } = useGroupedItems(sortedItems, groupBy, opened);
    const itemsLength = computed(() => flatItems.value.length);
    const {
      startIndex,
      stopIndex,
      pageCount,
      setItemsPerPage
    } = providePagination({
      page,
      itemsPerPage,
      itemsLength
    });
    const {
      paginatedItems
    } = usePaginatedItems({
      items: flatItems,
      startIndex,
      stopIndex,
      itemsPerPage
    });
    const paginatedItemsWithoutGroups = computed(() => extractRows(paginatedItems.value));
    const {
      isSelected,
      select,
      selectAll,
      toggleSelect,
      someSelected,
      allSelected
    } = provideSelection(props2, {
      allItems: items,
      currentPage: paginatedItemsWithoutGroups
    });
    const {
      isExpanded,
      toggleExpand
    } = provideExpanded(props2);
    useOptions({
      page,
      itemsPerPage,
      sortBy,
      groupBy,
      search
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props2, "hideNoData"),
        noDataText: toRef(props2, "noDataText"),
        loading: toRef(props2, "loading"),
        loadingText: toRef(props2, "loadingText")
      }
    });
    const slotProps = computed(() => ({
      page: page.value,
      itemsPerPage: itemsPerPage.value,
      sortBy: sortBy.value,
      pageCount: pageCount.value,
      toggleSort,
      setItemsPerPage,
      someSelected: someSelected.value,
      allSelected: allSelected.value,
      isSelected,
      select,
      selectAll,
      toggleSelect,
      isExpanded,
      toggleExpand,
      isGroupOpen,
      toggleGroup,
      items: paginatedItemsWithoutGroups.value.map((item) => item.raw),
      internalItems: paginatedItemsWithoutGroups.value,
      groupedItems: paginatedItems.value,
      columns: columns.value,
      headers: headers.value
    }));
    useRender(() => {
      const dataTableFooterProps = VDataTableFooter.filterProps(props2);
      const dataTableHeadersProps = VDataTableHeaders.filterProps(props2);
      const dataTableRowsProps = VDataTableRows.filterProps(props2);
      const tableProps = VTable.filterProps(props2);
      return createVNode(VTable, mergeProps({
        "class": ["v-data-table", {
          "v-data-table--show-select": props2.showSelect,
          "v-data-table--loading": props2.loading
        }, props2.class],
        "style": props2.style
      }, tableProps), {
        top: () => slots.top?.(slotProps.value),
        default: () => slots.default ? slots.default(slotProps.value) : createVNode(Fragment, null, [slots.colgroup?.(slotProps.value), createVNode("thead", null, [createVNode(VDataTableHeaders, dataTableHeadersProps, slots)]), slots.thead?.(slotProps.value), createVNode("tbody", null, [slots["body.prepend"]?.(slotProps.value), slots.body ? slots.body(slotProps.value) : createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
          "items": paginatedItems.value
        }), slots), slots["body.append"]?.(slotProps.value)]), slots.tbody?.(slotProps.value), slots.tfoot?.(slotProps.value)]),
        bottom: () => slots.bottom ? slots.bottom(slotProps.value) : createVNode(Fragment, null, [createVNode(VDivider, null, null), createVNode(VDataTableFooter, dataTableFooterProps, {
          prepend: slots["footer.prepend"]
        })])
      });
    });
    return {};
  }
});
const makeVDataTableVirtualProps = propsFactory({
  ...makeDataTableProps(),
  ...makeDataTableGroupProps(),
  ...makeVirtualProps(),
  ...makeFilterProps()
}, "VDataTableVirtual");
const VDataTableVirtual = genericComponent()({
  name: "VDataTableVirtual",
  props: makeVDataTableVirtualProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:sortBy": (value) => true,
    "update:options": (value) => true,
    "update:groupBy": (value) => true,
    "update:expanded": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      groupBy
    } = createGroupBy(props2);
    const {
      sortBy,
      multiSort,
      mustSort
    } = createSort(props2);
    const {
      columns,
      headers,
      filterFunctions,
      sortFunctions,
      sortRawFunctions
    } = createHeaders(props2, {
      groupBy,
      showSelect: toRef(props2, "showSelect"),
      showExpand: toRef(props2, "showExpand")
    });
    const {
      items
    } = useDataTableItems(props2, columns);
    const search = toRef(props2, "search");
    const {
      filteredItems
    } = useFilter(props2, items, search, {
      transform: (item) => item.columns,
      customKeyFilter: filterFunctions
    });
    const {
      toggleSort
    } = provideSort({
      sortBy,
      multiSort,
      mustSort
    });
    const {
      sortByWithGroups,
      opened,
      extractRows,
      isGroupOpen,
      toggleGroup
    } = provideGroupBy({
      groupBy,
      sortBy
    });
    const {
      sortedItems
    } = useSortedItems(props2, filteredItems, sortByWithGroups, sortFunctions, sortRawFunctions);
    const {
      flatItems
    } = useGroupedItems(sortedItems, groupBy, opened);
    const allItems = computed(() => extractRows(flatItems.value));
    const {
      isSelected,
      select,
      selectAll,
      toggleSelect,
      someSelected,
      allSelected
    } = provideSelection(props2, {
      allItems,
      currentPage: allItems
    });
    const {
      isExpanded,
      toggleExpand
    } = provideExpanded(props2);
    const {
      containerRef,
      markerRef,
      paddingTop,
      paddingBottom,
      computedItems,
      handleItemResize,
      handleScroll,
      handleScrollend
    } = useVirtual(props2, flatItems);
    const displayItems = computed(() => computedItems.value.map((item) => item.raw));
    useOptions({
      sortBy,
      page: shallowRef(1),
      itemsPerPage: shallowRef(-1),
      groupBy,
      search
    });
    provideDefaults({
      VDataTableRows: {
        hideNoData: toRef(props2, "hideNoData"),
        noDataText: toRef(props2, "noDataText"),
        loading: toRef(props2, "loading"),
        loadingText: toRef(props2, "loadingText")
      }
    });
    const slotProps = computed(() => ({
      sortBy: sortBy.value,
      toggleSort,
      someSelected: someSelected.value,
      allSelected: allSelected.value,
      isSelected,
      select,
      selectAll,
      toggleSelect,
      isExpanded,
      toggleExpand,
      isGroupOpen,
      toggleGroup,
      items: allItems.value.map((item) => item.raw),
      internalItems: allItems.value,
      groupedItems: flatItems.value,
      columns: columns.value,
      headers: headers.value
    }));
    useRender(() => {
      const dataTableHeadersProps = VDataTableHeaders.filterProps(props2);
      const dataTableRowsProps = VDataTableRows.filterProps(props2);
      const tableProps = VTable.filterProps(props2);
      return createVNode(VTable, mergeProps({
        "class": ["v-data-table", {
          "v-data-table--loading": props2.loading
        }, props2.class],
        "style": props2.style
      }, tableProps), {
        top: () => slots.top?.(slotProps.value),
        wrapper: () => createVNode("div", {
          "ref": containerRef,
          "onScrollPassive": handleScroll,
          "onScrollend": handleScrollend,
          "class": "v-table__wrapper",
          "style": {
            height: convertToUnit(props2.height)
          }
        }, [createVNode("table", null, [slots.colgroup?.(slotProps.value), createVNode("thead", null, [createVNode(VDataTableHeaders, mergeProps(dataTableHeadersProps, {
          "sticky": props2.fixedHeader
        }), slots)]), createVNode("tbody", null, [createVNode("tr", {
          "ref": markerRef,
          "style": {
            height: convertToUnit(paddingTop.value),
            border: 0
          }
        }, [createVNode("td", {
          "colspan": columns.value.length,
          "style": {
            height: 0,
            border: 0
          }
        }, null)]), slots["body.prepend"]?.(slotProps.value), createVNode(VDataTableRows, mergeProps(attrs, dataTableRowsProps, {
          "items": displayItems.value
        }), {
          ...slots,
          item: (itemSlotProps) => createVNode(VVirtualScrollItem, {
            "key": itemSlotProps.internalItem.index,
            "renderless": true,
            "onUpdate:height": (height) => handleItemResize(itemSlotProps.internalItem.index, height)
          }, {
            default: (_ref2) => {
              let {
                itemRef
              } = _ref2;
              return slots.item?.({
                ...itemSlotProps,
                itemRef
              }) ?? createVNode(VDataTableRow, mergeProps(itemSlotProps.props, {
                "ref": itemRef,
                "key": itemSlotProps.internalItem.index,
                "index": itemSlotProps.internalItem.index
              }), slots);
            }
          })
        }), slots["body.append"]?.(slotProps.value), createVNode("tr", {
          "style": {
            height: convertToUnit(paddingBottom.value),
            border: 0
          }
        }, [createVNode("td", {
          "colspan": columns.value.length,
          "style": {
            height: 0,
            border: 0
          }
        }, null)])])])]),
        bottom: () => slots.bottom?.(slotProps.value)
      });
    });
  }
});
const VGrid = "";
const VSpacer = createSimpleFunctional("v-spacer", "div", "VSpacer");
const VExpansionPanel$1 = "";
const VExpansionPanelSymbol = Symbol.for("vuetify:v-expansion-panel");
const allowedVariants = ["default", "accordion", "inset", "popout"];
const makeVExpansionPanelsProps = propsFactory({
  color: String,
  static: Boolean,
  variant: {
    type: String,
    default: "default",
    validator: (v) => allowedVariants.includes(v)
  },
  readonly: Boolean,
  ...makeComponentProps(),
  ...makeGroupProps(),
  ...makeTagProps(),
  ...makeThemeProps()
}, "VExpansionPanels");
const VExpansionPanels = genericComponent()({
  name: "VExpansionPanels",
  props: makeVExpansionPanelsProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useGroup(props2, VExpansionPanelSymbol);
    const {
      themeClasses
    } = provideTheme(props2);
    const variantClass = computed(() => props2.variant && `v-expansion-panels--variant-${props2.variant}`);
    provideDefaults({
      VExpansionPanel: {
        color: toRef(props2, "color"),
        readonly: toRef(props2, "readonly"),
        static: toRef(props2, "static")
      }
    });
    useRender(() => createVNode(props2.tag, {
      "class": ["v-expansion-panels", themeClasses.value, variantClass.value, props2.class],
      "style": props2.style
    }, slots));
    return {};
  }
});
const makeVExpansionPanelTextProps = propsFactory({
  ...makeComponentProps(),
  ...makeLazyProps()
}, "VExpansionPanelText");
const VExpansionPanelText = genericComponent()({
  name: "VExpansionPanelText",
  props: makeVExpansionPanelTextProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const expansionPanel = inject$1(VExpansionPanelSymbol);
    if (!expansionPanel)
      throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props2, expansionPanel.isSelected);
    useRender(() => createVNode(VExpandTransition, {
      "onAfterLeave": onAfterLeave
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": ["v-expansion-panel-text", props2.class],
        "style": props2.style
      }, [slots.default && hasContent.value && createVNode("div", {
        "class": "v-expansion-panel-text__wrapper"
      }, [slots.default?.()])]), [[vShow, expansionPanel.isSelected.value]])]
    }));
    return {};
  }
});
const makeVExpansionPanelTitleProps = propsFactory({
  color: String,
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  hideActions: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: false
  },
  readonly: Boolean,
  ...makeComponentProps()
}, "VExpansionPanelTitle");
const VExpansionPanelTitle = genericComponent()({
  name: "VExpansionPanelTitle",
  directives: {
    Ripple
  },
  props: makeVExpansionPanelTitleProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const expansionPanel = inject$1(VExpansionPanelSymbol);
    if (!expansionPanel)
      throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props2, "color");
    const slotProps = computed(() => ({
      collapseIcon: props2.collapseIcon,
      disabled: expansionPanel.disabled.value,
      expanded: expansionPanel.isSelected.value,
      expandIcon: props2.expandIcon,
      readonly: props2.readonly
    }));
    useRender(() => withDirectives(createVNode("button", {
      "class": ["v-expansion-panel-title", {
        "v-expansion-panel-title--active": expansionPanel.isSelected.value,
        "v-expansion-panel-title--static": props2.static
      }, backgroundColorClasses.value, props2.class],
      "style": [backgroundColorStyles.value, props2.style],
      "type": "button",
      "tabindex": expansionPanel.disabled.value ? -1 : void 0,
      "disabled": expansionPanel.disabled.value,
      "aria-expanded": expansionPanel.isSelected.value,
      "onClick": !props2.readonly ? expansionPanel.toggle : void 0
    }, [createVNode("span", {
      "class": "v-expansion-panel-title__overlay"
    }, null), slots.default?.(slotProps.value), !props2.hideActions && createVNode("span", {
      "class": "v-expansion-panel-title__icon"
    }, [slots.actions ? slots.actions(slotProps.value) : createVNode(VIcon, {
      "icon": expansionPanel.isSelected.value ? props2.collapseIcon : props2.expandIcon
    }, null)])]), [[resolveDirective("ripple"), props2.ripple]]));
    return {};
  }
});
const makeVExpansionPanelProps = propsFactory({
  title: String,
  text: String,
  bgColor: String,
  ...makeComponentProps(),
  ...makeElevationProps(),
  ...makeGroupItemProps(),
  ...makeLazyProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeVExpansionPanelTitleProps()
}, "VExpansionPanel");
const VExpansionPanel = genericComponent()({
  name: "VExpansionPanel",
  props: makeVExpansionPanelProps(),
  emits: {
    "group:selected": (val) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const groupItem = useGroupItem(props2, VExpansionPanelSymbol);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(props2, "bgColor");
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const isDisabled = computed(() => groupItem?.disabled.value || props2.disabled);
    const selectedIndices = computed(() => groupItem.group.items.value.reduce((arr, item, index2) => {
      if (groupItem.group.selected.value.includes(item.id))
        arr.push(index2);
      return arr;
    }, []));
    const isBeforeSelected = computed(() => {
      const index2 = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
      return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index2 === 1);
    });
    const isAfterSelected = computed(() => {
      const index2 = groupItem.group.items.value.findIndex((item) => item.id === groupItem.id);
      return !groupItem.isSelected.value && selectedIndices.value.some((selectedIndex) => selectedIndex - index2 === -1);
    });
    provide(VExpansionPanelSymbol, groupItem);
    provideDefaults({
      VExpansionPanelText: {
        eager: toRef(props2, "eager")
      },
      VExpansionPanelTitle: {
        readonly: toRef(props2, "readonly")
      }
    });
    useRender(() => {
      const hasText = !!(slots.text || props2.text);
      const hasTitle = !!(slots.title || props2.title);
      return createVNode(props2.tag, {
        "class": ["v-expansion-panel", {
          "v-expansion-panel--active": groupItem.isSelected.value,
          "v-expansion-panel--before-active": isBeforeSelected.value,
          "v-expansion-panel--after-active": isAfterSelected.value,
          "v-expansion-panel--disabled": isDisabled.value
        }, roundedClasses.value, backgroundColorClasses.value, props2.class],
        "style": [backgroundColorStyles.value, props2.style]
      }, {
        default: () => [createVNode("div", {
          "class": ["v-expansion-panel__shadow", ...elevationClasses.value]
        }, null), hasTitle && createVNode(VExpansionPanelTitle, {
          "key": "title",
          "collapseIcon": props2.collapseIcon,
          "color": props2.color,
          "expandIcon": props2.expandIcon,
          "hideActions": props2.hideActions,
          "ripple": props2.ripple
        }, {
          default: () => [slots.title ? slots.title() : props2.title]
        }), hasText && createVNode(VExpansionPanelText, {
          "key": "text"
        }, {
          default: () => [slots.text ? slots.text() : props2.text]
        }), slots.default?.()]
      });
    });
    return {};
  }
});
const VFileInput$1 = "";
const makeVFileInputProps = propsFactory({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: false,
    validator: (v) => {
      return typeof v === "boolean" || [1e3, 1024].includes(Number(v));
    }
  },
  ...makeVInputProps({
    prependIcon: "$file"
  }),
  modelValue: {
    type: Array,
    default: () => [],
    validator: (val) => {
      return wrapInArray(val).every((v) => v != null && typeof v === "object");
    }
  },
  ...makeVFieldProps({
    clearable: true
  })
}, "VFileInput");
const VFileInput = genericComponent()({
  name: "VFileInput",
  inheritAttrs: false,
  props: makeVFileInputProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (files) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const base = computed(() => typeof props2.showSize !== "boolean" ? props2.showSize : void 0);
    const totalBytes = computed(() => (model.value ?? []).reduce((bytes, _ref2) => {
      let {
        size: size2 = 0
      } = _ref2;
      return bytes + size2;
    }, 0));
    const totalBytesReadable = computed(() => humanReadableFileSize(totalBytes.value, base.value));
    const fileNames = computed(() => (model.value ?? []).map((file) => {
      const {
        name = "",
        size: size2 = 0
      } = file;
      return !props2.showSize ? name : `${name} (${humanReadableFileSize(size2, base.value)})`;
    }));
    const counterValue = computed(() => {
      const fileCount = model.value?.length ?? 0;
      if (props2.showSize)
        return t(props2.counterSizeString, fileCount, totalBytesReadable.value);
      else
        return t(props2.counterString, fileCount);
    });
    const vInputRef = ref();
    const vFieldRef = ref();
    const inputRef = ref();
    const isActive = computed(() => isFocused.value || props2.active);
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        inputRef.value?.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onClickPrepend(e) {
      onControlClick(e);
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
    }
    function onControlClick(e) {
      inputRef.value?.click();
      emit2("click:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = [];
        callEvent(props2["onClick:clear"], e);
      });
    }
    watch(model, (newValue) => {
      const hasModelReset = !Array.isArray(newValue) || !newValue.length;
      if (hasModelReset && inputRef.value) {
        inputRef.value.value = "";
      }
    });
    useRender(() => {
      const hasCounter = !!(slots.counter || props2.counter);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const {
        modelValue: _,
        ...inputProps
      } = VInput.filterProps(props2);
      const fieldProps = filterFieldProps(props2);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-file-input", {
          "v-file-input--chips": !!props2.chips,
          "v-input--plain-underlined": isPlainOrUnderlined.value
        }, props2.class],
        "style": props2.style,
        "onClick:prepend": onClickPrepend
      }, rootAttrs, inputProps, {
        "centerAffix": !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref3) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref3;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "prepend-icon": props2.prependIcon,
            "onMousedown": onControlMousedown,
            "onClick": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": props2["onClick:prependInner"],
            "onClick:appendInner": props2["onClick:appendInner"]
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref4) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref4;
              return createVNode(Fragment, null, [createVNode("input", mergeProps({
                "ref": inputRef,
                "type": "file",
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "multiple": props2.multiple,
                "name": props2.name,
                "onClick": (e) => {
                  e.stopPropagation();
                  if (isReadonly2.value)
                    e.preventDefault();
                  onFocus();
                },
                "onChange": (e) => {
                  if (!e.target)
                    return;
                  const target = e.target;
                  model.value = [...target.files ?? []];
                },
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), createVNode("div", {
                "class": fieldClass
              }, [!!model.value?.length && (slots.selection ? slots.selection({
                fileNames: fileNames.value,
                totalBytes: totalBytes.value,
                totalBytesReadable: totalBytesReadable.value
              }) : props2.chips ? fileNames.value.map((text) => createVNode(VChip, {
                "key": text,
                "size": "small",
                "color": props2.color
              }, {
                default: () => [text]
              })) : fileNames.value.join(", "))])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => createVNode(Fragment, null, [slots.details?.(slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": !!model.value?.length,
          "value": counterValue.value
        }, slots.counter)])]) : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, inputRef);
  }
});
const makeVFormProps = propsFactory({
  ...makeComponentProps(),
  ...makeFormProps()
}, "VForm");
const VForm = genericComponent()({
  name: "VForm",
  props: makeVFormProps(),
  emits: {
    "update:modelValue": (val) => true,
    submit: (e) => true
  },
  setup(props2, _ref) {
    let {
      slots,
      emit: emit2
    } = _ref;
    const form = createForm(props2);
    const formRef = ref();
    function onReset(e) {
      e.preventDefault();
      form.reset();
    }
    function onSubmit(_e2) {
      const e = _e2;
      const ready = form.validate();
      e.then = ready.then.bind(ready);
      e.catch = ready.catch.bind(ready);
      e.finally = ready.finally.bind(ready);
      emit2("submit", e);
      if (!e.defaultPrevented) {
        ready.then((_ref2) => {
          let {
            valid
          } = _ref2;
          if (valid) {
            formRef.value?.submit();
          }
        });
      }
      e.preventDefault();
    }
    useRender(() => createVNode("form", {
      "ref": formRef,
      "class": ["v-form", props2.class],
      "style": props2.style,
      "novalidate": true,
      "onReset": onReset,
      "onSubmit": onSubmit
    }, [slots.default?.(form)]));
    return forwardRefs(form, formRef);
  }
});
const makeVHoverProps = propsFactory({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: void 0
  },
  ...makeDelayProps()
}, "VHover");
const VHover = genericComponent()({
  name: "VHover",
  props: makeVHoverProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isHovering = useProxiedModel(props2, "modelValue");
    const {
      runOpenDelay,
      runCloseDelay
    } = useDelay(props2, (value) => !props2.disabled && (isHovering.value = value));
    return () => slots.default?.({
      isHovering: isHovering.value,
      props: {
        onMouseenter: runOpenDelay,
        onMouseleave: runCloseDelay
      }
    });
  }
});
const VMain$1 = "";
const makeVMainProps = propsFactory({
  scrollable: Boolean,
  ...makeComponentProps(),
  ...makeTagProps({
    tag: "main"
  })
}, "VMain");
const VMain = genericComponent()({
  name: "VMain",
  props: makeVMainProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      mainStyles
    } = useLayout();
    const {
      ssrBootStyles
    } = useSsrBoot();
    useRender(() => createVNode(props2.tag, {
      "class": ["v-main", {
        "v-main--scrollable": props2.scrollable
      }, props2.class],
      "style": [mainStyles.value, ssrBootStyles.value, props2.style]
    }, {
      default: () => [props2.scrollable ? createVNode("div", {
        "class": "v-main__scroller"
      }, [slots.default?.()]) : slots.default?.()]
    }));
    return {};
  }
});
const VNavigationDrawer$1 = "";
function useSticky(_ref) {
  let {
    rootEl,
    isSticky,
    layoutItemStyles
  } = _ref;
  const isStuck = shallowRef(false);
  const stuckPosition = shallowRef(0);
  const stickyStyles = computed(() => {
    const side = typeof isStuck.value === "boolean" ? "top" : isStuck.value;
    return [isSticky.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, isStuck.value ? {
      [side]: convertToUnit(stuckPosition.value)
    } : {
      top: layoutItemStyles.value.top
    }];
  });
  onMounted(() => {
    watch(isSticky, (val) => {
      if (val) {
        window.addEventListener("scroll", onScroll, {
          passive: true
        });
      } else {
        window.removeEventListener("scroll", onScroll);
      }
    }, {
      immediate: true
    });
  });
  onBeforeUnmount(() => {
    window.removeEventListener("scroll", onScroll);
  });
  let lastScrollTop = 0;
  function onScroll() {
    const direction = lastScrollTop > window.scrollY ? "up" : "down";
    const rect = rootEl.value.getBoundingClientRect();
    const layoutTop = parseFloat(layoutItemStyles.value.top ?? 0);
    const top = window.scrollY - Math.max(0, stuckPosition.value - layoutTop);
    const bottom = rect.height + Math.max(stuckPosition.value, layoutTop) - window.scrollY - window.innerHeight;
    const bodyScroll = parseFloat(getComputedStyle(rootEl.value).getPropertyValue("--v-body-scroll-y")) || 0;
    if (rect.height < window.innerHeight - layoutTop) {
      isStuck.value = "top";
      stuckPosition.value = layoutTop;
    } else if (direction === "up" && isStuck.value === "bottom" || direction === "down" && isStuck.value === "top") {
      stuckPosition.value = window.scrollY + rect.top - bodyScroll;
      isStuck.value = true;
    } else if (direction === "down" && bottom <= 0) {
      stuckPosition.value = 0;
      isStuck.value = "bottom";
    } else if (direction === "up" && top <= 0) {
      if (!bodyScroll) {
        stuckPosition.value = rect.top + top;
        isStuck.value = "top";
      } else if (isStuck.value !== "top") {
        stuckPosition.value = -top + bodyScroll + layoutTop;
        isStuck.value = "top";
      }
    }
    lastScrollTop = window.scrollY;
  }
  return {
    isStuck,
    stickyStyles
  };
}
const HORIZON = 100;
const HISTORY = 20;
function kineticEnergyToVelocity(work) {
  const sqrt2 = 1.41421356237;
  return (work < 0 ? -1 : 1) * Math.sqrt(Math.abs(work)) * sqrt2;
}
function calculateImpulseVelocity(samples) {
  if (samples.length < 2) {
    return 0;
  }
  if (samples.length === 2) {
    if (samples[1].t === samples[0].t) {
      return 0;
    }
    return (samples[1].d - samples[0].d) / (samples[1].t - samples[0].t);
  }
  let work = 0;
  for (let i = samples.length - 1; i > 0; i--) {
    if (samples[i].t === samples[i - 1].t) {
      continue;
    }
    const vprev = kineticEnergyToVelocity(work);
    const vcurr = (samples[i].d - samples[i - 1].d) / (samples[i].t - samples[i - 1].t);
    work += (vcurr - vprev) * Math.abs(vcurr);
    if (i === samples.length - 1) {
      work *= 0.5;
    }
  }
  return kineticEnergyToVelocity(work) * 1e3;
}
function useVelocity() {
  const touches = {};
  function addMovement(e) {
    Array.from(e.changedTouches).forEach((touch) => {
      const samples = touches[touch.identifier] ?? (touches[touch.identifier] = new CircularBuffer(HISTORY));
      samples.push([e.timeStamp, touch]);
    });
  }
  function endTouch(e) {
    Array.from(e.changedTouches).forEach((touch) => {
      delete touches[touch.identifier];
    });
  }
  function getVelocity(id) {
    const samples = touches[id]?.values().reverse();
    if (!samples) {
      throw new Error(`No samples for touch id ${id}`);
    }
    const newest = samples[0];
    const x2 = [];
    const y = [];
    for (const val of samples) {
      if (newest[0] - val[0] > HORIZON)
        break;
      x2.push({
        t: val[0],
        d: val[1].clientX
      });
      y.push({
        t: val[0],
        d: val[1].clientY
      });
    }
    return {
      x: calculateImpulseVelocity(x2),
      y: calculateImpulseVelocity(y),
      get direction() {
        const {
          x: x3,
          y: y2
        } = this;
        const [absX, absY] = [Math.abs(x3), Math.abs(y2)];
        return absX > absY && x3 >= 0 ? "right" : absX > absY && x3 <= 0 ? "left" : absY > absX && y2 >= 0 ? "down" : absY > absX && y2 <= 0 ? "up" : oops$1();
      }
    };
  }
  return {
    addMovement,
    endTouch,
    getVelocity
  };
}
function oops$1() {
  throw new Error();
}
function useTouch(_ref) {
  let {
    isActive,
    isTemporary,
    width,
    touchless,
    position
  } = _ref;
  onMounted(() => {
    window.addEventListener("touchstart", onTouchstart, {
      passive: true
    });
    window.addEventListener("touchmove", onTouchmove, {
      passive: false
    });
    window.addEventListener("touchend", onTouchend, {
      passive: true
    });
  });
  onBeforeUnmount(() => {
    window.removeEventListener("touchstart", onTouchstart);
    window.removeEventListener("touchmove", onTouchmove);
    window.removeEventListener("touchend", onTouchend);
  });
  const isHorizontal = computed(() => ["left", "right"].includes(position.value));
  const {
    addMovement,
    endTouch,
    getVelocity
  } = useVelocity();
  let maybeDragging = false;
  const isDragging = shallowRef(false);
  const dragProgress = shallowRef(0);
  const offset = shallowRef(0);
  let start;
  function getOffset2(pos, active) {
    return (position.value === "left" ? pos : position.value === "right" ? document.documentElement.clientWidth - pos : position.value === "top" ? pos : position.value === "bottom" ? document.documentElement.clientHeight - pos : oops()) - (active ? width.value : 0);
  }
  function getProgress(pos) {
    let limit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    const progress = position.value === "left" ? (pos - offset.value) / width.value : position.value === "right" ? (document.documentElement.clientWidth - pos - offset.value) / width.value : position.value === "top" ? (pos - offset.value) / width.value : position.value === "bottom" ? (document.documentElement.clientHeight - pos - offset.value) / width.value : oops();
    return limit ? Math.max(0, Math.min(1, progress)) : progress;
  }
  function onTouchstart(e) {
    if (touchless.value)
      return;
    const touchX = e.changedTouches[0].clientX;
    const touchY = e.changedTouches[0].clientY;
    const touchZone = 25;
    const inTouchZone = position.value === "left" ? touchX < touchZone : position.value === "right" ? touchX > document.documentElement.clientWidth - touchZone : position.value === "top" ? touchY < touchZone : position.value === "bottom" ? touchY > document.documentElement.clientHeight - touchZone : oops();
    const inElement = isActive.value && (position.value === "left" ? touchX < width.value : position.value === "right" ? touchX > document.documentElement.clientWidth - width.value : position.value === "top" ? touchY < width.value : position.value === "bottom" ? touchY > document.documentElement.clientHeight - width.value : oops());
    if (inTouchZone || inElement || isActive.value && isTemporary.value) {
      maybeDragging = true;
      start = [touchX, touchY];
      offset.value = getOffset2(isHorizontal.value ? touchX : touchY, isActive.value);
      dragProgress.value = getProgress(isHorizontal.value ? touchX : touchY);
      endTouch(e);
      addMovement(e);
    }
  }
  function onTouchmove(e) {
    const touchX = e.changedTouches[0].clientX;
    const touchY = e.changedTouches[0].clientY;
    if (maybeDragging) {
      if (!e.cancelable) {
        maybeDragging = false;
        return;
      }
      const dx = Math.abs(touchX - start[0]);
      const dy = Math.abs(touchY - start[1]);
      const thresholdMet = isHorizontal.value ? dx > dy && dx > 3 : dy > dx && dy > 3;
      if (thresholdMet) {
        isDragging.value = true;
        maybeDragging = false;
      } else if ((isHorizontal.value ? dy : dx) > 3) {
        maybeDragging = false;
      }
    }
    if (!isDragging.value)
      return;
    e.preventDefault();
    addMovement(e);
    const progress = getProgress(isHorizontal.value ? touchX : touchY, false);
    dragProgress.value = Math.max(0, Math.min(1, progress));
    if (progress > 1) {
      offset.value = getOffset2(isHorizontal.value ? touchX : touchY, true);
    } else if (progress < 0) {
      offset.value = getOffset2(isHorizontal.value ? touchX : touchY, false);
    }
  }
  function onTouchend(e) {
    maybeDragging = false;
    if (!isDragging.value)
      return;
    addMovement(e);
    isDragging.value = false;
    const velocity = getVelocity(e.changedTouches[0].identifier);
    const vx = Math.abs(velocity.x);
    const vy = Math.abs(velocity.y);
    const thresholdMet = isHorizontal.value ? vx > vy && vx > 400 : vy > vx && vy > 3;
    if (thresholdMet) {
      isActive.value = velocity.direction === ({
        left: "right",
        right: "left",
        top: "down",
        bottom: "up"
      }[position.value] || oops());
    } else {
      isActive.value = dragProgress.value > 0.5;
    }
  }
  const dragStyles = computed(() => {
    return isDragging.value ? {
      transform: position.value === "left" ? `translateX(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "right" ? `translateX(calc(100% - ${dragProgress.value * width.value}px))` : position.value === "top" ? `translateY(calc(-100% + ${dragProgress.value * width.value}px))` : position.value === "bottom" ? `translateY(calc(100% - ${dragProgress.value * width.value}px))` : oops(),
      transition: "none"
    } : void 0;
  });
  return {
    isDragging,
    dragProgress,
    dragStyles
  };
}
function oops() {
  throw new Error();
}
const locations = ["start", "end", "left", "right", "top", "bottom"];
const makeVNavigationDrawerProps = propsFactory({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: true
  },
  image: String,
  temporary: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (value) => locations.includes(value)
  },
  sticky: Boolean,
  ...makeBorderProps(),
  ...makeComponentProps(),
  ...makeDisplayProps(),
  ...makeElevationProps(),
  ...makeLayoutItemProps(),
  ...makeRoundedProps(),
  ...makeTagProps({
    tag: "nav"
  }),
  ...makeThemeProps()
}, "VNavigationDrawer");
const VNavigationDrawer = genericComponent()({
  name: "VNavigationDrawer",
  props: makeVNavigationDrawerProps(),
  emits: {
    "update:modelValue": (val) => true,
    "update:rail": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      borderClasses
    } = useBorder(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      displayClasses,
      mobile
    } = useDisplay(props2);
    const {
      roundedClasses
    } = useRounded(props2);
    const router2 = useRouter$1();
    const isActive = useProxiedModel(props2, "modelValue", null, (v) => !!v);
    const {
      ssrBootStyles
    } = useSsrBoot();
    const {
      scopeId
    } = useScopeId();
    const rootEl = ref();
    const isHovering = shallowRef(false);
    const width = computed(() => {
      return props2.rail && props2.expandOnHover && isHovering.value ? Number(props2.width) : Number(props2.rail ? props2.railWidth : props2.width);
    });
    const location2 = computed(() => {
      return toPhysical(props2.location, isRtl.value);
    });
    const isTemporary = computed(() => !props2.permanent && (mobile.value || props2.temporary));
    const isSticky = computed(() => props2.sticky && !isTemporary.value && location2.value !== "bottom");
    useToggleScope(() => props2.expandOnHover && props2.rail != null, () => {
      watch(isHovering, (val) => emit2("update:rail", !val));
    });
    useToggleScope(() => !props2.disableResizeWatcher, () => {
      watch(isTemporary, (val) => !props2.permanent && nextTick(() => isActive.value = !val));
    });
    useToggleScope(() => !props2.disableRouteWatcher && !!router2, () => {
      watch(router2.currentRoute, () => isTemporary.value && (isActive.value = false));
    });
    watch(() => props2.permanent, (val) => {
      if (val)
        isActive.value = true;
    });
    onBeforeMount(() => {
      if (props2.modelValue != null || isTemporary.value)
        return;
      isActive.value = props2.permanent || !mobile.value;
    });
    const {
      isDragging,
      dragProgress,
      dragStyles
    } = useTouch({
      isActive,
      isTemporary,
      width,
      touchless: toRef(props2, "touchless"),
      position: location2
    });
    const layoutSize = computed(() => {
      const size2 = isTemporary.value ? 0 : props2.rail && props2.expandOnHover ? Number(props2.railWidth) : width.value;
      return isDragging.value ? size2 * dragProgress.value : size2;
    });
    const {
      layoutItemStyles,
      layoutItemScrimStyles
    } = useLayoutItem({
      id: props2.name,
      order: computed(() => parseInt(props2.order, 10)),
      position: location2,
      layoutSize,
      elementSize: width,
      active: computed(() => isActive.value || isDragging.value),
      disableTransitions: computed(() => isDragging.value),
      absolute: computed(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        props2.absolute || isSticky.value && typeof isStuck.value !== "string"
      ))
    });
    const {
      isStuck,
      stickyStyles
    } = useSticky({
      rootEl,
      isSticky,
      layoutItemStyles
    });
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props2.scrim === "string" ? props2.scrim : null;
    }));
    const scrimStyles = computed(() => ({
      ...isDragging.value ? {
        opacity: dragProgress.value * 0.2,
        transition: "none"
      } : void 0,
      ...layoutItemScrimStyles.value
    }));
    provideDefaults({
      VList: {
        bgColor: "transparent"
      }
    });
    function onMouseenter() {
      isHovering.value = true;
    }
    function onMouseleave() {
      isHovering.value = false;
    }
    useRender(() => {
      const hasImage = slots.image || props2.image;
      return createVNode(Fragment, null, [createVNode(props2.tag, mergeProps({
        "ref": rootEl,
        "onMouseenter": onMouseenter,
        "onMouseleave": onMouseleave,
        "class": ["v-navigation-drawer", `v-navigation-drawer--${location2.value}`, {
          "v-navigation-drawer--expand-on-hover": props2.expandOnHover,
          "v-navigation-drawer--floating": props2.floating,
          "v-navigation-drawer--is-hovering": isHovering.value,
          "v-navigation-drawer--rail": props2.rail,
          "v-navigation-drawer--temporary": isTemporary.value,
          "v-navigation-drawer--active": isActive.value,
          "v-navigation-drawer--sticky": isSticky.value
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, displayClasses.value, elevationClasses.value, roundedClasses.value, props2.class],
        "style": [backgroundColorStyles.value, layoutItemStyles.value, dragStyles.value, ssrBootStyles.value, stickyStyles.value, props2.style]
      }, scopeId, attrs), {
        default: () => [hasImage && createVNode("div", {
          "key": "image",
          "class": "v-navigation-drawer__img"
        }, [slots.image ? slots.image?.({
          image: props2.image
        }) : createVNode("img", {
          "src": props2.image,
          "alt": ""
        }, null)]), slots.prepend && createVNode("div", {
          "class": "v-navigation-drawer__prepend"
        }, [slots.prepend?.()]), createVNode("div", {
          "class": "v-navigation-drawer__content"
        }, [slots.default?.()]), slots.append && createVNode("div", {
          "class": "v-navigation-drawer__append"
        }, [slots.append?.()])]
      }), createVNode(Transition, {
        "name": "fade-transition"
      }, {
        default: () => [isTemporary.value && (isDragging.value || isActive.value) && !!props2.scrim && createVNode("div", mergeProps({
          "class": ["v-navigation-drawer__scrim", scrimColor.backgroundColorClasses.value],
          "style": [scrimStyles.value, scrimColor.backgroundColorStyles.value],
          "onClick": () => isActive.value = false
        }, scopeId), null)]
      })]);
    });
    return {
      isStuck
    };
  }
});
const makeVRadioProps = propsFactory({
  ...makeVSelectionControlProps({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio");
const VRadio = genericComponent()({
  name: "VRadio",
  props: makeVRadioProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VSelectionControl, mergeProps(props2, {
      "class": ["v-radio", props2.class],
      "style": props2.style,
      "type": "radio"
    }), slots));
    return {};
  }
});
const VRadioGroup$1 = "";
const makeVRadioGroupProps = propsFactory({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...makeVInputProps(),
  ...omit(makeSelectionControlGroupProps(), ["multiple"]),
  trueIcon: {
    type: IconValue,
    default: "$radioOn"
  },
  falseIcon: {
    type: IconValue,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup");
const VRadioGroup = genericComponent()({
  name: "VRadioGroup",
  inheritAttrs: false,
  props: makeVRadioGroupProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const uid2 = getUid();
    const id = computed(() => props2.id || `radio-group-${uid2}`);
    const model = useProxiedModel(props2, "modelValue");
    useRender(() => {
      const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
      const inputProps = VInput.filterProps(props2);
      const controlProps = VSelectionControl.filterProps(props2);
      const label = slots.label ? slots.label({
        label: props2.label,
        props: {
          for: id.value
        }
      }) : props2.label;
      return createVNode(VInput, mergeProps({
        "class": ["v-radio-group", props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "id": id.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2
          } = _ref2;
          return createVNode(Fragment, null, [label && createVNode(VLabel, {
            "id": id2.value
          }, {
            default: () => [label]
          }), createVNode(VSelectionControlGroup, mergeProps(controlProps, {
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "defaultsTarget": "VRadio",
            "trueIcon": props2.trueIcon,
            "falseIcon": props2.falseIcon,
            "type": props2.type,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value,
            "aria-labelledby": label ? id2.value : void 0,
            "multiple": false
          }, controlAttrs, {
            "modelValue": model.value,
            "onUpdate:modelValue": ($event) => model.value = $event
          }), slots)]);
        }
      });
    });
    return {};
  }
});
const VSkeletonLoader$1 = "";
const rootTypes = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function genBone(type) {
  let children = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return createVNode("div", {
    "class": ["v-skeleton-loader__bone", `v-skeleton-loader__${type}`]
  }, [children]);
}
function genBones(bone) {
  const [type, length] = bone.split("@");
  return Array.from({
    length
  }).map(() => genStructure(type));
}
function genStructure(type) {
  let children = [];
  if (!type)
    return children;
  const bone = rootTypes[type];
  if (type === bone)
    ;
  else if (type.includes(","))
    return mapBones(type);
  else if (type.includes("@"))
    return genBones(type);
  else if (bone.includes(","))
    children = mapBones(bone);
  else if (bone.includes("@"))
    children = genBones(bone);
  else if (bone)
    children.push(genStructure(bone));
  return [genBone(type, children)];
}
function mapBones(bones) {
  return bones.replace(/\s/g, "").split(",").map(genStructure);
}
const makeVSkeletonLoaderProps = propsFactory({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...makeDimensionProps(),
  ...makeElevationProps(),
  ...makeThemeProps()
}, "VSkeletonLoader");
const VSkeletonLoader = genericComponent()({
  name: "VSkeletonLoader",
  props: makeVSkeletonLoaderProps(),
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "color"));
    const {
      dimensionStyles
    } = useDimension(props2);
    const {
      elevationClasses
    } = useElevation(props2);
    const {
      themeClasses
    } = provideTheme(props2);
    const {
      t
    } = useLocale();
    const items = computed(() => genStructure(wrapInArray(props2.type).join(",")));
    useRender(() => {
      const isLoading = !slots.default || props2.loading;
      return createVNode("div", {
        "class": ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": props2.boilerplate
        }, themeClasses.value, backgroundColorClasses.value, elevationClasses.value],
        "style": [backgroundColorStyles.value, isLoading ? dimensionStyles.value : {}],
        "aria-busy": !props2.boilerplate ? isLoading : void 0,
        "aria-live": !props2.boilerplate ? "polite" : void 0,
        "aria-label": !props2.boilerplate ? t(props2.loadingText) : void 0,
        "role": !props2.boilerplate ? "alert" : void 0
      }, [isLoading ? items.value : slots.default?.()]);
    });
    return {};
  }
});
const VSwitch$1 = "";
const makeVSwitchProps = propsFactory({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: false
  },
  ...makeVInputProps(),
  ...makeVSelectionControlProps()
}, "VSwitch");
const VSwitch = genericComponent()({
  name: "VSwitch",
  inheritAttrs: false,
  props: makeVSwitchProps(),
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": (value) => true,
    "update:indeterminate": (value) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props2, "indeterminate");
    const model = useProxiedModel(props2, "modelValue");
    const {
      loaderClasses
    } = useLoader(props2);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const control = ref();
    const loaderColor = computed(() => {
      return typeof props2.loading === "string" && props2.loading !== "" ? props2.loading : props2.color;
    });
    const uid2 = getUid();
    const id = computed(() => props2.id || `switch-${uid2}`);
    function onChange() {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    function onTrackClick(e) {
      e.stopPropagation();
      e.preventDefault();
      control.value?.input?.click();
    }
    useRender(() => {
      const [rootAttrs, controlAttrs] = filterInputAttrs(attrs);
      const inputProps = VInput.filterProps(props2);
      const controlProps = VSelectionControl.filterProps(props2);
      return createVNode(VInput, mergeProps({
        "class": ["v-switch", {
          "v-switch--inset": props2.inset
        }, {
          "v-switch--indeterminate": indeterminate.value
        }, loaderClasses.value, props2.class]
      }, rootAttrs, inputProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "id": id.value,
        "focused": isFocused.value,
        "style": props2.style
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          const slotProps = {
            model,
            isValid: isValid2
          };
          return createVNode(VSelectionControl, mergeProps({
            "ref": control
          }, controlProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": [($event) => model.value = $event, onChange],
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "type": "checkbox",
            "aria-checked": indeterminate.value ? "mixed" : void 0,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value,
            "onFocus": focus,
            "onBlur": blur
          }, controlAttrs), {
            ...slots,
            default: (_ref3) => {
              let {
                backgroundColorClasses,
                backgroundColorStyles
              } = _ref3;
              return createVNode("div", {
                "class": ["v-switch__track", ...backgroundColorClasses.value],
                "style": backgroundColorStyles.value,
                "onClick": onTrackClick
              }, [slots["track-true"] && createVNode("div", {
                "key": "prepend",
                "class": "v-switch__track-true"
              }, [slots["track-true"](slotProps)]), slots["track-false"] && createVNode("div", {
                "key": "append",
                "class": "v-switch__track-false"
              }, [slots["track-false"](slotProps)])]);
            },
            input: (_ref4) => {
              let {
                inputNode,
                icon,
                backgroundColorClasses,
                backgroundColorStyles
              } = _ref4;
              return createVNode(Fragment, null, [inputNode, createVNode("div", {
                "class": ["v-switch__thumb", {
                  "v-switch__thumb--filled": icon || props2.loading
                }, props2.inset ? void 0 : backgroundColorClasses.value],
                "style": props2.inset ? void 0 : backgroundColorStyles.value
              }, [slots.thumb ? createVNode(VDefaultsProvider, {
                "defaults": {
                  VIcon: {
                    icon,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [slots.thumb({
                  ...slotProps,
                  icon
                })]
              }) : createVNode(VScaleTransition, null, {
                default: () => [!props2.loading ? icon && createVNode(VIcon, {
                  "key": String(icon),
                  "icon": icon,
                  "size": "x-small"
                }, null) : createVNode(LoaderSlot, {
                  "name": "v-switch",
                  "active": true,
                  "color": isValid2.value === false ? void 0 : loaderColor.value
                }, {
                  default: (slotProps2) => slots.loader ? slots.loader(slotProps2) : createVNode(VProgressCircular, {
                    "active": slotProps2.isActive,
                    "color": slotProps2.color,
                    "indeterminate": true,
                    "size": "16",
                    "width": "2"
                  }, null)
                })]
              })])]);
            }
          });
        }
      });
    });
    return {};
  }
});
const VTabs$1 = "";
const VTab$1 = "";
const VTabsSymbol = Symbol.for("vuetify:v-tabs");
const makeVTabProps = propsFactory({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...omit(makeVBtnProps({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab");
const VTab = genericComponent()({
  name: "VTab",
  props: makeVTabProps(),
  setup(props2, _ref) {
    let {
      slots,
      attrs
    } = _ref;
    const {
      textColorClasses: sliderColorClasses,
      textColorStyles: sliderColorStyles
    } = useTextColor(props2, "sliderColor");
    const rootEl = ref();
    const sliderEl = ref();
    const isHorizontal = computed(() => props2.direction === "horizontal");
    const isSelected = computed(() => rootEl.value?.group?.isSelected.value ?? false);
    function updateSlider(_ref2) {
      let {
        value
      } = _ref2;
      if (value) {
        const prevEl = rootEl.value?.$el.parentElement?.querySelector(".v-tab--selected .v-tab__slider");
        const nextEl = sliderEl.value;
        if (!prevEl || !nextEl)
          return;
        const color = getComputedStyle(prevEl).color;
        const prevBox = prevEl.getBoundingClientRect();
        const nextBox = nextEl.getBoundingClientRect();
        const xy = isHorizontal.value ? "x" : "y";
        const XY = isHorizontal.value ? "X" : "Y";
        const rightBottom = isHorizontal.value ? "right" : "bottom";
        const widthHeight = isHorizontal.value ? "width" : "height";
        const prevPos = prevBox[xy];
        const nextPos = nextBox[xy];
        const delta2 = prevPos > nextPos ? prevBox[rightBottom] - nextBox[rightBottom] : prevBox[xy] - nextBox[xy];
        const origin = Math.sign(delta2) > 0 ? isHorizontal.value ? "right" : "bottom" : Math.sign(delta2) < 0 ? isHorizontal.value ? "left" : "top" : "center";
        const size2 = Math.abs(delta2) + (Math.sign(delta2) < 0 ? prevBox[widthHeight] : nextBox[widthHeight]);
        const scale = size2 / Math.max(prevBox[widthHeight], nextBox[widthHeight]) || 0;
        const initialScale = prevBox[widthHeight] / nextBox[widthHeight] || 0;
        const sigma = 1.5;
        animate(nextEl, {
          backgroundColor: [color, "currentcolor"],
          transform: [`translate${XY}(${delta2}px) scale${XY}(${initialScale})`, `translate${XY}(${delta2 / sigma}px) scale${XY}(${(scale - 1) / sigma + 1})`, "none"],
          transformOrigin: Array(3).fill(origin)
        }, {
          duration: 225,
          easing: standardEasing
        });
      }
    }
    useRender(() => {
      const btnProps = VBtn.filterProps(props2);
      return createVNode(VBtn, mergeProps({
        "symbol": VTabsSymbol,
        "ref": rootEl,
        "class": ["v-tab", props2.class],
        "style": props2.style,
        "tabindex": isSelected.value ? 0 : -1,
        "role": "tab",
        "aria-selected": String(isSelected.value),
        "active": false
      }, btnProps, attrs, {
        "block": props2.fixed,
        "maxWidth": props2.fixed ? 300 : void 0,
        "onGroup:selected": updateSlider
      }), {
        ...slots,
        default: () => createVNode(Fragment, null, [slots.default?.() ?? props2.text, !props2.hideSlider && createVNode("div", {
          "ref": sliderEl,
          "class": ["v-tab__slider", sliderColorClasses.value],
          "style": sliderColorStyles.value
        }, null)])
      });
    });
    return forwardRefs({}, rootEl);
  }
});
function parseItems(items) {
  if (!items)
    return [];
  return items.map((item) => {
    if (!isObject(item))
      return {
        text: item,
        value: item
      };
    return item;
  });
}
const makeVTabsProps = propsFactory({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...makeVSlideGroupProps({
    mandatory: "force"
  }),
  ...makeDensityProps(),
  ...makeTagProps()
}, "VTabs");
const VTabs = genericComponent()({
  name: "VTabs",
  props: makeVTabsProps(),
  emits: {
    "update:modelValue": (v) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const parsedItems = computed(() => parseItems(props2.items));
    const {
      densityClasses
    } = useDensity(props2);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props2, "bgColor"));
    provideDefaults({
      VTab: {
        color: toRef(props2, "color"),
        direction: toRef(props2, "direction"),
        stacked: toRef(props2, "stacked"),
        fixed: toRef(props2, "fixedTabs"),
        sliderColor: toRef(props2, "sliderColor"),
        hideSlider: toRef(props2, "hideSlider")
      }
    });
    useRender(() => {
      const slideGroupProps = VSlideGroup.filterProps(props2);
      return createVNode(VSlideGroup, mergeProps(slideGroupProps, {
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-tabs", `v-tabs--${props2.direction}`, `v-tabs--align-tabs-${props2.alignTabs}`, {
          "v-tabs--fixed-tabs": props2.fixedTabs,
          "v-tabs--grow": props2.grow,
          "v-tabs--stacked": props2.stacked
        }, densityClasses.value, backgroundColorClasses.value, props2.class],
        "style": [{
          "--v-tabs-height": convertToUnit(props2.height)
        }, backgroundColorStyles.value, props2.style],
        "role": "tablist",
        "symbol": VTabsSymbol
      }), {
        default: () => [slots.default ? slots.default() : parsedItems.value.map((item) => createVNode(VTab, mergeProps(item, {
          "key": item.text
        }), null))]
      });
    });
    return {};
  }
});
const VTextarea$1 = "";
const makeVTextareaProps = propsFactory({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (v) => !isNaN(parseFloat(v))
  },
  maxRows: {
    type: [Number, String],
    validator: (v) => !isNaN(parseFloat(v))
  },
  suffix: String,
  modelModifiers: Object,
  ...makeVInputProps(),
  ...makeVFieldProps()
}, "VTextarea");
const VTextarea = genericComponent()({
  name: "VTextarea",
  directives: {
    Intersect: Intersect$1
  },
  inheritAttrs: false,
  props: makeVTextareaProps(),
  emits: {
    "click:control": (e) => true,
    "mousedown:control": (e) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props2, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const model = useProxiedModel(props2, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props2);
    const counterValue = computed(() => {
      return typeof props2.counterValue === "function" ? props2.counterValue(model.value) : (model.value || "").toString().length;
    });
    const max = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props2.counter || typeof props2.counter !== "number" && typeof props2.counter !== "string")
        return void 0;
      return props2.counter;
    });
    function onIntersect(isIntersecting, entries) {
      if (!props2.autofocus || !isIntersecting)
        return;
      entries[0].target?.focus?.();
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const controlHeight = shallowRef("");
    const textareaRef = ref();
    const isActive = computed(() => props2.persistentPlaceholder || isFocused.value || props2.active);
    function onFocus() {
      if (textareaRef.value !== document.activeElement) {
        textareaRef.value?.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onControlClick(e) {
      onFocus();
      emit2("click:control", e);
    }
    function onControlMousedown(e) {
      emit2("mousedown:control", e);
    }
    function onClear(e) {
      e.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = "";
        callEvent(props2["onClick:clear"], e);
      });
    }
    function onInput(e) {
      const el = e.target;
      model.value = el.value;
      if (props2.modelModifiers?.trim) {
        const caretPosition = [el.selectionStart, el.selectionEnd];
        nextTick(() => {
          el.selectionStart = caretPosition[0];
          el.selectionEnd = caretPosition[1];
        });
      }
    }
    const sizerRef = ref();
    const rows = ref(+props2.rows);
    const isPlainOrUnderlined = computed(() => ["plain", "underlined"].includes(props2.variant));
    watchEffect(() => {
      if (!props2.autoGrow)
        rows.value = +props2.rows;
    });
    function calculateInputHeight() {
      if (!props2.autoGrow)
        return;
      nextTick(() => {
        if (!sizerRef.value || !vFieldRef.value)
          return;
        const style3 = getComputedStyle(sizerRef.value);
        const fieldStyle = getComputedStyle(vFieldRef.value.$el);
        const padding = parseFloat(style3.getPropertyValue("--v-field-padding-top")) + parseFloat(style3.getPropertyValue("--v-input-padding-top")) + parseFloat(style3.getPropertyValue("--v-field-padding-bottom"));
        const height = sizerRef.value.scrollHeight;
        const lineHeight = parseFloat(style3.lineHeight);
        const minHeight = Math.max(parseFloat(props2.rows) * lineHeight + padding, parseFloat(fieldStyle.getPropertyValue("--v-input-control-height")));
        const maxHeight = parseFloat(props2.maxRows) * lineHeight + padding || Infinity;
        const newHeight = clamp(height ?? 0, minHeight, maxHeight);
        rows.value = Math.floor((newHeight - padding) / lineHeight);
        controlHeight.value = convertToUnit(newHeight);
      });
    }
    onMounted(calculateInputHeight);
    watch(model, calculateInputHeight);
    watch(() => props2.rows, calculateInputHeight);
    watch(() => props2.maxRows, calculateInputHeight);
    watch(() => props2.density, calculateInputHeight);
    let observer;
    watch(sizerRef, (val) => {
      if (val) {
        observer = new ResizeObserver(calculateInputHeight);
        observer.observe(sizerRef.value);
      } else {
        observer?.disconnect();
      }
    });
    onBeforeUnmount(() => {
      observer?.disconnect();
    });
    useRender(() => {
      const hasCounter = !!(slots.counter || props2.counter || props2.counterValue);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const {
        modelValue: _,
        ...inputProps
      } = VInput.filterProps(props2);
      const fieldProps = filterFieldProps(props2);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-textarea v-text-field", {
          "v-textarea--prefixed": props2.prefix,
          "v-textarea--suffixed": props2.suffix,
          "v-text-field--prefixed": props2.prefix,
          "v-text-field--suffixed": props2.suffix,
          "v-textarea--auto-grow": props2.autoGrow,
          "v-textarea--no-resize": props2.noResize || props2.autoGrow,
          "v-input--plain-underlined": isPlainOrUnderlined.value
        }, props2.class],
        "style": props2.style
      }, rootAttrs, inputProps, {
        "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "style": {
              "--v-textarea-control-height": controlHeight.value
            },
            "onClick": onControlClick,
            "onMousedown": onControlMousedown,
            "onClick:clear": onClear,
            "onClick:prependInner": props2["onClick:prependInner"],
            "onClick:appendInner": props2["onClick:appendInner"]
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "centerAffix": rows.value === 1 && !isPlainOrUnderlined.value,
            "dirty": isDirty.value || props2.dirty,
            "disabled": isDisabled.value,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref3;
              return createVNode(Fragment, null, [props2.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [props2.prefix]), withDirectives(createVNode("textarea", mergeProps({
                "ref": textareaRef,
                "class": fieldClass,
                "value": model.value,
                "onInput": onInput,
                "autofocus": props2.autofocus,
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "placeholder": props2.placeholder,
                "rows": props2.rows,
                "name": props2.name,
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]]), props2.autoGrow && withDirectives(createVNode("textarea", {
                "class": [fieldClass, "v-textarea__sizer"],
                "id": `${slotProps.id}-sizer`,
                "onUpdate:modelValue": ($event) => model.value = $event,
                "ref": sizerRef,
                "readonly": true,
                "aria-hidden": "true"
              }, null), [[vModelText, model.value]]), props2.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [props2.suffix])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => createVNode(Fragment, null, [slots.details?.(slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
          "active": props2.persistentCounter || isFocused.value,
          "value": counterValue.value,
          "max": max.value
        }, slots.counter)])]) : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, textareaRef);
  }
});
const VTooltip$1 = "";
const makeVTooltipProps = propsFactory({
  id: String,
  text: String,
  ...omit(makeVOverlayProps({
    closeOnBack: false,
    location: "end",
    locationStrategy: "connected",
    eager: true,
    minWidth: 0,
    offset: 10,
    openOnClick: false,
    openOnHover: true,
    origin: "auto",
    scrim: false,
    scrollStrategy: "reposition",
    transition: false
  }), ["absolute", "persistent"])
}, "VTooltip");
const VTooltip = genericComponent()({
  name: "VTooltip",
  props: makeVTooltipProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props2, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props2, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props2.id || `v-tooltip-${uid2}`);
    const overlay = ref();
    const location2 = computed(() => {
      return props2.location.split(" ").length > 1 ? props2.location : props2.location + " center";
    });
    const origin = computed(() => {
      return props2.origin === "auto" || props2.origin === "overlap" || props2.origin.split(" ").length > 1 || props2.location.split(" ").length > 1 ? props2.origin : props2.origin + " center";
    });
    const transition = computed(() => {
      if (props2.transition)
        return props2.transition;
      return isActive.value ? "scale-transition" : "fade-transition";
    });
    const activatorProps = computed(() => mergeProps({
      "aria-describedby": id.value
    }, props2.activatorProps));
    useRender(() => {
      const overlayProps = VOverlay.filterProps(props2);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-tooltip", props2.class],
        "style": props2.style,
        "id": id.value
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "transition": transition.value,
        "absolute": true,
        "location": location2.value,
        "origin": origin.value,
        "persistent": true,
        "role": "tooltip",
        "activatorProps": activatorProps.value,
        "_disableGlobalStack": true
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return slots.default?.(...args) ?? props2.text;
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const vuetify = createVuetify({
  components: {
    VApp,
    VForm,
    VTextField,
    VTextarea,
    VVirtualScroll,
    VCard,
    VCardSubtitle,
    VDivider,
    VCardText,
    VTab,
    VTabs,
    VCardActions,
    VBtn,
    VMain,
    VNavigationDrawer,
    VListItem,
    VSheet,
    VListGroup,
    VList,
    VIcon,
    VSwitch,
    VMenu,
    VListItemTitle,
    VBanner,
    VDialog,
    VCardTitle,
    VSpacer,
    VSelect,
    VCheckboxBtn,
    VCombobox,
    VChip,
    VAutocomplete,
    VHover,
    VSkeletonLoader,
    VTable,
    VDataTableVirtual,
    VRadio,
    VRadioGroup,
    VBadge,
    VTooltip,
    VAvatar,
    VFileInput,
    VAlert,
    VExpansionPanel,
    VExpansionPanels
  },
  aliases: {
    VBtnPrimary: VBtn
  },
  defaults: {
    VTextField: {
      variant: "outlined",
      size: "x-small"
    },
    VTextarea: {
      variant: "outlined"
    },
    VBtnPrimary: {
      rounded: "md",
      variant: "elevated",
      color: "blue-darken-3"
    },
    VCard: {
      elevation: "2"
    }
  },
  icons: {
    defaultSet: "mdi",
    aliases,
    sets: {
      mdi
    }
  }
});
const style$1 = "";
function getInternetExplorerVersion() {
  var ua = window.navigator.userAgent;
  var msie = ua.indexOf("MSIE ");
  if (msie > 0) {
    return parseInt(ua.substring(msie + 5, ua.indexOf(".", msie)), 10);
  }
  var trident = ua.indexOf("Trident/");
  if (trident > 0) {
    var rv = ua.indexOf("rv:");
    return parseInt(ua.substring(rv + 3, ua.indexOf(".", rv)), 10);
  }
  var edge = ua.indexOf("Edge/");
  if (edge > 0) {
    return parseInt(ua.substring(edge + 5, ua.indexOf(".", edge)), 10);
  }
  return -1;
}
let isIE;
function initCompat() {
  if (!initCompat.init) {
    initCompat.init = true;
    isIE = getInternetExplorerVersion() !== -1;
  }
}
var script = {
  name: "ResizeObserver",
  props: {
    emitOnMount: {
      type: Boolean,
      default: false
    },
    ignoreWidth: {
      type: Boolean,
      default: false
    },
    ignoreHeight: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "notify"
  ],
  mounted() {
    initCompat();
    nextTick(() => {
      this._w = this.$el.offsetWidth;
      this._h = this.$el.offsetHeight;
      if (this.emitOnMount) {
        this.emitSize();
      }
    });
    const object = document.createElement("object");
    this._resizeObject = object;
    object.setAttribute("aria-hidden", "true");
    object.setAttribute("tabindex", -1);
    object.onload = this.addResizeHandlers;
    object.type = "text/html";
    if (isIE) {
      this.$el.appendChild(object);
    }
    object.data = "about:blank";
    if (!isIE) {
      this.$el.appendChild(object);
    }
  },
  beforeUnmount() {
    this.removeResizeHandlers();
  },
  methods: {
    compareAndNotify() {
      if (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) {
        this._w = this.$el.offsetWidth;
        this._h = this.$el.offsetHeight;
        this.emitSize();
      }
    },
    emitSize() {
      this.$emit("notify", {
        width: this._w,
        height: this._h
      });
    },
    addResizeHandlers() {
      this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify);
      this.compareAndNotify();
    },
    removeResizeHandlers() {
      if (this._resizeObject && this._resizeObject.onload) {
        if (!isIE && this._resizeObject.contentDocument) {
          this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify);
        }
        this.$el.removeChild(this._resizeObject);
        this._resizeObject.onload = null;
        this._resizeObject = null;
      }
    }
  }
};
const _withId = /* @__PURE__ */ withScopeId();
pushScopeId("data-v-b329ee4c");
const _hoisted_1$2 = {
  class: "resize-observer",
  tabindex: "-1"
};
popScopeId();
const render = /* @__PURE__ */ _withId((_ctx, _cache, $props, $setup, $data, $options) => {
  return openBlock(), createBlock("div", _hoisted_1$2);
});
script.render = render;
script.__scopeId = "data-v-b329ee4c";
script.__file = "src/components/ResizeObserver.vue";
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props2) {
  for (var i = 0; i < props2.length; i++) {
    var descriptor = props2[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function processOptions(value) {
  var options;
  if (typeof value === "function") {
    options = {
      callback: value
    };
  } else {
    options = value;
  }
  return options;
}
function throttle(callback, delay) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var timeout;
  var lastState;
  var currentArgs;
  var throttled = function throttled2(state) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    currentArgs = args;
    if (timeout && state === lastState)
      return;
    var leading = options.leading;
    if (typeof leading === "function") {
      leading = leading(state, lastState);
    }
    if ((!timeout || state !== lastState) && leading) {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
    }
    lastState = state;
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));
      timeout = 0;
    }, delay);
  };
  throttled._clear = function() {
    clearTimeout(timeout);
    timeout = null;
  };
  return throttled;
}
function deepEqual(val1, val2) {
  if (val1 === val2)
    return true;
  if (_typeof$1(val1) === "object") {
    for (var key in val1) {
      if (!deepEqual(val1[key], val2[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var VisibilityState = /* @__PURE__ */ function() {
  function VisibilityState2(el, options, vnode) {
    _classCallCheck(this, VisibilityState2);
    this.el = el;
    this.observer = null;
    this.frozen = false;
    this.createObserver(options, vnode);
  }
  _createClass(VisibilityState2, [{
    key: "createObserver",
    value: function createObserver(options, vnode) {
      var _this = this;
      if (this.observer) {
        this.destroyObserver();
      }
      if (this.frozen)
        return;
      this.options = processOptions(options);
      this.callback = function(result, entry) {
        _this.options.callback(result, entry);
        if (result && _this.options.once) {
          _this.frozen = true;
          _this.destroyObserver();
        }
      };
      if (this.callback && this.options.throttle) {
        var _ref = this.options.throttleOptions || {}, _leading = _ref.leading;
        this.callback = throttle(this.callback, this.options.throttle, {
          leading: function leading(state) {
            return _leading === "both" || _leading === "visible" && state || _leading === "hidden" && !state;
          }
        });
      }
      this.oldResult = void 0;
      this.observer = new IntersectionObserver(function(entries) {
        var entry = entries[0];
        if (entries.length > 1) {
          var intersectingEntry = entries.find(function(e) {
            return e.isIntersecting;
          });
          if (intersectingEntry) {
            entry = intersectingEntry;
          }
        }
        if (_this.callback) {
          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;
          if (result === _this.oldResult)
            return;
          _this.oldResult = result;
          _this.callback(result, entry);
        }
      }, this.options.intersection);
      nextTick(function() {
        if (_this.observer) {
          _this.observer.observe(_this.el);
        }
      });
    }
  }, {
    key: "destroyObserver",
    value: function destroyObserver() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      if (this.callback && this.callback._clear) {
        this.callback._clear();
        this.callback = null;
      }
    }
  }, {
    key: "threshold",
    get: function get2() {
      return this.options.intersection && typeof this.options.intersection.threshold === "number" ? this.options.intersection.threshold : 0;
    }
  }]);
  return VisibilityState2;
}();
function beforeMount(el, _ref2, vnode) {
  var value = _ref2.value;
  if (!value)
    return;
  if (typeof IntersectionObserver === "undefined") {
    console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");
  } else {
    var state = new VisibilityState(el, value, vnode);
    el._vue_visibilityState = state;
  }
}
function updated(el, _ref3, vnode) {
  var value = _ref3.value, oldValue = _ref3.oldValue;
  if (deepEqual(value, oldValue))
    return;
  var state = el._vue_visibilityState;
  if (!value) {
    unmounted(el);
    return;
  }
  if (state) {
    state.createObserver(value, vnode);
  } else {
    beforeMount(el, {
      value
    }, vnode);
  }
}
function unmounted(el) {
  var state = el._vue_visibilityState;
  if (state) {
    state.destroyObserver();
    delete el._vue_visibilityState;
  }
}
var ObserveVisibility = {
  beforeMount,
  updated,
  unmounted
};
var config = {
  itemsLimit: 1e3
};
var regex = /(auto|scroll)/;
function parents(node, ps) {
  if (node.parentNode === null) {
    return ps;
  }
  return parents(node.parentNode, ps.concat([node]));
}
var style = function style2(node, prop) {
  return getComputedStyle(node, null).getPropertyValue(prop);
};
var overflow = function overflow2(node) {
  return style(node, "overflow") + style(node, "overflow-y") + style(node, "overflow-x");
};
var scroll = function scroll2(node) {
  return regex.test(overflow(node));
};
function getScrollParent(node) {
  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {
    return;
  }
  var ps = parents(node.parentNode, []);
  for (var i = 0; i < ps.length; i += 1) {
    if (scroll(ps[i])) {
      return ps[i];
    }
  }
  return document.scrollingElement || document.documentElement;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var props = {
  items: {
    type: Array,
    required: true
  },
  keyField: {
    type: String,
    default: "id"
  },
  direction: {
    type: String,
    default: "vertical",
    validator: function validator(value) {
      return ["vertical", "horizontal"].includes(value);
    }
  },
  listTag: {
    type: String,
    default: "div"
  },
  itemTag: {
    type: String,
    default: "div"
  }
};
function simpleArray() {
  return this.items.length && _typeof(this.items[0]) !== "object";
}
var supportsPassive = false;
if (typeof window !== "undefined") {
  supportsPassive = false;
  try {
    var opts = Object.defineProperty({}, "passive", {
      get: function get2() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
  } catch (e) {
  }
}
let uid = 0;
var script$2 = {
  name: "RecycleScroller",
  components: {
    ResizeObserver: script
  },
  directives: {
    ObserveVisibility
  },
  props: {
    ...props,
    itemSize: {
      type: Number,
      default: null
    },
    gridItems: {
      type: Number,
      default: void 0
    },
    itemSecondarySize: {
      type: Number,
      default: void 0
    },
    minItemSize: {
      type: [Number, String],
      default: null
    },
    sizeField: {
      type: String,
      default: "size"
    },
    typeField: {
      type: String,
      default: "type"
    },
    buffer: {
      type: Number,
      default: 200
    },
    pageMode: {
      type: Boolean,
      default: false
    },
    prerender: {
      type: Number,
      default: 0
    },
    emitUpdate: {
      type: Boolean,
      default: false
    },
    updateInterval: {
      type: Number,
      default: 0
    },
    skipHover: {
      type: Boolean,
      default: false
    },
    listTag: {
      type: String,
      default: "div"
    },
    itemTag: {
      type: String,
      default: "div"
    },
    listClass: {
      type: [String, Object, Array],
      default: ""
    },
    itemClass: {
      type: [String, Object, Array],
      default: ""
    }
  },
  emits: [
    "resize",
    "visible",
    "hidden",
    "update",
    "scroll-start",
    "scroll-end"
  ],
  data() {
    return {
      pool: [],
      totalSize: 0,
      ready: false,
      hoverKey: null
    };
  },
  computed: {
    sizes() {
      if (this.itemSize === null) {
        const sizes = {
          "-1": { accumulator: 0 }
        };
        const items = this.items;
        const field = this.sizeField;
        const minItemSize = this.minItemSize;
        let computedMinSize = 1e4;
        let accumulator = 0;
        let current;
        for (let i = 0, l2 = items.length; i < l2; i++) {
          current = items[i][field] || minItemSize;
          if (current < computedMinSize) {
            computedMinSize = current;
          }
          accumulator += current;
          sizes[i] = { accumulator, size: current };
        }
        this.$_computedMinItemSize = computedMinSize;
        return sizes;
      }
      return [];
    },
    simpleArray,
    itemIndexByKey() {
      const { keyField, items } = this;
      const result = {};
      for (let i = 0, l2 = items.length; i < l2; i++) {
        result[items[i][keyField]] = i;
      }
      return result;
    }
  },
  watch: {
    items() {
      this.updateVisibleItems(true);
    },
    pageMode() {
      this.applyPageMode();
      this.updateVisibleItems(false);
    },
    sizes: {
      handler() {
        this.updateVisibleItems(false);
      },
      deep: true
    },
    gridItems() {
      this.updateVisibleItems(true);
    },
    itemSecondarySize() {
      this.updateVisibleItems(true);
    }
  },
  created() {
    this.$_startIndex = 0;
    this.$_endIndex = 0;
    this.$_views = /* @__PURE__ */ new Map();
    this.$_unusedViews = /* @__PURE__ */ new Map();
    this.$_scrollDirty = false;
    this.$_lastUpdateScrollPosition = 0;
    if (this.prerender) {
      this.$_prerender = true;
      this.updateVisibleItems(false);
    }
    if (this.gridItems && !this.itemSize) {
      console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems");
    }
  },
  mounted() {
    this.applyPageMode();
    this.$nextTick(() => {
      this.$_prerender = false;
      this.updateVisibleItems(true);
      this.ready = true;
    });
  },
  activated() {
    const lastPosition = this.$_lastUpdateScrollPosition;
    if (typeof lastPosition === "number") {
      this.$nextTick(() => {
        this.scrollToPosition(lastPosition);
      });
    }
  },
  beforeUnmount() {
    this.removeListeners();
  },
  methods: {
    addView(pool, index2, item, key, type) {
      const nr = markRaw({
        id: uid++,
        index: index2,
        used: true,
        key,
        type
      });
      const view = shallowReactive({
        item,
        position: 0,
        nr
      });
      pool.push(view);
      return view;
    },
    unuseView(view, fake = false) {
      const unusedViews = this.$_unusedViews;
      const type = view.nr.type;
      let unusedPool = unusedViews.get(type);
      if (!unusedPool) {
        unusedPool = [];
        unusedViews.set(type, unusedPool);
      }
      unusedPool.push(view);
      if (!fake) {
        view.nr.used = false;
        view.position = -9999;
      }
    },
    handleResize() {
      this.$emit("resize");
      if (this.ready)
        this.updateVisibleItems(false);
    },
    handleScroll(event) {
      if (!this.$_scrollDirty) {
        this.$_scrollDirty = true;
        if (this.$_updateTimeout)
          return;
        const requestUpdate = () => requestAnimationFrame(() => {
          this.$_scrollDirty = false;
          const { continuous } = this.updateVisibleItems(false, true);
          if (!continuous) {
            clearTimeout(this.$_refreshTimout);
            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100);
          }
        });
        requestUpdate();
        if (this.updateInterval) {
          this.$_updateTimeout = setTimeout(() => {
            this.$_updateTimeout = 0;
            if (this.$_scrollDirty)
              requestUpdate();
          }, this.updateInterval);
        }
      }
    },
    handleVisibilityChange(isVisible, entry) {
      if (this.ready) {
        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {
          this.$emit("visible");
          requestAnimationFrame(() => {
            this.updateVisibleItems(false);
          });
        } else {
          this.$emit("hidden");
        }
      }
    },
    updateVisibleItems(checkItem, checkPositionDiff = false) {
      const itemSize = this.itemSize;
      const gridItems = this.gridItems || 1;
      const itemSecondarySize = this.itemSecondarySize || itemSize;
      const minItemSize = this.$_computedMinItemSize;
      const typeField = this.typeField;
      const keyField = this.simpleArray ? null : this.keyField;
      const items = this.items;
      const count = items.length;
      const sizes = this.sizes;
      const views = this.$_views;
      const unusedViews = this.$_unusedViews;
      const pool = this.pool;
      const itemIndexByKey = this.itemIndexByKey;
      let startIndex, endIndex;
      let totalSize;
      let visibleStartIndex, visibleEndIndex;
      if (!count) {
        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0;
      } else if (this.$_prerender) {
        startIndex = visibleStartIndex = 0;
        endIndex = visibleEndIndex = Math.min(this.prerender, items.length);
        totalSize = null;
      } else {
        const scroll3 = this.getScroll();
        if (checkPositionDiff) {
          let positionDiff = scroll3.start - this.$_lastUpdateScrollPosition;
          if (positionDiff < 0)
            positionDiff = -positionDiff;
          if (itemSize === null && positionDiff < minItemSize || positionDiff < itemSize) {
            return {
              continuous: true
            };
          }
        }
        this.$_lastUpdateScrollPosition = scroll3.start;
        const buffer2 = this.buffer;
        scroll3.start -= buffer2;
        scroll3.end += buffer2;
        let beforeSize = 0;
        if (this.$refs.before) {
          beforeSize = this.$refs.before.scrollHeight;
          scroll3.start -= beforeSize;
        }
        if (this.$refs.after) {
          const afterSize = this.$refs.after.scrollHeight;
          scroll3.end += afterSize;
        }
        if (itemSize === null) {
          let h2;
          let a = 0;
          let b = count - 1;
          let i = ~~(count / 2);
          let oldI;
          do {
            oldI = i;
            h2 = sizes[i].accumulator;
            if (h2 < scroll3.start) {
              a = i;
            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll3.start) {
              b = i;
            }
            i = ~~((a + b) / 2);
          } while (i !== oldI);
          i < 0 && (i = 0);
          startIndex = i;
          totalSize = sizes[count - 1].accumulator;
          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll3.end; endIndex++)
            ;
          if (endIndex === -1) {
            endIndex = items.length - 1;
          } else {
            endIndex++;
            endIndex > count && (endIndex = count);
          }
          for (visibleStartIndex = startIndex; visibleStartIndex < count && beforeSize + sizes[visibleStartIndex].accumulator < scroll3.start; visibleStartIndex++)
            ;
          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && beforeSize + sizes[visibleEndIndex].accumulator < scroll3.end; visibleEndIndex++)
            ;
        } else {
          startIndex = ~~(scroll3.start / itemSize * gridItems);
          const remainer = startIndex % gridItems;
          startIndex -= remainer;
          endIndex = Math.ceil(scroll3.end / itemSize * gridItems);
          visibleStartIndex = Math.max(0, Math.floor((scroll3.start - beforeSize) / itemSize * gridItems));
          visibleEndIndex = Math.floor((scroll3.end - beforeSize) / itemSize * gridItems);
          startIndex < 0 && (startIndex = 0);
          endIndex > count && (endIndex = count);
          visibleStartIndex < 0 && (visibleStartIndex = 0);
          visibleEndIndex > count && (visibleEndIndex = count);
          totalSize = Math.ceil(count / gridItems) * itemSize;
        }
      }
      if (endIndex - startIndex > config.itemsLimit) {
        this.itemsLimitError();
      }
      this.totalSize = totalSize;
      let view;
      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex;
      if (continuous) {
        for (let i = 0, l2 = pool.length; i < l2; i++) {
          view = pool[i];
          if (view.nr.used) {
            if (checkItem) {
              view.nr.index = itemIndexByKey[view.item[keyField]];
            }
            if (view.nr.index == null || view.nr.index < startIndex || view.nr.index >= endIndex) {
              this.unuseView(view);
            }
          }
        }
      }
      const unusedIndex = continuous ? null : /* @__PURE__ */ new Map();
      let item, type;
      let v;
      for (let i = startIndex; i < endIndex; i++) {
        item = items[i];
        const key = keyField ? item[keyField] : item;
        if (key == null) {
          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);
        }
        view = views.get(key);
        if (!itemSize && !sizes[i].size) {
          if (view)
            this.unuseView(view);
          continue;
        }
        type = item[typeField];
        let unusedPool = unusedViews.get(type);
        let newlyUsedView = false;
        if (!view) {
          if (continuous) {
            if (unusedPool && unusedPool.length) {
              view = unusedPool.pop();
            } else {
              view = this.addView(pool, i, item, key, type);
            }
          } else {
            v = unusedIndex.get(type) || 0;
            if (!unusedPool || v >= unusedPool.length) {
              view = this.addView(pool, i, item, key, type);
              this.unuseView(view, true);
              unusedPool = unusedViews.get(type);
            }
            view = unusedPool[v];
            unusedIndex.set(type, v + 1);
          }
          views.delete(view.nr.key);
          view.nr.used = true;
          view.nr.index = i;
          view.nr.key = key;
          view.nr.type = type;
          views.set(key, view);
          newlyUsedView = true;
        } else {
          if (!view.nr.used) {
            view.nr.used = true;
            newlyUsedView = true;
            if (unusedPool) {
              const index2 = unusedPool.indexOf(view);
              if (index2 !== -1)
                unusedPool.splice(index2, 1);
            }
          }
        }
        view.item = item;
        if (newlyUsedView) {
          if (i === items.length - 1)
            this.$emit("scroll-end");
          if (i === 0)
            this.$emit("scroll-start");
        }
        if (itemSize === null) {
          view.position = sizes[i - 1].accumulator;
          view.offset = 0;
        } else {
          view.position = Math.floor(i / gridItems) * itemSize;
          view.offset = i % gridItems * itemSecondarySize;
        }
      }
      this.$_startIndex = startIndex;
      this.$_endIndex = endIndex;
      if (this.emitUpdate)
        this.$emit("update", startIndex, endIndex, visibleStartIndex, visibleEndIndex);
      clearTimeout(this.$_sortTimer);
      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300);
      return {
        continuous
      };
    },
    getListenerTarget() {
      let target = getScrollParent(this.$el);
      if (window.document && (target === window.document.documentElement || target === window.document.body)) {
        target = window;
      }
      return target;
    },
    getScroll() {
      const { $el: el, direction } = this;
      const isVertical = direction === "vertical";
      let scrollState;
      if (this.pageMode) {
        const bounds = el.getBoundingClientRect();
        const boundsSize = isVertical ? bounds.height : bounds.width;
        let start = -(isVertical ? bounds.top : bounds.left);
        let size2 = isVertical ? window.innerHeight : window.innerWidth;
        if (start < 0) {
          size2 += start;
          start = 0;
        }
        if (start + size2 > boundsSize) {
          size2 = boundsSize - start;
        }
        scrollState = {
          start,
          end: start + size2
        };
      } else if (isVertical) {
        scrollState = {
          start: el.scrollTop,
          end: el.scrollTop + el.clientHeight
        };
      } else {
        scrollState = {
          start: el.scrollLeft,
          end: el.scrollLeft + el.clientWidth
        };
      }
      return scrollState;
    },
    applyPageMode() {
      if (this.pageMode) {
        this.addListeners();
      } else {
        this.removeListeners();
      }
    },
    addListeners() {
      this.listenerTarget = this.getListenerTarget();
      this.listenerTarget.addEventListener("scroll", this.handleScroll, supportsPassive ? {
        passive: true
      } : false);
      this.listenerTarget.addEventListener("resize", this.handleResize);
    },
    removeListeners() {
      if (!this.listenerTarget) {
        return;
      }
      this.listenerTarget.removeEventListener("scroll", this.handleScroll);
      this.listenerTarget.removeEventListener("resize", this.handleResize);
      this.listenerTarget = null;
    },
    scrollToItem(index2) {
      let scroll3;
      const gridItems = this.gridItems || 1;
      if (this.itemSize === null) {
        scroll3 = index2 > 0 ? this.sizes[index2 - 1].accumulator : 0;
      } else {
        scroll3 = Math.floor(index2 / gridItems) * this.itemSize;
      }
      this.scrollToPosition(scroll3);
    },
    scrollToPosition(position) {
      const direction = this.direction === "vertical" ? { scroll: "scrollTop", start: "top" } : { scroll: "scrollLeft", start: "left" };
      let viewport;
      let scrollDirection;
      let scrollDistance;
      if (this.pageMode) {
        const viewportEl = getScrollParent(this.$el);
        const scrollTop = viewportEl.tagName === "HTML" ? 0 : viewportEl[direction.scroll];
        const bounds = viewportEl.getBoundingClientRect();
        const scroller = this.$el.getBoundingClientRect();
        const scrollerPosition = scroller[direction.start] - bounds[direction.start];
        viewport = viewportEl;
        scrollDirection = direction.scroll;
        scrollDistance = position + scrollTop + scrollerPosition;
      } else {
        viewport = this.$el;
        scrollDirection = direction.scroll;
        scrollDistance = position;
      }
      viewport[scrollDirection] = scrollDistance;
    },
    itemsLimitError() {
      setTimeout(() => {
        console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.", "Scroller:", this.$el);
        console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.");
      });
      throw new Error("Rendered items limit reached");
    },
    sortViews() {
      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);
    }
  }
};
const _hoisted_1$1 = {
  key: 0,
  ref: "before",
  class: "vue-recycle-scroller__slot"
};
const _hoisted_2$1 = {
  key: 1,
  ref: "after",
  class: "vue-recycle-scroller__slot"
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _directive_observe_visibility = resolveDirective("observe-visibility");
  return withDirectives((openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["vue-recycle-scroller", {
        ready: $data.ready,
        "page-mode": $props.pageMode,
        [`direction-${_ctx.direction}`]: true
      }]),
      onScrollPassive: _cache[0] || (_cache[0] = (...args) => $options.handleScroll && $options.handleScroll(...args))
    },
    [
      _ctx.$slots.before ? (openBlock(), createElementBlock(
        "div",
        _hoisted_1$1,
        [
          renderSlot(_ctx.$slots, "before")
        ],
        512
        /* NEED_PATCH */
      )) : createCommentVNode("v-if", true),
      (openBlock(), createBlock(resolveDynamicComponent($props.listTag), {
        ref: "wrapper",
        style: normalizeStyle({ [_ctx.direction === "vertical" ? "minHeight" : "minWidth"]: $data.totalSize + "px" }),
        class: normalizeClass(["vue-recycle-scroller__item-wrapper", $props.listClass])
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(
            Fragment,
            null,
            renderList($data.pool, (view) => {
              return openBlock(), createBlock(resolveDynamicComponent($props.itemTag), mergeProps({
                key: view.nr.id,
                style: $data.ready ? {
                  transform: `translate${_ctx.direction === "vertical" ? "Y" : "X"}(${view.position}px) translate${_ctx.direction === "vertical" ? "X" : "Y"}(${view.offset}px)`,
                  width: $props.gridItems ? `${_ctx.direction === "vertical" ? $props.itemSecondarySize || $props.itemSize : $props.itemSize}px` : void 0,
                  height: $props.gridItems ? `${_ctx.direction === "horizontal" ? $props.itemSecondarySize || $props.itemSize : $props.itemSize}px` : void 0
                } : null,
                class: ["vue-recycle-scroller__item-view", [
                  $props.itemClass,
                  {
                    hover: !$props.skipHover && $data.hoverKey === view.nr.key
                  }
                ]]
              }, toHandlers($props.skipHover ? {} : {
                mouseenter: () => {
                  $data.hoverKey = view.nr.key;
                },
                mouseleave: () => {
                  $data.hoverKey = null;
                }
              })), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {
                    item: view.item,
                    index: view.nr.index,
                    active: view.nr.used
                  })
                ]),
                _: 2
                /* DYNAMIC */
              }, 1040, ["style", "class"]);
            }),
            128
            /* KEYED_FRAGMENT */
          )),
          renderSlot(_ctx.$slots, "empty")
        ]),
        _: 3
        /* FORWARDED */
      }, 8, ["style", "class"])),
      _ctx.$slots.after ? (openBlock(), createElementBlock(
        "div",
        _hoisted_2$1,
        [
          renderSlot(_ctx.$slots, "after")
        ],
        512
        /* NEED_PATCH */
      )) : createCommentVNode("v-if", true),
      createVNode(_component_ResizeObserver, { onNotify: $options.handleResize }, null, 8, ["onNotify"])
    ],
    34
    /* CLASS, HYDRATE_EVENTS */
  )), [
    [_directive_observe_visibility, $options.handleVisibilityChange]
  ]);
}
script$2.render = render$1;
script$2.__file = "src/components/RecycleScroller.vue";
const vueVirtualScroller = "";
const D = {
  TOP_LEFT: "top-left",
  TOP_RIGHT: "top-right",
  TOP_CENTER: "top-center",
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_RIGHT: "bottom-right",
  BOTTOM_CENTER: "bottom-center"
}, M = {
  LIGHT: "light",
  DARK: "dark",
  COLORED: "colored",
  AUTO: "auto"
}, g = {
  INFO: "info",
  SUCCESS: "success",
  WARNING: "warning",
  ERROR: "error",
  DEFAULT: "default"
}, Ne = {
  BOUNCE: "bounce",
  SLIDE: "slide",
  FLIP: "flip",
  ZOOM: "zoom"
}, ce = {
  dangerouslyHTMLString: false,
  multiple: true,
  position: D.TOP_RIGHT,
  autoClose: 5e3,
  transition: "bounce",
  hideProgressBar: false,
  pauseOnHover: true,
  pauseOnFocusLoss: true,
  closeOnClick: true,
  className: "",
  bodyClassName: "",
  style: {},
  progressClassName: "",
  progressStyle: {},
  role: "alert",
  theme: "light"
}, Ie = {
  rtl: false,
  newestOnTop: false,
  toastClassName: ""
}, fe = {
  ...ce,
  ...Ie
};
({
  ...ce,
  type: g.DEFAULT
});
var r = /* @__PURE__ */ ((e) => (e[e.COLLAPSE_DURATION = 300] = "COLLAPSE_DURATION", e[e.DEBOUNCE_DURATION = 50] = "DEBOUNCE_DURATION", e.CSS_NAMESPACE = "Toastify", e))(r || {}), J = /* @__PURE__ */ ((e) => (e.ENTRANCE_ANIMATION_END = "d", e))(J || {});
const _e = {
  enter: "Toastify--animate Toastify__bounce-enter",
  exit: "Toastify--animate Toastify__bounce-exit",
  appendPosition: true
}, he = {
  enter: "Toastify--animate Toastify__slide-enter",
  exit: "Toastify--animate Toastify__slide-exit",
  appendPosition: true
}, Oe = {
  enter: "Toastify--animate Toastify__zoom-enter",
  exit: "Toastify--animate Toastify__zoom-exit"
}, be = {
  enter: "Toastify--animate Toastify__flip-enter",
  exit: "Toastify--animate Toastify__flip-exit"
};
function me(e) {
  let t = _e;
  if (!e || typeof e == "string")
    switch (e) {
      case "flip":
        t = be;
        break;
      case "zoom":
        t = Oe;
        break;
      case "slide":
        t = he;
        break;
    }
  else
    t = e;
  return t;
}
function Pe(e) {
  return e.containerId || String(e.position);
}
const K = "will-unmount";
function Le(e = D.TOP_RIGHT) {
  return !!document.querySelector(".".concat(r.CSS_NAMESPACE, "__toast-container--").concat(e));
}
function $e(e = D.TOP_RIGHT) {
  return "".concat(r.CSS_NAMESPACE, "__toast-container--").concat(e);
}
function qe(e, t, n = false) {
  const a = [
    "".concat(r.CSS_NAMESPACE, "__toast-container"),
    "".concat(r.CSS_NAMESPACE, "__toast-container--").concat(e),
    n ? "".concat(r.CSS_NAMESPACE, "__toast-container--rtl") : null
  ].filter(Boolean).join(" ");
  return B(t) ? t({
    position: e,
    rtl: n,
    defaultClassName: a
  }) : "".concat(a, " ").concat(t || "");
}
function Be(e) {
  var C;
  const { position: t, containerClassName: n, rtl: a = false, style: o = {} } = e, s = r.CSS_NAMESPACE, u = $e(t), E = document.querySelector(".".concat(s)), d = document.querySelector(".".concat(u)), p2 = !!d && !((C = d.className) != null && C.includes(K)), m = E || document.createElement("div"), S = document.createElement("div");
  S.className = qe(
    t,
    n,
    a
  ), S.dataset.testid = "".concat(r.CSS_NAMESPACE, "__toast-container--").concat(t), S.id = Pe(e);
  for (const v in o)
    if (Object.prototype.hasOwnProperty.call(o, v)) {
      const I = o[v];
      S.style[v] = I;
    }
  return E || (m.className = r.CSS_NAMESPACE, document.body.appendChild(m)), p2 || m.appendChild(S), S;
}
function ee(e) {
  var a, o, s;
  const t = typeof e == "string" ? e : ((a = e.currentTarget) == null ? void 0 : a.id) || ((o = e.target) == null ? void 0 : o.id), n = document.getElementById(t);
  n && n.removeEventListener("animationend", ee, false);
  try {
    x[t].unmount(), (s = document.getElementById(t)) == null || s.remove(), delete x[t], delete c[t];
  } catch {
  }
}
const x = reactive({});
function Me(e, t) {
  const n = document.getElementById(String(t));
  n && (x[n.id] = e);
}
function te(e, t = true) {
  const n = String(e);
  if (!x[n])
    return;
  const a = document.getElementById(n);
  a && a.classList.add(K), t ? (Re(e), a && a.addEventListener("animationend", ee, false)) : ee(n), N.items = N.items.filter((o) => o.containerId !== e);
}
function we(e) {
  for (const t in x)
    te(t, e);
  N.items = [];
}
function ge(e, t) {
  const n = document.getElementById(e.toastId);
  if (n) {
    let a = e;
    a = {
      ...a,
      ...me(a.transition)
    };
    const o = a.appendPosition ? "".concat(a.exit, "--").concat(a.position) : a.exit;
    n.className += " ".concat(o), t && t(n);
  }
}
function Re(e) {
  for (const t in c)
    if (t === e)
      for (const n of c[t] || [])
        ge(n);
}
function Fe(e) {
  const n = k().find((a) => a.toastId === e);
  return n == null ? void 0 : n.containerId;
}
function se(e) {
  return document.getElementById(e);
}
function Ue(e) {
  const t = se(e.containerId);
  return t && t.classList.contains(K);
}
function re(e) {
  var n;
  const t = isVNode(e.content) ? toRaw(e.content.props) : null;
  return t != null ? t : toRaw((n = e.data) != null ? n : {});
}
function xe(e) {
  return e ? N.items.filter((n) => n.containerId === e).length > 0 : N.items.length > 0;
}
function De() {
  if (N.items.length > 0) {
    const e = N.items.shift();
    j(e == null ? void 0 : e.toastContent, e == null ? void 0 : e.toastProps);
  }
}
const c = reactive({}), N = reactive({
  items: []
});
function k() {
  const e = toRaw(c);
  return Object.values(e).reduce((t, n) => [...t, ...n], []);
}
function ke(e) {
  return k().find((n) => n.toastId === e);
}
function j(e, t = {}) {
  if (Ue(t)) {
    const n = se(t.containerId);
    n && n.addEventListener("animationend", ne.bind(null, e, t), false);
  } else
    ne(e, t);
}
function ne(e, t = {}) {
  const n = se(t.containerId);
  n && n.removeEventListener("animationend", ne.bind(null, e, t), false);
  const a = c[t.containerId] || [], o = a.length > 0;
  if (!o && !Le(t.position)) {
    const s = Be(t), u = createApp(rt, t);
    u.mount(s), Me(u, s.id);
  }
  o && (t.position = a[0].position), nextTick(() => {
    t.updateId ? A.update(t) : A.add(e, t);
  });
}
const A = {
  /**
   * add a toast
   * @param _ ..
   * @param opts toast props
   */
  add(e, t) {
    const { containerId: n = "" } = t;
    n && (c[n] = c[n] || [], c[n].find((a) => a.toastId === t.toastId) || setTimeout(() => {
      var a, o;
      t.newestOnTop ? (a = c[n]) == null || a.unshift(t) : (o = c[n]) == null || o.push(t), t.onOpen && t.onOpen(re(t));
    }, t.delay || 0));
  },
  /**
   * remove a toast
   * @param id toastId
   */
  remove(e) {
    if (e) {
      const t = Fe(e);
      if (t) {
        const n = c[t];
        let a = n.find((o) => o.toastId === e);
        c[t] = n.filter((o) => o.toastId !== e), !c[t].length && !xe(t) && te(t, false), De(), nextTick(() => {
          a != null && a.onClose && (a.onClose(re(a)), a = void 0);
        });
      }
    }
  },
  /**
   * update the toast
   * @param opts toast props
   */
  update(e = {}) {
    const { containerId: t = "" } = e;
    if (t && e.updateId) {
      c[t] = c[t] || [];
      const n = c[t].find((a) => a.toastId === e.toastId);
      n && setTimeout(() => {
        for (const a in e)
          if (Object.prototype.hasOwnProperty.call(e, a)) {
            const o = e[a];
            n[a] = o;
          }
      }, e.delay || 0);
    }
  },
  /**
   * clear all toasts in container.
   * @param containerId container id
   */
  clear(e, t = true) {
    e ? te(e, t) : we(t);
  },
  dismissCallback(e) {
    var a;
    const t = (a = e.currentTarget) == null ? void 0 : a.id, n = document.getElementById(t);
    n && (n.removeEventListener("animationend", A.dismissCallback, false), setTimeout(() => {
      A.remove(t);
    }));
  },
  dismiss(e) {
    if (e) {
      const t = k();
      for (const n of t)
        if (n.toastId === e) {
          ge(n, (a) => {
            a.addEventListener("animationend", A.dismissCallback, false);
          });
          break;
        }
    }
  }
}, Ce = reactive({}), Q = reactive({});
function ye() {
  return Math.random().toString(36).substring(2, 9);
}
function He(e) {
  return typeof e == "number" && !isNaN(e);
}
function ae(e) {
  return typeof e == "string";
}
function B(e) {
  return typeof e == "function";
}
function Y(...e) {
  return mergeProps(...e);
}
function G(e) {
  return typeof e == "object" && (!!(e != null && e.render) || !!(e != null && e.setup) || typeof (e == null ? void 0 : e.type) == "object");
}
function ze(e = {}) {
  Ce["".concat(r.CSS_NAMESPACE, "-default-options")] = e;
}
function je() {
  return Ce["".concat(r.CSS_NAMESPACE, "-default-options")] || fe;
}
function Ge() {
  return document.documentElement.classList.contains("dark") ? "dark" : "light";
}
var V = /* @__PURE__ */ ((e) => (e[e.Enter = 0] = "Enter", e[e.Exit = 1] = "Exit", e))(V || {});
const Ee = {
  containerId: {
    type: [String, Number],
    required: false,
    default: ""
  },
  clearOnUrlChange: {
    type: Boolean,
    required: false,
    default: true
  },
  dangerouslyHTMLString: {
    type: Boolean,
    required: false,
    default: false
  },
  multiple: {
    type: Boolean,
    required: false,
    default: true
  },
  limit: {
    type: Number,
    required: false,
    default: void 0
  },
  position: {
    type: String,
    required: false,
    default: D.TOP_LEFT
  },
  bodyClassName: {
    type: String,
    required: false,
    default: ""
  },
  autoClose: {
    type: [Number, Boolean],
    required: false,
    default: false
  },
  closeButton: {
    type: [Boolean, Function, Object],
    required: false,
    default: void 0
  },
  transition: {
    type: [String, Object],
    required: false,
    default: "bounce"
  },
  hideProgressBar: {
    type: Boolean,
    required: false,
    default: false
  },
  pauseOnHover: {
    type: Boolean,
    required: false,
    default: true
  },
  pauseOnFocusLoss: {
    type: Boolean,
    required: false,
    default: true
  },
  closeOnClick: {
    type: Boolean,
    required: false,
    default: true
  },
  progress: {
    type: Number,
    required: false,
    default: void 0
  },
  progressClassName: {
    type: String,
    required: false,
    default: ""
  },
  toastStyle: {
    type: Object,
    required: false,
    default() {
      return {};
    }
  },
  progressStyle: {
    type: Object,
    required: false,
    default() {
      return {};
    }
  },
  role: {
    type: String,
    required: false,
    default: "alert"
  },
  theme: {
    type: String,
    required: false,
    default: M.AUTO
  },
  content: {
    type: [String, Object, Function],
    required: false,
    default: ""
  },
  toastId: {
    type: [String, Number],
    required: false,
    default: ""
  },
  data: {
    type: [Object, String],
    required: false,
    default() {
      return {};
    }
  },
  type: {
    type: String,
    required: false,
    default: g.DEFAULT
  },
  icon: {
    type: [Boolean, String, Number, Object, Function],
    required: false,
    default: void 0
  },
  delay: {
    type: Number,
    required: false,
    default: void 0
  },
  onOpen: {
    type: Function,
    required: false,
    default: void 0
  },
  onClose: {
    type: Function,
    required: false,
    default: void 0
  },
  onClick: {
    type: Function,
    required: false,
    default: void 0
  },
  isLoading: {
    type: Boolean,
    required: false,
    default: void 0
  },
  rtl: {
    type: Boolean,
    required: false,
    default: false
  },
  toastClassName: {
    type: String,
    required: false,
    default: ""
  },
  updateId: {
    type: [String, Number],
    required: false,
    default: ""
  }
}, Ve = {
  autoClose: {
    type: [Number, Boolean],
    required: true
  },
  isRunning: {
    type: Boolean,
    required: false,
    default: void 0
  },
  type: {
    type: String,
    required: false,
    default: g.DEFAULT
  },
  theme: {
    type: String,
    required: false,
    default: M.AUTO
  },
  hide: {
    type: Boolean,
    required: false,
    default: void 0
  },
  className: {
    type: [String, Function],
    required: false,
    default: ""
  },
  controlledProgress: {
    type: Boolean,
    required: false,
    default: void 0
  },
  rtl: {
    type: Boolean,
    required: false,
    default: void 0
  },
  isIn: {
    type: Boolean,
    required: false,
    default: void 0
  },
  progress: {
    type: Number,
    required: false,
    default: void 0
  },
  closeToast: {
    type: Function,
    required: false,
    default: void 0
  }
}, Qe = /* @__PURE__ */ defineComponent$1({
  name: "ProgressBar",
  props: Ve,
  // @ts-ignore
  setup(e, {
    attrs: t
  }) {
    const n = ref(), a = computed(() => e.hide ? "true" : "false"), o = computed(() => ({
      ...t.style || {},
      animationDuration: "".concat(e.autoClose === true ? 5e3 : e.autoClose, "ms"),
      animationPlayState: e.isRunning ? "running" : "paused",
      opacity: e.hide || e.autoClose === false ? 0 : 1,
      transform: e.controlledProgress ? "scaleX(".concat(e.progress, ")") : "none"
    })), s = computed(() => ["".concat(r.CSS_NAMESPACE, "__progress-bar"), e.controlledProgress ? "".concat(r.CSS_NAMESPACE, "__progress-bar--controlled") : "".concat(r.CSS_NAMESPACE, "__progress-bar--animated"), "".concat(r.CSS_NAMESPACE, "__progress-bar-theme--").concat(e.theme), "".concat(r.CSS_NAMESPACE, "__progress-bar--").concat(e.type), e.rtl ? "".concat(r.CSS_NAMESPACE, "__progress-bar--rtl") : null].filter(Boolean).join(" ")), u = computed(() => "".concat(s.value, " ").concat((t == null ? void 0 : t.class) || "")), E = () => {
      n.value && (n.value.onanimationend = null, n.value.ontransitionend = null);
    }, d = () => {
      e.isIn && e.closeToast && e.autoClose !== false && (e.closeToast(), E());
    }, p2 = computed(() => e.controlledProgress ? null : d), m = computed(() => e.controlledProgress ? d : null);
    return watchEffect(() => {
      n.value && (E(), n.value.onanimationend = p2.value, n.value.ontransitionend = m.value);
    }), () => createVNode("div", {
      ref: n,
      role: "progressbar",
      "aria-hidden": a.value,
      "aria-label": "notification timer",
      class: u.value,
      style: o.value
    }, null);
  }
}), We = /* @__PURE__ */ defineComponent$1({
  name: "CloseButton",
  inheritAttrs: false,
  props: {
    theme: {
      type: String,
      required: false,
      default: M.AUTO
    },
    type: {
      type: String,
      required: false,
      default: M.LIGHT
    },
    ariaLabel: {
      type: String,
      required: false,
      default: "close"
    },
    closeToast: {
      type: Function,
      required: false,
      default: void 0
    }
  },
  setup(e) {
    return () => createVNode("button", {
      class: "".concat(r.CSS_NAMESPACE, "__close-button ").concat(r.CSS_NAMESPACE, "__close-button--").concat(e.theme),
      type: "button",
      onClick: (t) => {
        t.stopPropagation(), e.closeToast && e.closeToast(t);
      },
      "aria-label": e.ariaLabel
    }, [createVNode("svg", {
      "aria-hidden": "true",
      viewBox: "0 0 14 16"
    }, [createVNode("path", {
      "fill-rule": "evenodd",
      d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
    }, null)])]);
  }
}), Z = ({
  theme: e,
  type: t,
  path: n,
  ...a
}) => createVNode("svg", mergeProps({
  viewBox: "0 0 24 24",
  width: "100%",
  height: "100%",
  fill: e === "colored" ? "currentColor" : "var(--toastify-icon-color-".concat(t, ")")
}, a), [createVNode("path", {
  d: n
}, null)]);
function Ke(e) {
  return createVNode(Z, mergeProps(e, {
    path: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
  }), null);
}
function Ye(e) {
  return createVNode(Z, mergeProps(e, {
    path: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
  }), null);
}
function Ze(e) {
  return createVNode(Z, mergeProps(e, {
    path: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
  }), null);
}
function Xe(e) {
  return createVNode(Z, mergeProps(e, {
    path: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
  }), null);
}
function Je() {
  return createVNode("div", {
    class: "".concat(r.CSS_NAMESPACE, "__spinner")
  }, null);
}
const oe = {
  info: Ye,
  warning: Ke,
  success: Ze,
  error: Xe,
  spinner: Je
}, et = (e) => e in oe;
function tt({
  theme: e,
  type: t,
  isLoading: n,
  icon: a
}) {
  let o;
  const s = {
    theme: e,
    type: t
  };
  return n ? o = oe.spinner() : a === false ? o = void 0 : G(a) ? o = toRaw(a) : B(a) ? o = a(s) : isVNode(a) ? o = cloneVNode(a, s) : ae(a) || He(a) ? o = a : et(t) && (o = oe[t](s)), o;
}
const nt = () => {
};
function at(e, t, n = r.COLLAPSE_DURATION) {
  const { scrollHeight: a, style: o } = e, s = n;
  requestAnimationFrame(() => {
    o.minHeight = "initial", o.height = a + "px", o.transition = "all ".concat(s, "ms"), requestAnimationFrame(() => {
      o.height = "0", o.padding = "0", o.margin = "0", setTimeout(t, s);
    });
  });
}
function ot(e) {
  const t = ref(false), n = ref(false), a = ref(false), o = ref(V.Enter), s = reactive({
    ...e,
    appendPosition: e.appendPosition || false,
    collapse: typeof e.collapse > "u" ? true : e.collapse,
    collapseDuration: e.collapseDuration || r.COLLAPSE_DURATION
  }), u = s.done || nt, E = computed(() => s.appendPosition ? "".concat(s.enter, "--").concat(s.position) : s.enter), d = computed(() => s.appendPosition ? "".concat(s.exit, "--").concat(s.position) : s.exit), p2 = computed(() => e.pauseOnHover ? {
    onMouseenter: h2,
    onMouseleave: _
  } : {});
  function m() {
    const y = E.value.split(" ");
    C().addEventListener(
      J.ENTRANCE_ANIMATION_END,
      _,
      { once: true }
    );
    const O = ($) => {
      const F = C();
      $.target === F && (F.dispatchEvent(new Event(J.ENTRANCE_ANIMATION_END)), F.removeEventListener("animationend", O), F.removeEventListener("animationcancel", O), o.value === V.Enter && $.type !== "animationcancel" && F.classList.remove(...y));
    }, b = () => {
      const $ = C();
      $.classList.add(...y), $.addEventListener("animationend", O), $.addEventListener("animationcancel", O);
    };
    e.pauseOnFocusLoss && v(), b();
  }
  function S() {
    if (!C())
      return;
    const y = () => {
      const b = C();
      b.removeEventListener("animationend", y), s.collapse ? at(b, u, s.collapseDuration) : u();
    }, O = () => {
      const b = C();
      o.value = V.Exit, b && (b.className += " ".concat(d.value), b.addEventListener("animationend", y));
    };
    n.value || (a.value ? y() : setTimeout(O));
  }
  function C() {
    return e.toastRef.value;
  }
  function v() {
    document.hasFocus() || h2(), window.addEventListener("focus", _), window.addEventListener("blur", h2);
  }
  function I() {
    window.removeEventListener("focus", _), window.removeEventListener("blur", h2);
  }
  function _() {
    (!e.loading.value || e.isLoading === void 0) && (t.value = true);
  }
  function h2() {
    t.value = false;
  }
  function R(y) {
    y && (y.stopPropagation(), y.preventDefault()), n.value = false;
  }
  return watchEffect(S), watchEffect(() => {
    const y = k();
    n.value = y.findIndex((O) => O.toastId === s.toastId) > -1;
  }), watchEffect(() => {
    e.isLoading !== void 0 && (e.loading.value ? h2() : _());
  }), onMounted(m), onUnmounted(() => {
    e.pauseOnFocusLoss && I();
  }), {
    isIn: n,
    isRunning: t,
    hideToast: R,
    eventHandlers: p2
  };
}
const st = /* @__PURE__ */ defineComponent$1({
  name: "ToastItem",
  inheritAttrs: false,
  props: Ee,
  // @ts-ignore
  setup(e) {
    const t = ref(), n = computed(() => !!e.isLoading), a = computed(() => e.progress !== void 0 && e.progress !== null), o = computed(() => tt(e)), s = computed(() => ["".concat(r.CSS_NAMESPACE, "__toast"), "".concat(r.CSS_NAMESPACE, "__toast-theme--").concat(e.theme), "".concat(r.CSS_NAMESPACE, "__toast--").concat(e.type), e.rtl ? "".concat(r.CSS_NAMESPACE, "__toast--rtl") : void 0, e.toastClassName || ""].filter(Boolean).join(" ")), {
      isRunning: u,
      isIn: E,
      hideToast: d,
      eventHandlers: p2
    } = ot({
      toastRef: t,
      loading: n,
      done: () => {
        A.remove(e.toastId);
      },
      ...me(e.transition),
      ...e
    });
    return () => createVNode("div", mergeProps({
      id: e.toastId,
      class: s.value,
      style: e.toastStyle || {},
      ref: t,
      "data-testid": "toast-item-".concat(e.toastId),
      onClick: (m) => {
        e.closeOnClick && d(), e.onClick && e.onClick(m);
      }
    }, p2.value), [createVNode("div", {
      role: e.role,
      "data-testid": "toast-body",
      class: "".concat(r.CSS_NAMESPACE, "__toast-body ").concat(e.bodyClassName || "")
    }, [o.value != null && createVNode("div", {
      "data-testid": "toast-icon-".concat(e.type),
      class: ["".concat(r.CSS_NAMESPACE, "__toast-icon"), e.isLoading ? "" : "".concat(r.CSS_NAMESPACE, "--animate-icon ").concat(r.CSS_NAMESPACE, "__zoom-enter")].join(" ")
    }, [G(o.value) ? h(toRaw(o.value), {
      theme: e.theme,
      type: e.type
    }) : B(o.value) ? o.value({
      theme: e.theme,
      type: e.type
    }) : o.value]), createVNode("div", {
      "data-testid": "toast-content"
    }, [G(e.content) ? h(toRaw(e.content), {
      toastProps: toRaw(e),
      closeToast: d,
      data: e.data
    }) : B(e.content) ? e.content({
      toastProps: toRaw(e),
      closeToast: d,
      data: e.data
    }) : e.dangerouslyHTMLString ? h("div", {
      innerHTML: e.content
    }) : e.content])]), (e.closeButton === void 0 || e.closeButton === true) && createVNode(We, {
      theme: e.theme,
      closeToast: (m) => {
        m.stopPropagation(), m.preventDefault(), d();
      }
    }, null), G(e.closeButton) ? h(toRaw(e.closeButton), {
      closeToast: d,
      type: e.type,
      theme: e.theme
    }) : B(e.closeButton) ? e.closeButton({
      closeToast: d,
      type: e.type,
      theme: e.theme
    }) : null, createVNode(Qe, {
      className: e.progressClassName,
      style: e.progressStyle,
      rtl: e.rtl,
      theme: e.theme,
      isIn: E.value,
      type: e.type,
      hide: e.hideProgressBar,
      isRunning: u.value,
      autoClose: e.autoClose,
      controlledProgress: a.value,
      progress: e.progress,
      closeToast: e.isLoading ? void 0 : d
    }, null)]);
  }
});
let U = 0;
function Se() {
  typeof window > "u" || (U && window.cancelAnimationFrame(U), U = window.requestAnimationFrame(Se), Q.lastUrl !== window.location.href && (Q.lastUrl = window.location.href, A.clear()));
}
const rt = /* @__PURE__ */ defineComponent$1({
  name: "ToastifyContainer",
  inheritAttrs: false,
  props: Ee,
  // @ts-ignore
  setup(e) {
    const t = computed(() => e.containerId), n = computed(() => c[t.value] || []), a = computed(() => n.value.filter((o) => o.position === e.position));
    return onMounted(() => {
      typeof window < "u" && e.clearOnUrlChange && window.requestAnimationFrame(Se);
    }), onUnmounted(() => {
      typeof window < "u" && U && (window.cancelAnimationFrame(U), Q.lastUrl = "");
    }), () => createVNode(Fragment, null, [a.value.map((o) => {
      const {
        toastId: s = ""
      } = o;
      return createVNode(st, mergeProps({
        key: s
      }, o), null);
    })]);
  }
});
let X = false;
function ve() {
  const e = [];
  return k().forEach((n) => {
    const a = document.getElementById(n.containerId);
    a && !a.classList.contains(K) && e.push(n);
  }), e;
}
function lt(e) {
  const t = ve().length, n = e != null ? e : 0;
  return n > 0 && t + N.items.length >= n;
}
function it(e) {
  lt(e.limit) && !e.updateId && N.items.push({
    toastId: e.toastId,
    containerId: e.containerId,
    toastContent: e.content,
    toastProps: e
  });
}
function L(e, t, n = {}) {
  if (X)
    return;
  n = Y(je(), {
    type: t
  }, toRaw(n)), (!n.toastId || typeof n.toastId != "string" && typeof n.toastId != "number") && (n.toastId = ye()), n = {
    ...n,
    content: e,
    containerId: n.containerId || String(n.position)
  };
  const a = Number(n == null ? void 0 : n.progress);
  return a < 0 && (n.progress = 0), a > 1 && (n.progress = 1), n.theme === "auto" && (n.theme = Ge()), it(n), Q.lastUrl = window.location.href, n.multiple ? N.items.length ? n.updateId && j(e, n) : j(e, n) : (X = true, l.clearAll(void 0, false), setTimeout(() => {
    j(e, n);
  }, 0), setTimeout(() => {
    X = false;
  }, 390)), n.toastId;
}
const l = (e, t) => L(e, g.DEFAULT, t);
l.info = (e, t) => L(e, g.DEFAULT, {
  ...t,
  type: g.INFO
});
l.error = (e, t) => L(e, g.DEFAULT, {
  ...t,
  type: g.ERROR
});
l.warning = (e, t) => L(e, g.DEFAULT, {
  ...t,
  type: g.WARNING
});
l.warn = l.warning;
l.success = (e, t) => L(e, g.DEFAULT, {
  ...t,
  type: g.SUCCESS
});
l.loading = (e, t) => L(e, g.DEFAULT, Y(t, {
  isLoading: true,
  autoClose: false,
  closeOnClick: false,
  closeButton: false,
  draggable: false
}));
l.dark = (e, t) => L(e, g.DEFAULT, Y(t, {
  theme: M.DARK
}));
l.remove = (e) => {
  e ? A.dismiss(e) : A.clear();
};
l.clearAll = (e, t) => {
  A.clear(e, t);
};
l.isActive = (e) => {
  let t = false;
  return t = ve().findIndex((a) => a.toastId === e) > -1, t;
};
l.update = (e, t = {}) => {
  setTimeout(() => {
    const n = ke(e);
    if (n) {
      const a = toRaw(n), {
        content: o
      } = a, s = {
        ...a,
        ...t,
        toastId: t.toastId || e,
        updateId: ye()
      }, u = s.render || o;
      delete s.render, L(u, s.type, s);
    }
  }, 0);
};
l.done = (e) => {
  l.update(e, {
    isLoading: false,
    progress: 1
  });
};
l.promise = ut;
function ut(e, {
  pending: t,
  error: n,
  success: a
}, o) {
  var m, S, C;
  let s;
  const u = {
    ...o || {},
    autoClose: false
  };
  t && (s = ae(t) ? l.loading(t, u) : l.loading(t.render, {
    ...u,
    ...t
  }));
  const E = {
    autoClose: (m = o == null ? void 0 : o.autoClose) != null ? m : true,
    closeOnClick: (S = o == null ? void 0 : o.closeOnClick) != null ? S : true,
    closeButton: (C = o == null ? void 0 : o.autoClose) != null ? C : null,
    isLoading: void 0,
    draggable: null,
    delay: 100
  }, d = (v, I, _) => {
    if (I == null) {
      l.remove(s);
      return;
    }
    const h2 = {
      type: v,
      ...E,
      ...o,
      data: _
    }, R = ae(I) ? {
      render: I
    } : I;
    return s ? l.update(s, {
      ...h2,
      ...R,
      isLoading: false
    }) : l(R.render, {
      ...h2,
      ...R,
      isLoading: false
    }), _;
  }, p2 = B(e) ? e() : e;
  return p2.then((v) => {
    d("success", a, v);
  }).catch((v) => {
    d("error", n, v);
  }), p2;
}
l.POSITION = D;
l.THEME = M;
l.TYPE = g;
l.TRANSITIONS = Ne;
const dt = {
  install(e, t = {}) {
    ct(t);
  }
};
typeof window < "u" && (window.Vue3Toastify = dt);
function ct(e = {}) {
  const t = Y(fe, e);
  ze(t);
}
const index$1 = "";
const index = "";
/*!
  * vue-router v4.2.5
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */
const isBrowser = typeof window !== "undefined";
function isESModule(obj) {
  return obj.__esModule || obj[Symbol.toStringTag] === "Module";
}
const assign = Object.assign;
function applyToParams(fn, params) {
  const newParams = {};
  for (const key in params) {
    const value = params[key];
    newParams[key] = isArray(value) ? value.map(fn) : fn(value);
  }
  return newParams;
}
const noop = () => {
};
const isArray = Array.isArray;
const TRAILING_SLASH_RE = /\/$/;
const removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
function parseURL(parseQuery2, location2, currentLocation = "/") {
  let path, query = {}, searchString = "", hash = "";
  const hashPos = location2.indexOf("#");
  let searchPos = location2.indexOf("?");
  if (hashPos < searchPos && hashPos >= 0) {
    searchPos = -1;
  }
  if (searchPos > -1) {
    path = location2.slice(0, searchPos);
    searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
    query = parseQuery2(searchString);
  }
  if (hashPos > -1) {
    path = path || location2.slice(0, hashPos);
    hash = location2.slice(hashPos, location2.length);
  }
  path = resolveRelativePath(path != null ? path : location2, currentLocation);
  return {
    fullPath: path + (searchString && "?") + searchString + hash,
    path,
    query,
    hash
  };
}
function stringifyURL(stringifyQuery2, location2) {
  const query = location2.query ? stringifyQuery2(location2.query) : "";
  return location2.path + (query && "?") + query + (location2.hash || "");
}
function stripBase(pathname, base) {
  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
    return pathname;
  return pathname.slice(base.length) || "/";
}
function isSameRouteLocation(stringifyQuery2, a, b) {
  const aLastIndex = a.matched.length - 1;
  const bLastIndex = b.matched.length - 1;
  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
}
function isSameRouteRecord(a, b) {
  return (a.aliasOf || a) === (b.aliasOf || b);
}
function isSameRouteLocationParams(a, b) {
  if (Object.keys(a).length !== Object.keys(b).length)
    return false;
  for (const key in a) {
    if (!isSameRouteLocationParamsValue(a[key], b[key]))
      return false;
  }
  return true;
}
function isSameRouteLocationParamsValue(a, b) {
  return isArray(a) ? isEquivalentArray(a, b) : isArray(b) ? isEquivalentArray(b, a) : a === b;
}
function isEquivalentArray(a, b) {
  return isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;
}
function resolveRelativePath(to, from) {
  if (to.startsWith("/"))
    return to;
  if (!to)
    return from;
  const fromSegments = from.split("/");
  const toSegments = to.split("/");
  const lastToSegment = toSegments[toSegments.length - 1];
  if (lastToSegment === ".." || lastToSegment === ".") {
    toSegments.push("");
  }
  let position = fromSegments.length - 1;
  let toPosition;
  let segment;
  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
    segment = toSegments[toPosition];
    if (segment === ".")
      continue;
    if (segment === "..") {
      if (position > 1)
        position--;
    } else
      break;
  }
  return fromSegments.slice(0, position).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
}
var NavigationType;
(function(NavigationType2) {
  NavigationType2["pop"] = "pop";
  NavigationType2["push"] = "push";
})(NavigationType || (NavigationType = {}));
var NavigationDirection;
(function(NavigationDirection2) {
  NavigationDirection2["back"] = "back";
  NavigationDirection2["forward"] = "forward";
  NavigationDirection2["unknown"] = "";
})(NavigationDirection || (NavigationDirection = {}));
function normalizeBase(base) {
  if (!base) {
    if (isBrowser) {
      const baseEl = document.querySelector("base");
      base = baseEl && baseEl.getAttribute("href") || "/";
      base = base.replace(/^\w+:\/\/[^\/]+/, "");
    } else {
      base = "/";
    }
  }
  if (base[0] !== "/" && base[0] !== "#")
    base = "/" + base;
  return removeTrailingSlash(base);
}
const BEFORE_HASH_RE = /^[^#]+#/;
function createHref(base, location2) {
  return base.replace(BEFORE_HASH_RE, "#") + location2;
}
function getElementPosition(el, offset) {
  const docRect = document.documentElement.getBoundingClientRect();
  const elRect = el.getBoundingClientRect();
  return {
    behavior: offset.behavior,
    left: elRect.left - docRect.left - (offset.left || 0),
    top: elRect.top - docRect.top - (offset.top || 0)
  };
}
const computeScrollPosition = () => ({
  left: window.pageXOffset,
  top: window.pageYOffset
});
function scrollToPosition(position) {
  let scrollToOptions;
  if ("el" in position) {
    const positionEl = position.el;
    const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
    const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
    if (!el) {
      return;
    }
    scrollToOptions = getElementPosition(el, position);
  } else {
    scrollToOptions = position;
  }
  if ("scrollBehavior" in document.documentElement.style)
    window.scrollTo(scrollToOptions);
  else {
    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
  }
}
function getScrollKey(path, delta2) {
  const position = history.state ? history.state.position - delta2 : -1;
  return position + path;
}
const scrollPositions = /* @__PURE__ */ new Map();
function saveScrollPosition(key, scrollPosition) {
  scrollPositions.set(key, scrollPosition);
}
function getSavedScrollPosition(key) {
  const scroll3 = scrollPositions.get(key);
  scrollPositions.delete(key);
  return scroll3;
}
let createBaseLocation = () => location.protocol + "//" + location.host;
function createCurrentLocation(base, location2) {
  const { pathname, search, hash } = location2;
  const hashPos = base.indexOf("#");
  if (hashPos > -1) {
    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
    let pathFromHash = hash.slice(slicePos);
    if (pathFromHash[0] !== "/")
      pathFromHash = "/" + pathFromHash;
    return stripBase(pathFromHash, "");
  }
  const path = stripBase(pathname, base);
  return path + search + hash;
}
function useHistoryListeners(base, historyState, currentLocation, replace2) {
  let listeners = [];
  let teardowns = [];
  let pauseState = null;
  const popStateHandler = ({ state }) => {
    const to = createCurrentLocation(base, location);
    const from = currentLocation.value;
    const fromState = historyState.value;
    let delta2 = 0;
    if (state) {
      currentLocation.value = to;
      historyState.value = state;
      if (pauseState && pauseState === from) {
        pauseState = null;
        return;
      }
      delta2 = fromState ? state.position - fromState.position : 0;
    } else {
      replace2(to);
    }
    listeners.forEach((listener) => {
      listener(currentLocation.value, from, {
        delta: delta2,
        type: NavigationType.pop,
        direction: delta2 ? delta2 > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
      });
    });
  };
  function pauseListeners() {
    pauseState = currentLocation.value;
  }
  function listen(callback) {
    listeners.push(callback);
    const teardown = () => {
      const index2 = listeners.indexOf(callback);
      if (index2 > -1)
        listeners.splice(index2, 1);
    };
    teardowns.push(teardown);
    return teardown;
  }
  function beforeUnloadListener() {
    const { history: history2 } = window;
    if (!history2.state)
      return;
    history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
  }
  function destroy() {
    for (const teardown of teardowns)
      teardown();
    teardowns = [];
    window.removeEventListener("popstate", popStateHandler);
    window.removeEventListener("beforeunload", beforeUnloadListener);
  }
  window.addEventListener("popstate", popStateHandler);
  window.addEventListener("beforeunload", beforeUnloadListener, {
    passive: true
  });
  return {
    pauseListeners,
    listen,
    destroy
  };
}
function buildState(back, current, forward, replaced = false, computeScroll = false) {
  return {
    back,
    current,
    forward,
    replaced,
    position: window.history.length,
    scroll: computeScroll ? computeScrollPosition() : null
  };
}
function useHistoryStateNavigation(base) {
  const { history: history2, location: location2 } = window;
  const currentLocation = {
    value: createCurrentLocation(base, location2)
  };
  const historyState = { value: history2.state };
  if (!historyState.value) {
    changeLocation(currentLocation.value, {
      back: null,
      current: currentLocation.value,
      forward: null,
      // the length is off by one, we need to decrease it
      position: history2.length - 1,
      replaced: true,
      // don't add a scroll as the user may have an anchor, and we want
      // scrollBehavior to be triggered without a saved position
      scroll: null
    }, true);
  }
  function changeLocation(to, state, replace3) {
    const hashIndex = base.indexOf("#");
    const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
    try {
      history2[replace3 ? "replaceState" : "pushState"](state, "", url);
      historyState.value = state;
    } catch (err) {
      {
        console.error(err);
      }
      location2[replace3 ? "replace" : "assign"](url);
    }
  }
  function replace2(to, data) {
    const state = assign({}, history2.state, buildState(
      historyState.value.back,
      // keep back and forward entries but override current position
      to,
      historyState.value.forward,
      true
    ), data, { position: historyState.value.position });
    changeLocation(to, state, true);
    currentLocation.value = to;
  }
  function push(to, data) {
    const currentState = assign(
      {},
      // use current history state to gracefully handle a wrong call to
      // history.replaceState
      // https://github.com/vuejs/router/issues/366
      historyState.value,
      history2.state,
      {
        forward: to,
        scroll: computeScrollPosition()
      }
    );
    changeLocation(currentState.current, currentState, true);
    const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
    changeLocation(to, state, false);
    currentLocation.value = to;
  }
  return {
    location: currentLocation,
    state: historyState,
    push,
    replace: replace2
  };
}
function createWebHistory(base) {
  base = normalizeBase(base);
  const historyNavigation = useHistoryStateNavigation(base);
  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
  function go(delta2, triggerListeners = true) {
    if (!triggerListeners)
      historyListeners.pauseListeners();
    history.go(delta2);
  }
  const routerHistory = assign({
    // it's overridden right after
    location: "",
    base,
    go,
    createHref: createHref.bind(null, base)
  }, historyNavigation, historyListeners);
  Object.defineProperty(routerHistory, "location", {
    enumerable: true,
    get: () => historyNavigation.location.value
  });
  Object.defineProperty(routerHistory, "state", {
    enumerable: true,
    get: () => historyNavigation.state.value
  });
  return routerHistory;
}
function isRouteLocation(route) {
  return typeof route === "string" || route && typeof route === "object";
}
function isRouteName(name) {
  return typeof name === "string" || typeof name === "symbol";
}
const START_LOCATION_NORMALIZED = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
const NavigationFailureSymbol = Symbol("");
var NavigationFailureType;
(function(NavigationFailureType2) {
  NavigationFailureType2[NavigationFailureType2["aborted"] = 4] = "aborted";
  NavigationFailureType2[NavigationFailureType2["cancelled"] = 8] = "cancelled";
  NavigationFailureType2[NavigationFailureType2["duplicated"] = 16] = "duplicated";
})(NavigationFailureType || (NavigationFailureType = {}));
function createRouterError(type, params) {
  {
    return assign(new Error(), {
      type,
      [NavigationFailureSymbol]: true
    }, params);
  }
}
function isNavigationFailure(error, type) {
  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));
}
const BASE_PARAM_PATTERN = "[^/]+?";
const BASE_PATH_PARSER_OPTIONS = {
  sensitive: false,
  strict: false,
  start: true,
  end: true
};
const REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
function tokensToParser(segments, extraOptions) {
  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
  const score = [];
  let pattern = options.start ? "^" : "";
  const keys = [];
  for (const segment of segments) {
    const segmentScores = segment.length ? [] : [
      90
      /* PathScore.Root */
    ];
    if (options.strict && !segment.length)
      pattern += "/";
    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
      const token = segment[tokenIndex];
      let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
      if (token.type === 0) {
        if (!tokenIndex)
          pattern += "/";
        pattern += token.value.replace(REGEX_CHARS_RE, "\\$&");
        subSegmentScore += 40;
      } else if (token.type === 1) {
        const { value, repeatable, optional, regexp } = token;
        keys.push({
          name: value,
          repeatable,
          optional
        });
        const re3 = regexp ? regexp : BASE_PARAM_PATTERN;
        if (re3 !== BASE_PARAM_PATTERN) {
          subSegmentScore += 10;
          try {
            new RegExp(`(${re3})`);
          } catch (err) {
            throw new Error(`Invalid custom RegExp for param "${value}" (${re3}): ` + err.message);
          }
        }
        let subPattern = repeatable ? `((?:${re3})(?:/(?:${re3}))*)` : `(${re3})`;
        if (!tokenIndex)
          subPattern = // avoid an optional / if there are more segments e.g. /:p?-static
          // or /:p?-:p2
          optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
        if (optional)
          subPattern += "?";
        pattern += subPattern;
        subSegmentScore += 20;
        if (optional)
          subSegmentScore += -8;
        if (repeatable)
          subSegmentScore += -20;
        if (re3 === ".*")
          subSegmentScore += -50;
      }
      segmentScores.push(subSegmentScore);
    }
    score.push(segmentScores);
  }
  if (options.strict && options.end) {
    const i = score.length - 1;
    score[i][score[i].length - 1] += 0.7000000000000001;
  }
  if (!options.strict)
    pattern += "/?";
  if (options.end)
    pattern += "$";
  else if (options.strict)
    pattern += "(?:/|$)";
  const re2 = new RegExp(pattern, options.sensitive ? "" : "i");
  function parse2(path) {
    const match = path.match(re2);
    const params = {};
    if (!match)
      return null;
    for (let i = 1; i < match.length; i++) {
      const value = match[i] || "";
      const key = keys[i - 1];
      params[key.name] = value && key.repeatable ? value.split("/") : value;
    }
    return params;
  }
  function stringify(params) {
    let path = "";
    let avoidDuplicatedSlash = false;
    for (const segment of segments) {
      if (!avoidDuplicatedSlash || !path.endsWith("/"))
        path += "/";
      avoidDuplicatedSlash = false;
      for (const token of segment) {
        if (token.type === 0) {
          path += token.value;
        } else if (token.type === 1) {
          const { value, repeatable, optional } = token;
          const param = value in params ? params[value] : "";
          if (isArray(param) && !repeatable) {
            throw new Error(`Provided param "${value}" is an array but it is not repeatable (* or + modifiers)`);
          }
          const text = isArray(param) ? param.join("/") : param;
          if (!text) {
            if (optional) {
              if (segment.length < 2) {
                if (path.endsWith("/"))
                  path = path.slice(0, -1);
                else
                  avoidDuplicatedSlash = true;
              }
            } else
              throw new Error(`Missing required param "${value}"`);
          }
          path += text;
        }
      }
    }
    return path || "/";
  }
  return {
    re: re2,
    score,
    keys,
    parse: parse2,
    stringify
  };
}
function compareScoreArray(a, b) {
  let i = 0;
  while (i < a.length && i < b.length) {
    const diff = b[i] - a[i];
    if (diff)
      return diff;
    i++;
  }
  if (a.length < b.length) {
    return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
  } else if (a.length > b.length) {
    return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
  }
  return 0;
}
function comparePathParserScore(a, b) {
  let i = 0;
  const aScore = a.score;
  const bScore = b.score;
  while (i < aScore.length && i < bScore.length) {
    const comp = compareScoreArray(aScore[i], bScore[i]);
    if (comp)
      return comp;
    i++;
  }
  if (Math.abs(bScore.length - aScore.length) === 1) {
    if (isLastScoreNegative(aScore))
      return 1;
    if (isLastScoreNegative(bScore))
      return -1;
  }
  return bScore.length - aScore.length;
}
function isLastScoreNegative(score) {
  const last = score[score.length - 1];
  return score.length > 0 && last[last.length - 1] < 0;
}
const ROOT_TOKEN = {
  type: 0,
  value: ""
};
const VALID_PARAM_RE = /[a-zA-Z0-9_]/;
function tokenizePath(path) {
  if (!path)
    return [[]];
  if (path === "/")
    return [[ROOT_TOKEN]];
  if (!path.startsWith("/")) {
    throw new Error(`Invalid path "${path}"`);
  }
  function crash(message) {
    throw new Error(`ERR (${state})/"${buffer2}": ${message}`);
  }
  let state = 0;
  let previousState = state;
  const tokens = [];
  let segment;
  function finalizeSegment() {
    if (segment)
      tokens.push(segment);
    segment = [];
  }
  let i = 0;
  let char;
  let buffer2 = "";
  let customRe = "";
  function consumeBuffer() {
    if (!buffer2)
      return;
    if (state === 0) {
      segment.push({
        type: 0,
        value: buffer2
      });
    } else if (state === 1 || state === 2 || state === 3) {
      if (segment.length > 1 && (char === "*" || char === "+"))
        crash(`A repeatable param (${buffer2}) must be alone in its segment. eg: '/:ids+.`);
      segment.push({
        type: 1,
        value: buffer2,
        regexp: customRe,
        repeatable: char === "*" || char === "+",
        optional: char === "*" || char === "?"
      });
    } else {
      crash("Invalid state to consume buffer");
    }
    buffer2 = "";
  }
  function addCharToBuffer() {
    buffer2 += char;
  }
  while (i < path.length) {
    char = path[i++];
    if (char === "\\" && state !== 2) {
      previousState = state;
      state = 4;
      continue;
    }
    switch (state) {
      case 0:
        if (char === "/") {
          if (buffer2) {
            consumeBuffer();
          }
          finalizeSegment();
        } else if (char === ":") {
          consumeBuffer();
          state = 1;
        } else {
          addCharToBuffer();
        }
        break;
      case 4:
        addCharToBuffer();
        state = previousState;
        break;
      case 1:
        if (char === "(") {
          state = 2;
        } else if (VALID_PARAM_RE.test(char)) {
          addCharToBuffer();
        } else {
          consumeBuffer();
          state = 0;
          if (char !== "*" && char !== "?" && char !== "+")
            i--;
        }
        break;
      case 2:
        if (char === ")") {
          if (customRe[customRe.length - 1] == "\\")
            customRe = customRe.slice(0, -1) + char;
          else
            state = 3;
        } else {
          customRe += char;
        }
        break;
      case 3:
        consumeBuffer();
        state = 0;
        if (char !== "*" && char !== "?" && char !== "+")
          i--;
        customRe = "";
        break;
      default:
        crash("Unknown state");
        break;
    }
  }
  if (state === 2)
    crash(`Unfinished custom RegExp for param "${buffer2}"`);
  consumeBuffer();
  finalizeSegment();
  return tokens;
}
function createRouteRecordMatcher(record, parent, options) {
  const parser = tokensToParser(tokenizePath(record.path), options);
  const matcher = assign(parser, {
    record,
    parent,
    // these needs to be populated by the parent
    children: [],
    alias: []
  });
  if (parent) {
    if (!matcher.record.aliasOf === !parent.record.aliasOf)
      parent.children.push(matcher);
  }
  return matcher;
}
function createRouterMatcher(routes, globalOptions) {
  const matchers = [];
  const matcherMap = /* @__PURE__ */ new Map();
  globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);
  function getRecordMatcher(name) {
    return matcherMap.get(name);
  }
  function addRoute(record, parent, originalRecord) {
    const isRootAdd = !originalRecord;
    const mainNormalizedRecord = normalizeRouteRecord(record);
    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
    const options = mergeOptions(globalOptions, record);
    const normalizedRecords = [
      mainNormalizedRecord
    ];
    if ("alias" in record) {
      const aliases2 = typeof record.alias === "string" ? [record.alias] : record.alias;
      for (const alias of aliases2) {
        normalizedRecords.push(assign({}, mainNormalizedRecord, {
          // this allows us to hold a copy of the `components` option
          // so that async components cache is hold on the original record
          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
          path: alias,
          // we might be the child of an alias
          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
          // the aliases are always of the same kind as the original since they
          // are defined on the same record
        }));
      }
    }
    let matcher;
    let originalMatcher;
    for (const normalizedRecord of normalizedRecords) {
      const { path } = normalizedRecord;
      if (parent && path[0] !== "/") {
        const parentPath = parent.record.path;
        const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
      }
      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
      if (originalRecord) {
        originalRecord.alias.push(matcher);
      } else {
        originalMatcher = originalMatcher || matcher;
        if (originalMatcher !== matcher)
          originalMatcher.alias.push(matcher);
        if (isRootAdd && record.name && !isAliasRecord(matcher))
          removeRoute(record.name);
      }
      if (mainNormalizedRecord.children) {
        const children = mainNormalizedRecord.children;
        for (let i = 0; i < children.length; i++) {
          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
        }
      }
      originalRecord = originalRecord || matcher;
      if (matcher.record.components && Object.keys(matcher.record.components).length || matcher.record.name || matcher.record.redirect) {
        insertMatcher(matcher);
      }
    }
    return originalMatcher ? () => {
      removeRoute(originalMatcher);
    } : noop;
  }
  function removeRoute(matcherRef) {
    if (isRouteName(matcherRef)) {
      const matcher = matcherMap.get(matcherRef);
      if (matcher) {
        matcherMap.delete(matcherRef);
        matchers.splice(matchers.indexOf(matcher), 1);
        matcher.children.forEach(removeRoute);
        matcher.alias.forEach(removeRoute);
      }
    } else {
      const index2 = matchers.indexOf(matcherRef);
      if (index2 > -1) {
        matchers.splice(index2, 1);
        if (matcherRef.record.name)
          matcherMap.delete(matcherRef.record.name);
        matcherRef.children.forEach(removeRoute);
        matcherRef.alias.forEach(removeRoute);
      }
    }
  }
  function getRoutes() {
    return matchers;
  }
  function insertMatcher(matcher) {
    let i = 0;
    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && // Adding children with empty path should still appear before the parent
    // https://github.com/vuejs/router/issues/1124
    (matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i])))
      i++;
    matchers.splice(i, 0, matcher);
    if (matcher.record.name && !isAliasRecord(matcher))
      matcherMap.set(matcher.record.name, matcher);
  }
  function resolve2(location2, currentLocation) {
    let matcher;
    let params = {};
    let path;
    let name;
    if ("name" in location2 && location2.name) {
      matcher = matcherMap.get(location2.name);
      if (!matcher)
        throw createRouterError(1, {
          location: location2
        });
      name = matcher.record.name;
      params = assign(
        // paramsFromLocation is a new object
        paramsFromLocation(
          currentLocation.params,
          // only keep params that exist in the resolved location
          // TODO: only keep optional params coming from a parent record
          matcher.keys.filter((k2) => !k2.optional).map((k2) => k2.name)
        ),
        // discard any existing params in the current location that do not exist here
        // #1497 this ensures better active/exact matching
        location2.params && paramsFromLocation(location2.params, matcher.keys.map((k2) => k2.name))
      );
      path = matcher.stringify(params);
    } else if ("path" in location2) {
      path = location2.path;
      matcher = matchers.find((m) => m.re.test(path));
      if (matcher) {
        params = matcher.parse(path);
        name = matcher.record.name;
      }
    } else {
      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
      if (!matcher)
        throw createRouterError(1, {
          location: location2,
          currentLocation
        });
      name = matcher.record.name;
      params = assign({}, currentLocation.params, location2.params);
      path = matcher.stringify(params);
    }
    const matched = [];
    let parentMatcher = matcher;
    while (parentMatcher) {
      matched.unshift(parentMatcher.record);
      parentMatcher = parentMatcher.parent;
    }
    return {
      name,
      path,
      params,
      matched,
      meta: mergeMetaFields(matched)
    };
  }
  routes.forEach((route) => addRoute(route));
  return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
}
function paramsFromLocation(params, keys) {
  const newParams = {};
  for (const key of keys) {
    if (key in params)
      newParams[key] = params[key];
  }
  return newParams;
}
function normalizeRouteRecord(record) {
  return {
    path: record.path,
    redirect: record.redirect,
    name: record.name,
    meta: record.meta || {},
    aliasOf: void 0,
    beforeEnter: record.beforeEnter,
    props: normalizeRecordProps(record),
    children: record.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in record ? record.components || null : record.component && { default: record.component }
  };
}
function normalizeRecordProps(record) {
  const propsObject = {};
  const props2 = record.props || false;
  if ("component" in record) {
    propsObject.default = props2;
  } else {
    for (const name in record.components)
      propsObject[name] = typeof props2 === "object" ? props2[name] : props2;
  }
  return propsObject;
}
function isAliasRecord(record) {
  while (record) {
    if (record.record.aliasOf)
      return true;
    record = record.parent;
  }
  return false;
}
function mergeMetaFields(matched) {
  return matched.reduce((meta, record) => assign(meta, record.meta), {});
}
function mergeOptions(defaults, partialOptions) {
  const options = {};
  for (const key in defaults) {
    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];
  }
  return options;
}
function isRecordChildOf(record, parent) {
  return parent.children.some((child) => child === record || isRecordChildOf(record, child));
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_BRACKET_OPEN_RE = /%5B/g;
const ENC_BRACKET_CLOSE_RE = /%5D/g;
const ENC_CARET_RE = /%5E/g;
const ENC_BACKTICK_RE = /%60/g;
const ENC_CURLY_OPEN_RE = /%7B/g;
const ENC_PIPE_RE = /%7C/g;
const ENC_CURLY_CLOSE_RE = /%7D/g;
const ENC_SPACE_RE = /%20/g;
function commonEncode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeHash(text) {
  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryValue(text) {
  return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
}
function encodeParam(text) {
  return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text) {
  try {
    return decodeURIComponent("" + text);
  } catch (err) {
  }
  return "" + text;
}
function parseQuery(search) {
  const query = {};
  if (search === "" || search === "?")
    return query;
  const hasLeadingIM = search[0] === "?";
  const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
  for (let i = 0; i < searchParams.length; ++i) {
    const searchParam = searchParams[i].replace(PLUS_RE, " ");
    const eqPos = searchParam.indexOf("=");
    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));
    if (key in query) {
      let currentValue = query[key];
      if (!isArray(currentValue)) {
        currentValue = query[key] = [currentValue];
      }
      currentValue.push(value);
    } else {
      query[key] = value;
    }
  }
  return query;
}
function stringifyQuery(query) {
  let search = "";
  for (let key in query) {
    const value = query[key];
    key = encodeQueryKey(key);
    if (value == null) {
      if (value !== void 0) {
        search += (search.length ? "&" : "") + key;
      }
      continue;
    }
    const values = isArray(value) ? value.map((v) => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];
    values.forEach((value2) => {
      if (value2 !== void 0) {
        search += (search.length ? "&" : "") + key;
        if (value2 != null)
          search += "=" + value2;
      }
    });
  }
  return search;
}
function normalizeQuery(query) {
  const normalizedQuery = {};
  for (const key in query) {
    const value = query[key];
    if (value !== void 0) {
      normalizedQuery[key] = isArray(value) ? value.map((v) => v == null ? null : "" + v) : value == null ? value : "" + value;
    }
  }
  return normalizedQuery;
}
const matchedRouteKey = Symbol("");
const viewDepthKey = Symbol("");
const routerKey = Symbol("");
const routeLocationKey = Symbol("");
const routerViewLocationKey = Symbol("");
function useCallbacks() {
  let handlers2 = [];
  function add2(handler) {
    handlers2.push(handler);
    return () => {
      const i = handlers2.indexOf(handler);
      if (i > -1)
        handlers2.splice(i, 1);
    };
  }
  function reset() {
    handlers2 = [];
  }
  return {
    add: add2,
    list: () => handlers2.slice(),
    reset
  };
}
function guardToPromiseFn(guard, to, from, record, name) {
  const enterCallbackArray = record && // name is defined if record is because of the function overload
  (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
  return () => new Promise((resolve2, reject) => {
    const next = (valid) => {
      if (valid === false) {
        reject(createRouterError(4, {
          from,
          to
        }));
      } else if (valid instanceof Error) {
        reject(valid);
      } else if (isRouteLocation(valid)) {
        reject(createRouterError(2, {
          from: to,
          to: valid
        }));
      } else {
        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are
        record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function") {
          enterCallbackArray.push(valid);
        }
        resolve2();
      }
    };
    const guardReturn = guard.call(record && record.instances[name], to, from, next);
    let guardCall = Promise.resolve(guardReturn);
    if (guard.length < 3)
      guardCall = guardCall.then(next);
    guardCall.catch((err) => reject(err));
  });
}
function extractComponentsGuards(matched, guardType, to, from) {
  const guards = [];
  for (const record of matched) {
    for (const name in record.components) {
      let rawComponent = record.components[name];
      if (guardType !== "beforeRouteEnter" && !record.instances[name])
        continue;
      if (isRouteComponent(rawComponent)) {
        const options = rawComponent.__vccOpts || rawComponent;
        const guard = options[guardType];
        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
      } else {
        let componentPromise = rawComponent();
        guards.push(() => componentPromise.then((resolved) => {
          if (!resolved)
            return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
          record.components[name] = resolvedComponent;
          const options = resolvedComponent.__vccOpts || resolvedComponent;
          const guard = options[guardType];
          return guard && guardToPromiseFn(guard, to, from, record, name)();
        }));
      }
    }
  }
  return guards;
}
function isRouteComponent(component) {
  return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
}
function useLink(props2) {
  const router2 = inject$1(routerKey);
  const currentRoute = inject$1(routeLocationKey);
  const route = computed(() => router2.resolve(unref(props2.to)));
  const activeRecordIndex = computed(() => {
    const { matched } = route.value;
    const { length } = matched;
    const routeMatched = matched[length - 1];
    const currentMatched = currentRoute.matched;
    if (!routeMatched || !currentMatched.length)
      return -1;
    const index2 = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));
    if (index2 > -1)
      return index2;
    const parentRecordPath = getOriginalPath(matched[length - 2]);
    return (
      // we are dealing with nested routes
      length > 1 && // if the parent and matched route have the same path, this link is
      // referring to the empty child. Or we currently are on a different
      // child of the same parent
      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent
      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index2
    );
  });
  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));
  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
  function navigate(e = {}) {
    if (guardEvent(e)) {
      return router2[unref(props2.replace) ? "replace" : "push"](
        unref(props2.to)
        // avoid uncaught errors are they are logged anyway
      ).catch(noop);
    }
    return Promise.resolve();
  }
  return {
    route,
    href: computed(() => route.value.href),
    isActive,
    isExactActive,
    navigate
  };
}
const RouterLinkImpl = /* @__PURE__ */ defineComponent$1({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: true
    },
    replace: Boolean,
    activeClass: String,
    // inactiveClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    }
  },
  useLink,
  setup(props2, { slots }) {
    const link = reactive(useLink(props2));
    const { options } = inject$1(routerKey);
    const elClass = computed(() => ({
      [getLinkClass(props2.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
      // [getLinkClass(
      //   props.inactiveClass,
      //   options.linkInactiveClass,
      //   'router-link-inactive'
      // )]: !link.isExactActive,
      [getLinkClass(props2.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
    }));
    return () => {
      const children = slots.default && slots.default(link);
      return props2.custom ? children : h("a", {
        "aria-current": link.isExactActive ? props2.ariaCurrentValue : null,
        href: link.href,
        // this would override user added attrs but Vue will still add
        // the listener, so we end up triggering both
        onClick: link.navigate,
        class: elClass.value
      }, children);
    };
  }
});
const RouterLink = RouterLinkImpl;
function guardEvent(e) {
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
    return;
  if (e.defaultPrevented)
    return;
  if (e.button !== void 0 && e.button !== 0)
    return;
  if (e.currentTarget && e.currentTarget.getAttribute) {
    const target = e.currentTarget.getAttribute("target");
    if (/\b_blank\b/i.test(target))
      return;
  }
  if (e.preventDefault)
    e.preventDefault();
  return true;
}
function includesParams(outer, inner) {
  for (const key in inner) {
    const innerValue = inner[key];
    const outerValue = outer[key];
    if (typeof innerValue === "string") {
      if (innerValue !== outerValue)
        return false;
    } else {
      if (!isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i]))
        return false;
    }
  }
  return true;
}
function getOriginalPath(record) {
  return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
}
const getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
const RouterViewImpl = /* @__PURE__ */ defineComponent$1({
  name: "RouterView",
  // #674 we manually inherit them
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  // Better compat for @vue/compat users
  // https://github.com/vuejs/router/issues/1315
  compatConfig: { MODE: 3 },
  setup(props2, { attrs, slots }) {
    const injectedRoute = inject$1(routerViewLocationKey);
    const routeToDisplay = computed(() => props2.route || injectedRoute.value);
    const injectedDepth = inject$1(viewDepthKey, 0);
    const depth = computed(() => {
      let initialDepth = unref(injectedDepth);
      const { matched } = routeToDisplay.value;
      let matchedRoute;
      while ((matchedRoute = matched[initialDepth]) && !matchedRoute.components) {
        initialDepth++;
      }
      return initialDepth;
    });
    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth.value]);
    provide(viewDepthKey, computed(() => depth.value + 1));
    provide(matchedRouteKey, matchedRouteRef);
    provide(routerViewLocationKey, routeToDisplay);
    const viewRef = ref();
    watch(() => [viewRef.value, matchedRouteRef.value, props2.name], ([instance, to, name], [oldInstance, from, oldName]) => {
      if (to) {
        to.instances[name] = instance;
        if (from && from !== to && instance && instance === oldInstance) {
          if (!to.leaveGuards.size) {
            to.leaveGuards = from.leaveGuards;
          }
          if (!to.updateGuards.size) {
            to.updateGuards = from.updateGuards;
          }
        }
      }
      if (instance && to && // if there is no instance but to and from are the same this might be
      // the first visit
      (!from || !isSameRouteRecord(to, from) || !oldInstance)) {
        (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
      }
    }, { flush: "post" });
    return () => {
      const route = routeToDisplay.value;
      const currentName = props2.name;
      const matchedRoute = matchedRouteRef.value;
      const ViewComponent = matchedRoute && matchedRoute.components[currentName];
      if (!ViewComponent) {
        return normalizeSlot(slots.default, { Component: ViewComponent, route });
      }
      const routePropsOption = matchedRoute.props[currentName];
      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
      const onVnodeUnmounted = (vnode) => {
        if (vnode.component.isUnmounted) {
          matchedRoute.instances[currentName] = null;
        }
      };
      const component = h(ViewComponent, assign({}, routeProps, attrs, {
        onVnodeUnmounted,
        ref: viewRef
      }));
      return (
        // pass the vnode to the slot as a prop.
        // h and <component :is="..."> both accept vnodes
        normalizeSlot(slots.default, { Component: component, route }) || component
      );
    };
  }
});
function normalizeSlot(slot, data) {
  if (!slot)
    return null;
  const slotContent = slot(data);
  return slotContent.length === 1 ? slotContent[0] : slotContent;
}
const RouterView = RouterViewImpl;
function createRouter(options) {
  const matcher = createRouterMatcher(options.routes, options);
  const parseQuery$1 = options.parseQuery || parseQuery;
  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
  const routerHistory = options.history;
  const beforeGuards = useCallbacks();
  const beforeResolveGuards = useCallbacks();
  const afterGuards = useCallbacks();
  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);
  let pendingLocation = START_LOCATION_NORMALIZED;
  if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
    history.scrollRestoration = "manual";
  }
  const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
  const encodeParams = applyToParams.bind(null, encodeParam);
  const decodeParams = (
    // @ts-expect-error: intentionally avoid the type check
    applyToParams.bind(null, decode)
  );
  function addRoute(parentOrRoute, route) {
    let parent;
    let record;
    if (isRouteName(parentOrRoute)) {
      parent = matcher.getRecordMatcher(parentOrRoute);
      record = route;
    } else {
      record = parentOrRoute;
    }
    return matcher.addRoute(record, parent);
  }
  function removeRoute(name) {
    const recordMatcher = matcher.getRecordMatcher(name);
    if (recordMatcher) {
      matcher.removeRoute(recordMatcher);
    }
  }
  function getRoutes() {
    return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
  }
  function hasRoute(name) {
    return !!matcher.getRecordMatcher(name);
  }
  function resolve2(rawLocation, currentLocation) {
    currentLocation = assign({}, currentLocation || currentRoute.value);
    if (typeof rawLocation === "string") {
      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
      const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
      const href2 = routerHistory.createHref(locationNormalized.fullPath);
      return assign(locationNormalized, matchedRoute2, {
        params: decodeParams(matchedRoute2.params),
        hash: decode(locationNormalized.hash),
        redirectedFrom: void 0,
        href: href2
      });
    }
    let matcherLocation;
    if ("path" in rawLocation) {
      matcherLocation = assign({}, rawLocation, {
        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
      });
    } else {
      const targetParams = assign({}, rawLocation.params);
      for (const key in targetParams) {
        if (targetParams[key] == null) {
          delete targetParams[key];
        }
      }
      matcherLocation = assign({}, rawLocation, {
        params: encodeParams(targetParams)
      });
      currentLocation.params = encodeParams(currentLocation.params);
    }
    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
    const hash = rawLocation.hash || "";
    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
      hash: encodeHash(hash),
      path: matchedRoute.path
    }));
    const href = routerHistory.createHref(fullPath);
    return assign({
      fullPath,
      // keep the hash encoded so fullPath is effectively path + encodedQuery +
      // hash
      hash,
      query: (
        // if the user is using a custom query lib like qs, we might have
        // nested objects, so we keep the query as is, meaning it can contain
        // numbers at `$route.query`, but at the point, the user will have to
        // use their own type anyway.
        // https://github.com/vuejs/router/issues/328#issuecomment-649481567
        stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
      )
    }, matchedRoute, {
      redirectedFrom: void 0,
      href
    });
  }
  function locationAsObject(to) {
    return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
  }
  function checkCanceledNavigation(to, from) {
    if (pendingLocation !== to) {
      return createRouterError(8, {
        from,
        to
      });
    }
  }
  function push(to) {
    return pushWithRedirect(to);
  }
  function replace2(to) {
    return push(assign(locationAsObject(to), { replace: true }));
  }
  function handleRedirectRecord(to) {
    const lastMatched = to.matched[to.matched.length - 1];
    if (lastMatched && lastMatched.redirect) {
      const { redirect } = lastMatched;
      let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
      if (typeof newTargetLocation === "string") {
        newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : (
          // force empty params
          { path: newTargetLocation }
        );
        newTargetLocation.params = {};
      }
      return assign({
        query: to.query,
        hash: to.hash,
        // avoid transferring params if the redirect has a path
        params: "path" in newTargetLocation ? {} : to.params
      }, newTargetLocation);
    }
  }
  function pushWithRedirect(to, redirectedFrom) {
    const targetLocation = pendingLocation = resolve2(to);
    const from = currentRoute.value;
    const data = to.state;
    const force = to.force;
    const replace3 = to.replace === true;
    const shouldRedirect = handleRedirectRecord(targetLocation);
    if (shouldRedirect)
      return pushWithRedirect(
        assign(locationAsObject(shouldRedirect), {
          state: typeof shouldRedirect === "object" ? assign({}, data, shouldRedirect.state) : data,
          force,
          replace: replace3
        }),
        // keep original redirectedFrom if it exists
        redirectedFrom || targetLocation
      );
    const toLocation = targetLocation;
    toLocation.redirectedFrom = redirectedFrom;
    let failure;
    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
      failure = createRouterError(16, { to: toLocation, from });
      handleScroll(
        from,
        from,
        // this is a push, the only way for it to be triggered from a
        // history.listen is with a redirect, which makes it become a push
        true,
        // This cannot be the first navigation because the initial location
        // cannot be manually navigated to
        false
      );
    }
    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? (
      // navigation redirects still mark the router as ready
      isNavigationFailure(
        error,
        2
        /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
      ) ? error : markAsReady(error)
    ) : (
      // reject any unknown error
      triggerError(error, toLocation, from)
    )).then((failure2) => {
      if (failure2) {
        if (isNavigationFailure(
          failure2,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          return pushWithRedirect(
            // keep options
            assign({
              // preserve an existing replacement but allow the redirect to override it
              replace: replace3
            }, locationAsObject(failure2.to), {
              state: typeof failure2.to === "object" ? assign({}, data, failure2.to.state) : data,
              force
            }),
            // preserve the original redirectedFrom if any
            redirectedFrom || toLocation
          );
        }
      } else {
        failure2 = finalizeNavigation(toLocation, from, true, replace3, data);
      }
      triggerAfterEach(toLocation, from, failure2);
      return failure2;
    });
  }
  function checkCanceledNavigationAndReject(to, from) {
    const error = checkCanceledNavigation(to, from);
    return error ? Promise.reject(error) : Promise.resolve();
  }
  function runWithContext(fn) {
    const app2 = installedApps.values().next().value;
    return app2 && typeof app2.runWithContext === "function" ? app2.runWithContext(fn) : fn();
  }
  function navigate(to, from) {
    let guards;
    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
    guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
    for (const record of leavingRecords) {
      record.leaveGuards.forEach((guard) => {
        guards.push(guardToPromiseFn(guard, to, from));
      });
    }
    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
    guards.push(canceledNavigationCheck);
    return runGuardQueue(guards).then(() => {
      guards = [];
      for (const guard of beforeGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
      for (const record of updatingRecords) {
        record.updateGuards.forEach((guard) => {
          guards.push(guardToPromiseFn(guard, to, from));
        });
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const record of enteringRecords) {
        if (record.beforeEnter) {
          if (isArray(record.beforeEnter)) {
            for (const beforeEnter of record.beforeEnter)
              guards.push(guardToPromiseFn(beforeEnter, to, from));
          } else {
            guards.push(guardToPromiseFn(record.beforeEnter, to, from));
          }
        }
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      to.matched.forEach((record) => record.enterCallbacks = {});
      guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).then(() => {
      guards = [];
      for (const guard of beforeResolveGuards.list()) {
        guards.push(guardToPromiseFn(guard, to, from));
      }
      guards.push(canceledNavigationCheck);
      return runGuardQueue(guards);
    }).catch((err) => isNavigationFailure(
      err,
      8
      /* ErrorTypes.NAVIGATION_CANCELLED */
    ) ? err : Promise.reject(err));
  }
  function triggerAfterEach(to, from, failure) {
    afterGuards.list().forEach((guard) => runWithContext(() => guard(to, from, failure)));
  }
  function finalizeNavigation(toLocation, from, isPush, replace3, data) {
    const error = checkCanceledNavigation(toLocation, from);
    if (error)
      return error;
    const isFirstNavigation = from === START_LOCATION_NORMALIZED;
    const state = !isBrowser ? {} : history.state;
    if (isPush) {
      if (replace3 || isFirstNavigation)
        routerHistory.replace(toLocation.fullPath, assign({
          scroll: isFirstNavigation && state && state.scroll
        }, data));
      else
        routerHistory.push(toLocation.fullPath, data);
    }
    currentRoute.value = toLocation;
    handleScroll(toLocation, from, isPush, isFirstNavigation);
    markAsReady();
  }
  let removeHistoryListener;
  function setupListeners() {
    if (removeHistoryListener)
      return;
    removeHistoryListener = routerHistory.listen((to, _from, info) => {
      if (!router2.listening)
        return;
      const toLocation = resolve2(to);
      const shouldRedirect = handleRedirectRecord(toLocation);
      if (shouldRedirect) {
        pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);
        return;
      }
      pendingLocation = toLocation;
      const from = currentRoute.value;
      if (isBrowser) {
        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
      }
      navigate(toLocation, from).catch((error) => {
        if (isNavigationFailure(
          error,
          4 | 8
          /* ErrorTypes.NAVIGATION_CANCELLED */
        )) {
          return error;
        }
        if (isNavigationFailure(
          error,
          2
          /* ErrorTypes.NAVIGATION_GUARD_REDIRECT */
        )) {
          pushWithRedirect(
            error.to,
            toLocation
            // avoid an uncaught rejection, let push call triggerError
          ).then((failure) => {
            if (isNavigationFailure(
              failure,
              4 | 16
              /* ErrorTypes.NAVIGATION_DUPLICATED */
            ) && !info.delta && info.type === NavigationType.pop) {
              routerHistory.go(-1, false);
            }
          }).catch(noop);
          return Promise.reject();
        }
        if (info.delta) {
          routerHistory.go(-info.delta, false);
        }
        return triggerError(error, toLocation, from);
      }).then((failure) => {
        failure = failure || finalizeNavigation(
          // after navigation, all matched components are resolved
          toLocation,
          from,
          false
        );
        if (failure) {
          if (info.delta && // a new navigation has been triggered, so we do not want to revert, that will change the current history
          // entry while a different route is displayed
          !isNavigationFailure(
            failure,
            8
            /* ErrorTypes.NAVIGATION_CANCELLED */
          )) {
            routerHistory.go(-info.delta, false);
          } else if (info.type === NavigationType.pop && isNavigationFailure(
            failure,
            4 | 16
            /* ErrorTypes.NAVIGATION_DUPLICATED */
          )) {
            routerHistory.go(-1, false);
          }
        }
        triggerAfterEach(toLocation, from, failure);
      }).catch(noop);
    });
  }
  let readyHandlers = useCallbacks();
  let errorListeners = useCallbacks();
  let ready;
  function triggerError(error, to, from) {
    markAsReady(error);
    const list = errorListeners.list();
    if (list.length) {
      list.forEach((handler) => handler(error, to, from));
    } else {
      console.error(error);
    }
    return Promise.reject(error);
  }
  function isReady() {
    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)
      return Promise.resolve();
    return new Promise((resolve3, reject) => {
      readyHandlers.add([resolve3, reject]);
    });
  }
  function markAsReady(err) {
    if (!ready) {
      ready = !err;
      setupListeners();
      readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
      readyHandlers.reset();
    }
    return err;
  }
  function handleScroll(to, from, isPush, isFirstNavigation) {
    const { scrollBehavior } = options;
    if (!isBrowser || !scrollBehavior)
      return Promise.resolve();
    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position) => position && scrollToPosition(position)).catch((err) => triggerError(err, to, from));
  }
  const go = (delta2) => routerHistory.go(delta2);
  let started;
  const installedApps = /* @__PURE__ */ new Set();
  const router2 = {
    currentRoute,
    listening: true,
    addRoute,
    removeRoute,
    hasRoute,
    getRoutes,
    resolve: resolve2,
    options,
    push,
    replace: replace2,
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: beforeGuards.add,
    beforeResolve: beforeResolveGuards.add,
    afterEach: afterGuards.add,
    onError: errorListeners.add,
    isReady,
    install(app2) {
      const router3 = this;
      app2.component("RouterLink", RouterLink);
      app2.component("RouterView", RouterView);
      app2.config.globalProperties.$router = router3;
      Object.defineProperty(app2.config.globalProperties, "$route", {
        enumerable: true,
        get: () => unref(currentRoute)
      });
      if (isBrowser && // used for the initial navigation client side to avoid pushing
      // multiple times when the router is used in multiple apps
      !started && currentRoute.value === START_LOCATION_NORMALIZED) {
        started = true;
        push(routerHistory.location).catch((err) => {
        });
      }
      const reactiveRoute = {};
      for (const key in START_LOCATION_NORMALIZED) {
        Object.defineProperty(reactiveRoute, key, {
          get: () => currentRoute.value[key],
          enumerable: true
        });
      }
      app2.provide(routerKey, router3);
      app2.provide(routeLocationKey, shallowReactive(reactiveRoute));
      app2.provide(routerViewLocationKey, currentRoute);
      const unmountApp = app2.unmount;
      installedApps.add(app2);
      app2.unmount = function() {
        installedApps.delete(app2);
        if (installedApps.size < 1) {
          pendingLocation = START_LOCATION_NORMALIZED;
          removeHistoryListener && removeHistoryListener();
          removeHistoryListener = null;
          currentRoute.value = START_LOCATION_NORMALIZED;
          started = false;
          ready = false;
        }
        unmountApp();
      };
    }
  };
  function runGuardQueue(guards) {
    return guards.reduce((promise, guard) => promise.then(() => runWithContext(guard)), Promise.resolve());
  }
  return router2;
}
function extractChangingRecords(to, from) {
  const leavingRecords = [];
  const updatingRecords = [];
  const enteringRecords = [];
  const len = Math.max(from.matched.length, to.matched.length);
  for (let i = 0; i < len; i++) {
    const recordFrom = from.matched[i];
    if (recordFrom) {
      if (to.matched.find((record) => isSameRouteRecord(record, recordFrom)))
        updatingRecords.push(recordFrom);
      else
        leavingRecords.push(recordFrom);
    }
    const recordTo = to.matched[i];
    if (recordTo) {
      if (!from.matched.find((record) => isSameRouteRecord(record, recordTo))) {
        enteringRecords.push(recordTo);
      }
    }
  }
  return [leavingRecords, updatingRecords, enteringRecords];
}
function useRouter() {
  return inject$1(routerKey);
}
function useRoute() {
  return inject$1(routeLocationKey);
}
const _sfc_main$1 = /* @__PURE__ */ defineComponent$1({
  __name: "theme-toggle",
  setup(__props) {
    const theme = useTheme();
    function toggleTheme() {
      theme.global.name.value = theme.global.current.value.dark ? "light" : "dark";
      localStorage.setItem("theme", theme.global.name.value);
    }
    const icon = computed(
      () => theme.global.current.value.dark ? "mdi-white-balance-sunny" : "mdi-weather-night"
    );
    onMounted(() => {
      theme.global.name.value = localStorage.getItem("theme") || "light";
    });
    return (_ctx, _cache) => {
      const _component_v_btn = resolveComponent("v-btn");
      return openBlock(), createBlock(_component_v_btn, {
        icon: icon.value,
        onClick: _cache[0] || (_cache[0] = ($event) => toggleTheme())
      }, null, 8, ["icon"]);
    };
  }
});
const _hoisted_1 = /* @__PURE__ */ createBaseVNode("div", { class: "flex-grow-1" }, "E-Dictionry", -1);
const _hoisted_2 = { class: "text-capitalize font-weight-regular" };
const _hoisted_3 = { class: "d-flex flex-column pa-4 flex-grow-1 overflow-hidden" };
const _sfc_main = /* @__PURE__ */ defineComponent$1({
  __name: "app",
  setup(__props) {
    const routes = [
      { name: "start", title: "Start" },
      { name: "words", title: "Words" },
      { name: "sets", title: "Sets" },
      { name: "practice", title: "Practice" },
      { name: "irregular-verbs", title: "Irregular verbs" }
    ];
    const router2 = useRouter();
    const currentRoute = useRoute();
    const header = computed(() => {
      return currentRoute.matched[0]?.meta.alias || "";
    });
    onMounted(() => router2.push({ name: "start" }));
    return (_ctx, _cache) => {
      const _component_v_divider = resolveComponent("v-divider");
      const _component_v_sheet = resolveComponent("v-sheet");
      const _component_v_list_item = resolveComponent("v-list-item");
      const _component_v_list = resolveComponent("v-list");
      const _component_v_navigation_drawer = resolveComponent("v-navigation-drawer");
      const _component_v_banner = resolveComponent("v-banner");
      const _component_router_view = resolveComponent("router-view");
      const _component_v_main = resolveComponent("v-main");
      const _component_v_app = resolveComponent("v-app");
      return openBlock(), createBlock(_component_v_app, null, {
        default: withCtx(() => [
          createVNode(_component_v_navigation_drawer, {
            permanent: true,
            color: "grey-darken-4"
          }, {
            prepend: withCtx(() => [
              createVNode(_component_v_divider),
              createVNode(_component_v_sheet, {
                height: "100",
                color: "grey-darken-4",
                class: "d-flex align-center justify-around pa-4"
              }, {
                default: withCtx(() => [
                  _hoisted_1,
                  createVNode(_sfc_main$1)
                ]),
                _: 1
              }),
              createVNode(_component_v_divider)
            ]),
            append: withCtx(() => [
              createVNode(_component_v_list, null, {
                default: withCtx(() => [
                  createVNode(_component_v_list_item, { to: { name: "import-export" } }, {
                    default: withCtx(() => [
                      createTextVNode(" Import / export data ")
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            default: withCtx(() => [
              createVNode(_component_v_list, null, {
                default: withCtx(() => [
                  (openBlock(), createElementBlock(Fragment, null, renderList(routes, (route) => {
                    return createVNode(_component_v_list_item, {
                      key: route.name,
                      to: route
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(route.title), 1)
                      ]),
                      _: 2
                    }, 1032, ["to"]);
                  }), 64))
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_v_main, { class: "d-flex flex-column overflow-hidden h-screen" }, {
            default: withCtx(() => [
              createVNode(_component_v_banner, {
                height: 100,
                class: "flex-grow-0",
                style: { "min-height": "60px" }
              }, {
                default: withCtx(() => [
                  createBaseVNode("h3", _hoisted_2, toDisplayString(header.value), 1)
                ]),
                _: 1
              }),
              createBaseVNode("div", _hoisted_3, [
                createVNode(_component_router_view)
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
});
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link2 = links[i];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e = new Event("vite:preloadError", { cancelable: true });
    e.payload = err;
    window.dispatchEvent(e);
    if (!e.defaultPrevented) {
      throw err;
    }
  });
};
const startRoute = {
  name: "start",
  path: "/start",
  meta: { alias: "Start" },
  component: () => __vitePreload(() => import("./start-1ddafb33.js"), true ? ["./start-1ddafb33.js","./_plugin-vue_export-helper-cc2b3d55.js"] : void 0, import.meta.url)
};
const addWordRoute = {
  name: "add-word",
  path: "/add-word",
  component: () => __vitePreload(() => import("./add-word-6447100b.js"), true ? ["./add-word-6447100b.js","./word-form.vue_vue_type_script_setup_true_lang-d17f76e1.js","./required-5fd17c0e.js","./link-chip.vue_vue_type_script_setup_true_lang-5e600a48.js"] : void 0, import.meta.url)
};
const wordListRoute = {
  name: "word-list",
  path: "/word-list",
  component: () => __vitePreload(() => import("./word-list-f96c577f.js"), true ? ["./word-list-f96c577f.js","./confirm-dialog.vue_vue_type_script_setup_true_lang-0ad942f2.js","./use-filter-by-key-8e7d5353.js","./speak.vue_vue_type_script_setup_true_lang-36db1f78.js","./link-chip.vue_vue_type_script_setup_true_lang-5e600a48.js"] : void 0, import.meta.url)
};
const editWordListRoute = {
  name: "edit-word",
  path: "/edit-word/:id",
  component: () => __vitePreload(() => import("./edit-word-b449b15b.js"), true ? ["./edit-word-b449b15b.js","./word-form.vue_vue_type_script_setup_true_lang-d17f76e1.js","./required-5fd17c0e.js","./link-chip.vue_vue_type_script_setup_true_lang-5e600a48.js"] : void 0, import.meta.url)
};
const wordsRoute = {
  name: "words",
  path: "/words",
  meta: { alias: "Words" },
  redirect: wordListRoute.path,
  component: () => __vitePreload(() => import("./words-e33cff18.js"), true ? ["./words-e33cff18.js","./_plugin-vue_export-helper-cc2b3d55.js"] : void 0, import.meta.url),
  children: [wordListRoute, addWordRoute, editWordListRoute]
};
const addSetRoute = {
  name: "add-set",
  path: "/add-set",
  component: () => __vitePreload(() => import("./add-set-b8dac6f4.js"), true ? ["./add-set-b8dac6f4.js","./set-form.vue_vue_type_script_setup_true_lang-034d92f1.js","./required-5fd17c0e.js"] : void 0, import.meta.url)
};
const setListRoute = {
  name: "set-list",
  path: "/set-list",
  component: () => __vitePreload(() => import("./set-list-2465814b.js"), true ? ["./set-list-2465814b.js","./confirm-dialog.vue_vue_type_script_setup_true_lang-0ad942f2.js","./use-filter-by-key-8e7d5353.js"] : void 0, import.meta.url)
};
const editSetListRoute = {
  name: "edit-set",
  path: "/edit-set/:id",
  component: () => __vitePreload(() => import("./edit-set-8bfd6b99.js"), true ? ["./edit-set-8bfd6b99.js","./set-form.vue_vue_type_script_setup_true_lang-034d92f1.js","./required-5fd17c0e.js"] : void 0, import.meta.url)
};
const setsRoute = {
  name: "sets",
  path: "/sets",
  meta: { alias: "Sets" },
  redirect: setListRoute.path,
  component: () => __vitePreload(() => import("./sets-14aa2447.js"), true ? ["./sets-14aa2447.js","./_plugin-vue_export-helper-cc2b3d55.js"] : void 0, import.meta.url),
  children: [setListRoute, addSetRoute, editSetListRoute]
};
const testingRoute = {
  name: "testing",
  path: "/testing/:id",
  component: () => __vitePreload(() => import("./testing-aa34c754.js"), true ? ["./testing-aa34c754.js","./speak.vue_vue_type_script_setup_true_lang-36db1f78.js","./_plugin-vue_export-helper-cc2b3d55.js","./testing-92d40536.css"] : void 0, import.meta.url)
};
const practiceSetsRoute = {
  name: "practice-sets",
  path: "/practice-sets",
  component: () => __vitePreload(() => import("./practice-sets-25f380f2.js"), true ? ["./practice-sets-25f380f2.js","./use-filter-by-key-8e7d5353.js"] : void 0, import.meta.url)
};
const practiceRoute = {
  name: "practice",
  path: "/practice",
  meta: { alias: "Practice" },
  redirect: practiceSetsRoute.path,
  component: () => __vitePreload(() => import("./practice-dab6fbc8.js"), true ? ["./practice-dab6fbc8.js","./_plugin-vue_export-helper-cc2b3d55.js"] : void 0, import.meta.url),
  children: [testingRoute, practiceSetsRoute]
};
const irregularVerbs = {
  name: "irregular-verbs",
  path: "/irregular-verbs",
  meta: { alias: "Irregular verbs" },
  component: () => __vitePreload(() => import("./irregular-verbs-e79e773b.js"), true ? ["./irregular-verbs-e79e773b.js","./speak.vue_vue_type_script_setup_true_lang-36db1f78.js"] : void 0, import.meta.url)
};
const exportRoute = {
  name: "export",
  path: "/export",
  component: () => __vitePreload(() => import("./export-bf20fadf.js"), true ? [] : void 0, import.meta.url)
};
const importRoute = {
  name: "import",
  path: "/import",
  component: () => __vitePreload(() => import("./import-7f61147a.js"), true ? ["./import-7f61147a.js","./confirm-dialog.vue_vue_type_script_setup_true_lang-0ad942f2.js"] : void 0, import.meta.url)
};
const importExport = {
  name: "import-export",
  path: "/import-export",
  meta: { alias: "Import / export data" },
  redirect: importRoute.path,
  component: () => __vitePreload(() => import("./import-export-e11e801d.js"), true ? ["./import-export-e11e801d.js","./_plugin-vue_export-helper-cc2b3d55.js"] : void 0, import.meta.url),
  children: [exportRoute, importRoute]
};
const router = createRouter({
  routes: [
    { path: "/", redirect: "/start" },
    startRoute,
    wordsRoute,
    setsRoute,
    practiceRoute,
    irregularVerbs,
    importExport
  ],
  history: createWebHistory()
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k2) {
    var d = Object.getOwnPropertyDescriptor(n, k2);
    Object.defineProperty(a, k2, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k2];
      }
    });
  });
  return a;
}
var npm_export = { exports: {} };
var jsstore_commonjs2_min = { exports: {} };
/*! For license information please see jsstore.commonjs2.min.js.LICENSE.txt */
(() => {
  var e = { d: (t2, n2) => {
    for (var o2 in n2)
      e.o(n2, o2) && !e.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: n2[o2] });
  }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
  } }, t = {};
  e.r(t), e.d(t, { API: () => r2, CONNECTION_STATUS: () => p2, Connection: () => b, DATA_TYPE: () => o, ERROR_TYPE: () => l2, EVENT: () => i, IDB_MODE: () => u, OCCURENCE: () => a, QUERY_OPTION: () => s, WORKER_STATUS: () => n, forObj: () => q, promise: () => d, promiseAll: () => v, promiseResolve: () => f });
  var n, o, r2, i, s, u, a, p2, c2 = function() {
    function e2(e3, t2) {
      this.type = e3, this._info = t2, this.message = this.getMsg();
    }
    return e2.prototype.throw = function() {
      throw this;
    }, e2.prototype.log = function(e3) {
      this.status && console.log(e3);
    }, e2.prototype.logError = function() {
      console.error(this.get());
    }, e2.prototype.logWarning = function() {
      console.warn(this.get());
    }, e2.prototype.get = function() {
      return { message: this.message, type: this.type };
    }, e2.prototype.getMsg = function() {
      return this.type, this.message;
    }, e2;
  }(), l2 = { InvalidUpdateColumn: "invalid_update_column", UndefinedColumn: "undefined_column", UndefinedValue: "undefined_value", UndefinedColumnName: "undefined_column_name", UndefinedDbName: "undefined_database_name", UndefinedColumnValue: "undefined_column_value", NotArray: "not_array", NoValueSupplied: "no_value_supplied", ColumnNotExist: "column_not_exist", NoIndexFound: "no_index_found", InvalidOp: "invalid_operator", NullValue: "null_value", WrongDataType: "wrong_data_type", TableNotExist: "table_not_exist", DbNotExist: "db_not_exist", ConnectionAborted: "connection_aborted", ConnectionClosed: "connection_closed", NotObject: "not_object", InvalidConfig: "invalid_config", DbBlocked: "Db_blocked", IndexedDbNotSupported: "indexeddb_not_supported", NullValueInWhere: "null_value_in_where", InvalidJoinQuery: "invalid_join_query", InvalidQuery: "invalid_query", ImportScriptsFailed: "import_scripts_failed", MethodNotExist: "method_not_exist", Unknown: "unknown", InvalidMiddleware: "invalid_middleware" };
  (function(e2) {
    e2.Registered = "registerd", e2.Failed = "failed", e2.NotStarted = "not_started";
  })(n || (n = {})), function(e2) {
    e2.String = "string", e2.Object = "object", e2.Array = "array", e2.Number = "number", e2.Boolean = "boolean", e2.Null = "null", e2.DateTime = "date_time";
  }(o || (o = {})), function(e2) {
    e2.InitDb = "init_db", e2.MapGet = "map_get", e2.MapSet = "map_set", e2.MapHas = "map_has", e2.MapDelete = "map_delete", e2.Select = "select", e2.Insert = "insert", e2.Update = "update", e2.Remove = "remove", e2.OpenDb = "open_db", e2.Clear = "clear", e2.DropDb = "drop_db", e2.Count = "count", e2.ChangeLogStatus = "change_log_status", e2.Terminate = "terminate", e2.Transaction = "transaction", e2.CloseDb = "close_db", e2.Union = "union", e2.Intersect = "intersect", e2.ImportScripts = "import_scripts", e2.Middleware = "middleware";
  }(r2 || (r2 = {})), function(e2) {
    e2.RequestQueueEmpty = "requestQueueEmpty", e2.RequestQueueFilled = "requestQueueFilled", e2.Upgrade = "upgrade", e2.Create = "create", e2.Open = "open";
  }(i || (i = {})), function(e2) {
    e2.Where = "where", e2.Like = "like", e2.Regex = "regex", e2.In = "in", e2.Equal = "=", e2.Between = "-", e2.GreaterThan = ">", e2.LessThan = "<", e2.GreaterThanEqualTo = ">=", e2.LessThanEqualTo = "<=", e2.NotEqualTo = "!=", e2.Aggregate = "aggregate", e2.Max = "max", e2.Min = "min", e2.Avg = "avg", e2.Count = "count", e2.Sum = "sum", e2.List = "list", e2.Or = "or", e2.Skip = "skip", e2.Limit = "limit", e2.And = "and", e2.IgnoreCase = "ignoreCase", e2.Then = "then";
  }(s || (s = {})), function(e2) {
    e2.ReadOnly = "readonly", e2.ReadWrite = "readwrite";
  }(u || (u = {})), function(e2) {
    e2.First = "f", e2.Last = "l", e2.Any = "a";
  }(a || (a = {})), function(e2) {
    e2.Connected = "connected", e2.Closed = "closed", e2.NotStarted = "not_started", e2.UnableToStart = "unable_to_start", e2.ClosedByJsStore = "closed_by_jsstore";
  }(p2 || (p2 = {}));
  var h2, d = function(e2) {
    return new Promise(e2);
  }, f = function(e2) {
    return Promise.resolve(e2);
  }, _ = function() {
    function e2(e3) {
      this._events = {}, this._ctx = e3;
    }
    return e2.prototype.on = function(e3, t2) {
      return null == this._events[e3] && (this._events[e3] = []), this._events[e3].push(t2), this;
    }, e2.prototype.off = function(e3, t2) {
      if (this._events[e3])
        if (t2) {
          var n2 = this._events[e3].indexOf(t2);
          this._events[e3].splice(n2, 1);
        } else
          this._events[e3] = [];
    }, e2.prototype.emit = function(e3) {
      for (var t2 = this, n2 = [], o2 = 1; o2 < arguments.length; o2++)
        n2[o2 - 1] = arguments[o2];
      var r3 = this._events[e3] || [], i2 = 0, s2 = r3.length, u2 = [];
      return new Promise(function(e4) {
        var o3 = function() {
          i2 < s2 ? function() {
            var e5 = r3[i2++];
            if (e5) {
              var o4 = e5.call.apply(e5, function(e6, t3, n3) {
                if (n3 || 2 === arguments.length)
                  for (var o5, r4 = 0, i3 = t3.length; r4 < i3; r4++)
                    !o5 && r4 in t3 || (o5 || (o5 = Array.prototype.slice.call(t3, 0, r4)), o5[r4] = t3[r4]);
                return e6.concat(o5 || Array.prototype.slice.call(t3));
              }([t2._ctx], n2, false));
              return o4 && o4.then ? o4 : Promise.resolve(o4);
            }
          }().then(function(e5) {
            u2.push(e5), o3();
          }) : e4(u2);
        };
        o3();
      });
    }, e2.prototype.destroy = function() {
      this._events = null, this._ctx = null;
    }, e2;
  }(), y = function() {
    function e2(e3) {
      this.isConOpened_ = false, this.isDbIdle_ = true, this.requestQueue_ = [], this.isCodeExecuting_ = false, this.inactivityTimer_ = -1e3, this.middlewares = [], this.eventBus_ = new _(this), this.whiteListApi_ = [r2.InitDb, r2.OpenDb, r2.MapGet, r2.MapSet, r2.MapHas, r2.MapDelete, r2.ChangeLogStatus, r2.Terminate, r2.DropDb], this.isWorker = true, this.logger = new c2(null), e3 ? (this.worker_ = e3, this.worker_.onmessage = this.onMessageFromWorker_.bind(this)) : (this.isWorker = false, this.initQueryManager_());
    }
    return Object.defineProperty(e2.prototype, "jsstoreWorker", { get: function() {
      return this.$worker || self.JsStoreWorker;
    }, enumerable: false, configurable: true }), e2.prototype.initQueryManager_ = function() {
      var e3 = this.jsstoreWorker;
      e3 && (this.queryManager = new e3.QueryManager(this.processFinishedQuery_.bind(this)));
    }, e2.prototype.onMessageFromWorker_ = function(e3) {
      this.processFinishedQuery_(e3.data);
    }, e2.prototype.processFinishedQuery_ = function(e3) {
      var t2 = this.requestQueue_.shift();
      if (t2) {
        if (this.logger.log("request ".concat(t2.name, " finished")), e3.error)
          t2.onError(e3.error);
        else {
          switch (t2.name) {
            case r2.OpenDb:
            case r2.InitDb:
              this.isConOpened_ = true;
              break;
            case r2.Terminate:
              this.isConOpened_ = false, true === this.isWorker && this.worker_.terminate();
            case r2.DropDb:
              this.isConOpened_ = false, this.requestQueue_ = [], this.isDbIdle_ = true;
              break;
            case r2.CloseDb:
              this.isDbIdle_ = true, this.eventBus_.emit(i.RequestQueueEmpty, []), this.requestQueue_.length > 0 && this.openDb_(false);
          }
          t2.onSuccess(e3.result);
        }
        this.isCodeExecuting_ = false, this.executeQry_();
      }
    }, e2.prototype.openDb_ = function(e3) {
      void 0 === e3 && (e3 = true);
      var t2 = { name: r2.OpenDb, query: { name: this.database.name, version: this.database.version }, onSuccess: function() {
      }, onError: function(e4) {
        console.error(e4);
      } };
      e3 ? this.prcoessExecutionOfQry_(t2, 0) : this.requestQueue_.splice(0, 0, t2);
    }, e2.prototype.executeMiddleware_ = function(e3) {
      var t2 = this;
      return d(function(n2) {
        var o2 = 0, r3 = t2.middlewares.length - 1, i2 = function() {
          if (o2 <= r3) {
            var s2 = t2.middlewares[o2++](e3);
            s2 && s2.then || (s2 = f(s2)), s2.then(function(e4) {
              i2();
            });
          } else
            n2();
        };
        i2();
      });
    }, e2.prototype.callResultMiddleware = function(e3, t2) {
      return d(function(n2) {
        var o2 = 0, r3 = e3.length - 1, i2 = function() {
          if (o2 <= r3) {
            var s2 = e3[o2++](t2);
            s2.then || (s2 = f(s2)), s2.then(function(e4) {
              t2 = e4, i2();
            });
          } else
            n2(t2);
        };
        i2();
      });
    }, e2.prototype.pushApi = function(e3) {
      var t2 = this;
      return new Promise(function(n2, o2) {
        var s2 = [];
        e3.onResult = function(e4) {
          s2.push(function(t3) {
            return e4(t3);
          });
        }, t2.executeMiddleware_(e3).then(function() {
          e3.onSuccess = function(o3) {
            t2.callResultMiddleware(s2, o3).then(function(e4) {
              n2(e4);
            }).catch(function(t3) {
              e3.onError(t3);
            });
          }, e3.onError = function(e4) {
            s2 = [], o2(e4);
          }, 0 === t2.requestQueue_.length && (t2.eventBus_.emit(i.RequestQueueFilled, []), t2.isDbIdle_ && t2.isConOpened_ && ([r2.InitDb, r2.CloseDb, r2.DropDb, r2.OpenDb, r2.Terminate].indexOf(e3.name) >= 0 || t2.openDb_()), clearTimeout(t2.inactivityTimer_)), t2.prcoessExecutionOfQry_(e3);
        }).catch(o2);
      });
    }, e2.prototype.prcoessExecutionOfQry_ = function(e3, t2) {
      this.isDbIdle_ = false, null != t2 ? this.requestQueue_.splice(t2, 0, e3) : this.requestQueue_.push(e3), this.logger.log("request pushed: " + e3.name), this.executeQry_();
    }, e2.prototype.executeQry_ = function() {
      var e3 = this, t2 = this.requestQueue_.length;
      if (!this.isCodeExecuting_ && t2 > 0) {
        if (true === this.isConOpened_)
          return void this.sendRequestToWorker_(this.requestQueue_[0]);
        var n2 = this.requestQueue_.findIndex(function(t3) {
          return e3.whiteListApi_.indexOf(t3.name) >= 0;
        });
        n2 >= 0 && (this.requestQueue_.splice(0, 0, this.requestQueue_.splice(n2, 1)[0]), this.sendRequestToWorker_(this.requestQueue_[0]));
      } else
        0 === t2 && false === this.isDbIdle_ && this.isConOpened_ && (this.inactivityTimer_ = setTimeout(function() {
          e3.prcoessExecutionOfQry_({ name: r2.CloseDb, onSuccess: function() {
          }, onError: function(e4) {
            console.error(e4);
          } });
        }, 100));
    }, e2.prototype.sendRequestToWorker_ = function(e3) {
      this.isCodeExecuting_ = true, this.logger.log("request executing: " + e3.name);
      var t2 = { name: e3.name, query: e3.query };
      true === this.isWorker ? this.worker_.postMessage(t2) : this.queryManager.run(t2);
    }, e2;
  }(), m = function() {
    function e2(e3) {
      this.con = e3;
    }
    return e2.prototype.get = function(e3) {
      return this.con.pushApi({ name: r2.MapGet, query: e3 });
    }, e2.prototype.has = function(e3) {
      return this.con.pushApi({ name: r2.MapHas, query: e3 });
    }, e2.prototype.set = function(e3, t2) {
      return this.con.pushApi({ name: r2.MapSet, query: { key: e3, value: t2 } });
    }, e2.prototype.delete = function(e3) {
      return this.con.pushApi({ name: r2.MapDelete, query: e3 });
    }, e2;
  }(), g2 = (h2 = function(e2, t2) {
    return h2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
      e3.__proto__ = t3;
    } || function(e3, t3) {
      for (var n2 in t3)
        Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
    }, h2(e2, t2);
  }, function(e2, t2) {
    if ("function" != typeof t2 && null !== t2)
      throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
    function n2() {
      this.constructor = e2;
    }
    h2(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
  }), b = function(e2) {
    function t2(t3) {
      var n2 = e2.call(this, t3) || this;
      return n2.Map = new m(n2), n2;
    }
    return g2(t2, e2), t2.prototype.initDb = function(e3) {
      var t3 = this;
      return this.database = e3, this.pushApi({ name: r2.InitDb, query: e3 }).then(function(e4) {
        var n2, o2 = e4.database;
        return e4.isCreated && (n2 = e4.oldVersion ? t3.eventBus_.emit(i.Upgrade, o2, e4.oldVersion, e4.newVersion) : t3.eventBus_.emit(i.Create, o2)), (n2 || f()).then(function(e5) {
          return t3.eventBus_.emit(i.Open, o2);
        }).then(function(t4) {
          return e4.isCreated;
        });
      });
    }, t2.prototype.dropDb = function() {
      return this.pushApi({ name: r2.DropDb });
    }, t2.prototype.select = function(e3) {
      return this.pushApi({ name: r2.Select, query: e3 });
    }, t2.prototype.count = function(e3) {
      return this.pushApi({ name: r2.Count, query: e3 });
    }, t2.prototype.insert = function(e3) {
      return this.pushApi({ name: r2.Insert, query: e3 });
    }, t2.prototype.update = function(e3) {
      return this.pushApi({ name: r2.Update, query: e3 });
    }, t2.prototype.remove = function(e3) {
      return this.pushApi({ name: r2.Remove, query: e3 });
    }, t2.prototype.clear = function(e3) {
      return this.pushApi({ name: r2.Clear, query: e3 });
    }, Object.defineProperty(t2.prototype, "logStatus", { set: function(e3) {
      this.logger.status = e3, this.pushApi({ name: r2.ChangeLogStatus, query: e3 });
    }, enumerable: false, configurable: true }), t2.prototype.openDb = function(e3, t3) {
      var n2 = this;
      return this.pushApi({ name: r2.OpenDb, query: { version: t3, name: e3 } }).then(function(e4) {
        return n2.database = e4, e4;
      });
    }, t2.prototype.getDbList = function() {
      return console.warn("Api getDbList is recommended to use for debugging only. Do not use in code."), indexedDB.databases();
    }, t2.prototype.get = function(e3) {
      return console.warn("This API is obsolete, please use Map"), this.Map.get(e3);
    }, t2.prototype.set = function(e3, t3) {
      return console.warn("This API is obsolete, please use Map"), this.Map.set(e3, t3);
    }, t2.prototype.terminate = function() {
      return this.pushApi({ name: r2.Terminate });
    }, t2.prototype.transaction = function(e3) {
      return this.pushApi({ name: r2.Transaction, query: e3 });
    }, t2.prototype.on = function(e3, t3) {
      this.eventBus_.on(e3, t3);
    }, t2.prototype.off = function(e3, t3) {
      this.eventBus_.off(e3, t3);
    }, t2.prototype.union = function(e3) {
      return this.pushApi({ name: r2.Union, query: e3 });
    }, t2.prototype.intersect = function(e3) {
      return this.pushApi({ name: r2.Intersect, query: e3 });
    }, t2.prototype.addPlugin = function(e3, t3) {
      return e3.setup(this, t3);
    }, t2.prototype.addMiddleware = function(e3, t3) {
      return t3 ? this.pushApi({ name: r2.Middleware, query: e3 }) : (this.middlewares.push(e3), Promise.resolve());
    }, t2.prototype.importScripts = function() {
      for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
        e3[t3] = arguments[t3];
      return this.pushApi({ name: r2.ImportScripts, query: e3 });
    }, t2;
  }(y), v = function(e2) {
    return Promise.all(e2);
  }, q = function(e2, t2) {
    for (var n2 in e2)
      t2(n2, e2[n2]);
  };
  jsstore_commonjs2_min.exports = t;
})();
var jsstore_commonjs2_minExports = jsstore_commonjs2_min.exports;
npm_export.exports = jsstore_commonjs2_minExports;
var npm_exportExports = npm_export.exports;
var jsstore_worker_commonjs2_min = { exports: {} };
/*! For license information please see jsstore.worker.commonjs2.min.js.LICENSE.txt */
var hasRequiredJsstore_worker_commonjs2_min;
function requireJsstore_worker_commonjs2_min() {
  if (hasRequiredJsstore_worker_commonjs2_min)
    return jsstore_worker_commonjs2_min.exports;
  hasRequiredJsstore_worker_commonjs2_min = 1;
  (() => {
    var e = { d: (t2, n2) => {
      for (var r3 in n2)
        e.o(n2, r3) && !e.o(t2, r3) && Object.defineProperty(t2, r3, { enumerable: true, get: n2[r3] });
    }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
    } }, t = {};
    e.r(t), e.d(t, { QueryManager: () => ot2 });
    var n, r2, o, u, i, a, c2, s, l2 = function(e2) {
      return Promise.resolve(e2);
    }, f = function(e2) {
      return new Promise(e2);
    }, h2 = "not_array", p2 = "no_value_supplied", y = "column_not_exist", d = "no_index_found", v = "invalid_operator", m = "null_value", b = "wrong_data_type", g2 = "table_not_exist", _ = "not_object", w = "Db_blocked", x2 = "indexeddb_not_supported", k2 = "null_value_in_where", T = "invalid_join_query", S = "import_scripts_failed", E = "method_not_exist", O = "invalid_middleware";
    (function(e2) {
      e2.Registered = "registerd", e2.Failed = "failed", e2.NotStarted = "not_started";
    })(n || (n = {})), function(e2) {
      e2.String = "string", e2.Object = "object", e2.Array = "array", e2.Number = "number", e2.Boolean = "boolean", e2.Null = "null", e2.DateTime = "date_time";
    }(r2 || (r2 = {})), function(e2) {
      e2.InitDb = "init_db", e2.MapGet = "map_get", e2.MapSet = "map_set", e2.MapHas = "map_has", e2.MapDelete = "map_delete", e2.Select = "select", e2.Insert = "insert", e2.Update = "update", e2.Remove = "remove", e2.OpenDb = "open_db", e2.Clear = "clear", e2.DropDb = "drop_db", e2.Count = "count", e2.ChangeLogStatus = "change_log_status", e2.Terminate = "terminate", e2.Transaction = "transaction", e2.CloseDb = "close_db", e2.Union = "union", e2.Intersect = "intersect", e2.ImportScripts = "import_scripts", e2.Middleware = "middleware";
    }(o || (o = {})), function(e2) {
      e2.RequestQueueEmpty = "requestQueueEmpty", e2.RequestQueueFilled = "requestQueueFilled", e2.Upgrade = "upgrade", e2.Create = "create", e2.Open = "open";
    }(u || (u = {})), function(e2) {
      e2.Where = "where", e2.Like = "like", e2.Regex = "regex", e2.In = "in", e2.Equal = "=", e2.Between = "-", e2.GreaterThan = ">", e2.LessThan = "<", e2.GreaterThanEqualTo = ">=", e2.LessThanEqualTo = "<=", e2.NotEqualTo = "!=", e2.Aggregate = "aggregate", e2.Max = "max", e2.Min = "min", e2.Avg = "avg", e2.Count = "count", e2.Sum = "sum", e2.List = "list", e2.Or = "or", e2.Skip = "skip", e2.Limit = "limit", e2.And = "and", e2.IgnoreCase = "ignoreCase", e2.Then = "then";
    }(i || (i = {})), function(e2) {
      e2.ReadOnly = "readonly", e2.ReadWrite = "readwrite";
    }(a || (a = {})), function(e2) {
      e2.First = "f", e2.Last = "l", e2.Any = "a";
    }(c2 || (c2 = {})), function(e2) {
      e2.Connected = "connected", e2.Closed = "closed", e2.NotStarted = "not_started", e2.UnableToStart = "unable_to_start", e2.ClosedByJsStore = "closed_by_jsstore";
    }(s || (s = {}));
    var C, j2 = function() {
      function e2(e3) {
        this.columns = [], this.autoIncColumnValue = {}, this.columns = this.setColumn(e3.columns), this.name = e3.name, this.alter = e3.alter || {};
      }
      return e2.prototype.setColumn = function(e3) {
        var t2 = [], n2 = function(n3) {
          var o3 = e3[n3];
          o3.name = n3, o3.autoIncrement && (r3.autoIncColumnValue[n3] = 0), o3.primaryKey && (r3.primaryKey = n3), o3.enableSearch = null == o3.enableSearch || o3.enableSearch;
          var u2 = r3.columns.indexOf(function(e4) {
            return e4.name === n3;
          });
          if (u2 < 0)
            t2.push(o3);
          else {
            var i2 = r3.columns[u2];
            Object.assign(i2, o3);
          }
        }, r3 = this;
        for (var o2 in e3)
          n2(o2);
        return t2;
      }, e2;
    }(), A2 = function() {
      function e2() {
      }
      return e2.autoIncrementKey = function(e3, t2) {
        return "JsStore_".concat(e3, "_").concat(t2, "_Value");
      }, e2.getStore = function(t2) {
        return t2.tx || t2.createTransaction([e2.tableName]), t2.objectStore(e2.tableName);
      }, e2.set = function(t2, n2, r3) {
        var o2 = e2.getStore(r3);
        return f(function(e3, r4) {
          var u2 = o2.put({ key: t2, value: n2 });
          u2.onsuccess = function() {
            e3();
          }, u2.onerror = r4;
        });
      }, e2.get = function(t2, n2) {
        var r3 = e2.getStore(n2);
        return f(function(e3, o2) {
          var u2 = r3.get(n2.keyRange(t2));
          u2.onsuccess = function() {
            var t3 = u2.result;
            e3(t3 && t3.value);
          }, u2.onerror = o2;
        });
      }, e2.remove = function(t2, n2) {
        var r3 = e2.getStore(n2);
        return f(function(e3, o2) {
          var u2 = r3.delete(n2.keyRange(t2));
          u2.onsuccess = function() {
            e3();
          }, u2.onerror = o2;
        });
      }, e2.has = function(t2, n2) {
        var r3 = e2.getStore(n2);
        return f(function(e3, o2) {
          var u2 = r3.count(n2.keyRange(t2));
          u2.onsuccess = function() {
            var t3 = u2.result;
            e3(t3 > 0);
          }, u2.onerror = o2;
        });
      }, e2.tableName = "JsStore_Meta", e2.dbSchema = "JsStore_DbSchema", e2;
    }(), q = function(e2) {
      this.name = e2.name, this.version = e2.version || 1, e2.tables.push({ name: A2.tableName, columns: { key: { primaryKey: true }, value: { enableSearch: false } } }), this.tables = e2.tables.map(function(e3) {
        return new j2(e3);
      });
    }, I = function(e2, t2) {
      for (var n2 in e2)
        t2(n2, e2[n2]);
    }, R = function() {
      function e2(e3, t2) {
        this.type = e3, this.info_ = t2, this.message = this.getMsg_();
      }
      return e2.prototype.log = function(e3) {
        this.status && console.log(e3);
      }, e2.prototype.throw = function() {
        throw this.get();
      }, e2.prototype.logError = function() {
        console.error(this.get());
      }, e2.prototype.get = function() {
        return { message: this.message, type: this.type };
      }, e2.prototype.getMsg_ = function() {
        var e3, t2, n2 = this.info_, r3 = ((e3 = {})[h2] = function() {
          t2 = "Supplied value is not an array";
        }, e3.undefined_column = function() {
          t2 = "Column is undefined in Where";
        }, e3.undefined_value = function() {
          t2 = "Value is undefined in Where";
        }, e3.undefined_column_name = function() {
          t2 = "Column name is undefined '" + n2.TableName + "'";
        }, e3.undefined_database_name = function() {
          t2 = "Database name is not supplied";
        }, e3.undefined_column_value = function() {
          t2 = "Column value is undefined";
        }, e3[p2] = function() {
          t2 = "No value is supplied";
        }, e3[v] = function() {
          t2 = "Invalid Op Value '" + n2.Op + "'";
        }, e3[y] = function() {
          var e4 = n2.column;
          t2 = n2.isOrder ? "Column '".concat(e4, "' in order query does not exist") : "Column '".concat(e4, "' does not exist");
        }, e3[d] = function() {
          t2 = "No index found for column '" + n2.column + "'. Query can not be executed without index.";
        }, e3[m] = function() {
          t2 = "Null value is not allowed for column '" + n2.ColumnName + "'";
        }, e3[b] = function() {
          t2 = "Supplied value for column '" + n2.column + "' have wrong data type";
        }, e3[g2] = function() {
          t2 = "Table '" + n2.tableName + "' does not exist";
        }, e3.db_not_exist = function() {
          t2 = "Database with name ".concat(n2.dbName, " does not exist");
        }, e3[_] = function() {
          t2 = "supplied value is not object";
        }, e3[v] = function() {
          t2 = "Invalid Config '" + n2.Config + " '";
        }, e3[w] = function() {
          t2 = "database is blocked, cant be deleted right now";
        }, e3[k2] = function() {
          t2 = "Null/undefined is not allowed in where. Column '".concat(n2.column, "' has null");
        }, e3[E] = function() {
          t2 = "method '".concat(n2, "' does not exist.");
        }, e3[x2] = function() {
          t2 = "Browser does not support indexeddb";
        }, e3.getInfo = function() {
          t2 = n2;
        }, e3[T] = function() {
          r3.getInfo();
        }, e3[S] = function() {
          r3.getInfo();
        }, e3[O] = function() {
          t2 = "No function ".concat(n2, " is found.");
        }, e3), o2 = this.type, u2 = r3[o2];
        return u2 ? u2() : (o2 || (this.type = "unknown"), t2 = this.message), t2;
      }, e2;
    }(), Q2 = function() {
      function e2() {
        this.logger = new R(null);
      }
      return e2.prototype.emptyTx = function() {
        this.tx && (this.tx.oncomplete = null, this.tx.onabort = null, this.tx.onerror = null, this.tx = null);
      }, e2.prototype.createTransactionIfNotExist = function(e3, t2) {
        this.tx || this.createTransaction(e3, t2);
      }, e2.prototype.createTransaction = function(e3, t2) {
        var n2 = this;
        return void 0 === t2 && (t2 = a.ReadWrite), this.tx = this.con.transaction(e3, t2), f(function(e4, t3) {
          n2.tx.oncomplete = e4, n2.tx.onabort = e4, n2.tx.onerror = t3;
        });
      }, e2.prototype.keyRange = function(e3, t2) {
        var n2;
        switch (t2) {
          case i.Between:
            n2 = IDBKeyRange.bound(e3.low, e3.high, false, false);
            break;
          case i.GreaterThan:
            n2 = IDBKeyRange.lowerBound(e3, true);
            break;
          case i.GreaterThanEqualTo:
            n2 = IDBKeyRange.lowerBound(e3);
            break;
          case i.LessThan:
            n2 = IDBKeyRange.upperBound(e3, true);
            break;
          case i.LessThanEqualTo:
            n2 = IDBKeyRange.upperBound(e3);
            break;
          default:
            n2 = IDBKeyRange.only(e3);
        }
        return n2;
      }, e2.prototype.objectStore = function(e3) {
        return this.tx.objectStore(e3);
      }, e2.prototype.abortTransaction = function() {
        this.tx && this.tx.abort();
      }, e2.prototype.close = function() {
        var e3 = this;
        return this.con && this.con.close(), f(function(t2) {
          e3.con = null, setTimeout(t2, 100);
        });
      }, e2.prototype.initDb = function(e3) {
        var t2, n2 = this, r3 = false, o2 = e3.version;
        return f(function(u2, i2) {
          var a2 = indexedDB.open(e3.name, o2);
          a2.onsuccess = function() {
            n2.con = a2.result, n2.con.onversionchange = function(e4) {
              e4.target.close();
            }, u2({ isCreated: r3, oldVersion: t2, newVersion: o2 });
          }, a2.onerror = function(e4) {
            console.error("error", e4), i2(e4);
          }, a2.onupgradeneeded = function(n3) {
            t2 = n3.oldVersion;
            var u3 = n3.target, i3 = u3.result;
            r3 = true;
            var a3 = u3.transaction, c3 = i3.objectStoreNames, s2 = function(e4, t3) {
              var n4 = t3.name;
              if (t3.enableSearch && !e4.indexNames.contains(n4)) {
                var r4 = t3.primaryKey ? { unique: true } : { unique: t3.unique };
                r4.multiEntry = t3.multiEntry;
                var o3 = null == t3.keyPath ? n4 : t3.keyPath;
                e4.createIndex(n4, o3, r4);
              }
            }, l3 = function(e4, t3, n4) {
              var r4 = t3.columns.findIndex(function(e5) {
                return e5.name === n4;
              });
              r4 >= 0 && (t3.columns.splice(r4, 1), e4.deleteIndex(n4));
            };
            e3.tables.forEach(function(e4) {
              if (!c3.contains(e4.name))
                return function(e5) {
                  var t3 = e5.primaryKey ? { keyPath: e5.primaryKey } : { autoIncrement: true }, n5 = i3.createObjectStore(e5.name, t3);
                  e5.columns.forEach(function(e6) {
                    s2(n5, e6);
                  });
                }(e4);
              for (var n4 = a3.objectStore(e4.name), r4 = t2 + 1; r4 <= o2; r4++) {
                var u4 = e4.alter[r4];
                u4 && (u4.add && e4.setColumn(u4.add).forEach(function(t3) {
                  s2(n4, t3), e4.columns.push(t3);
                }), I(u4.drop || {}, function(t3) {
                  l3(n4, e4, t3);
                }), I(u4.modify || {}, function(t3, r5) {
                  var o3 = r5.multiEntry || r5.keyPath || r5.unique, u5 = e4.columns.find(function(e5) {
                    return e5.name === t3;
                  }), i4 = Object.assign(u5, r5);
                  i4.name = t3, o3 && (l3(n4, e4, t3), s2(n4, i4), e4.columns.push(i4));
                }));
              }
            });
            for (var f2 = function(t3, n4) {
              var r4 = c3.item(t3);
              e3.tables.findIndex(function(e4) {
                return e4.name === r4;
              }) < 0 && i3.deleteObjectStore(r4);
            }, h3 = 0, p3 = c3.length; h3 < p3; h3++)
              f2(h3);
          };
        });
      }, e2;
    }(), L2 = function(e2) {
      return Promise.all(e2);
    }, N2 = function(e2) {
      return Promise.reject(e2);
    }, D2 = function(e2) {
      if (e2 instanceof R)
        return e2.logError(), e2.get();
      var t2 = void 0;
      return e2.name ? (t2 = new R(e2.name)).message = e2.message : (t2 = new R(e2.target.error.name)).message = e2.target.error.message, t2.get();
    }, V2 = function() {
      function e2() {
        this.rowAffected = 0, this.isTxQuery = false, this.results = [];
      }
      return Object.defineProperty(e2.prototype, "db", { get: function() {
        return this.util.db;
      }, enumerable: false, configurable: true }), e2.prototype.table = function(e3) {
        var t2 = e3 || this.tableName;
        return this.db.tables.find(function(e4) {
          return e4.name === t2;
        });
      }, e2.prototype.primaryKey = function(e3) {
        var t2 = this.query;
        return !t2.from && t2.store && t2.meta ? t2.meta.primaryKey : this.table(e3).primaryKey;
      }, e2.prototype.getColumnInfo = function(e3, t2) {
        return this.table(t2).columns.find(function(t3) {
          return t3.name === e3;
        });
      }, e2.prototype.onException = function(e3, t2) {
        return console.error(e3), this.util.abortTransaction(), N2(function(e4, t3) {
          return void 0 === t3 && (t3 = "invalid_query"), e4.name = t3, D2(e4);
        }(e3, t2));
      }, e2;
    }(), W = function(e2) {
      if (null == e2)
        return r2.Null;
      var t2 = typeof e2;
      if ("object" === t2) {
        if (Array.isArray(e2))
          return r2.Array;
        if (e2 instanceof Date)
          return r2.DateTime;
      }
      return t2;
    }, B2 = function(e2) {
      return null == e2 || "number" == typeof e2 && isNaN(e2);
    }, P = function() {
      function e2(e3, t2) {
        this.table = e3, this.autoIncrementValue = t2;
      }
      return e2.prototype.checkAndModifyValues = function(e3) {
        var t2, n2 = this;
        this.query = e3;
        var r3 = e3.values, o2 = [];
        return r3.every(function(r4, u2) {
          return t2 = n2.checkAndModifyValue(r4), e3.ignore && t2 && (o2.push(u2), t2 = null), !t2;
        }), o2.forEach(function(e4) {
          r3.splice(e4, 1);
        }), { err: t2, values: r3 };
      }, e2.prototype.checkAndModifyValue = function(e3) {
        var t2, n2 = this;
        return this.table.columns.every(function(r3) {
          return !(t2 = n2.checkAndModifyColumnValue_(r3, e3));
        }), t2;
      }, e2.prototype.checkNotNullAndDataType_ = function(e3, t2) {
        return e3.notNull && B2(t2[e3.name]) ? this.getError(m, { ColumnName: e3.name }) : e3.dataType && !B2(t2[e3.name]) && W(t2[e3.name]) !== e3.dataType ? this.getError(b, { column: e3.name }) : void 0;
      }, e2.prototype.checkAndModifyColumnValue_ = function(e3, t2) {
        var n2 = t2[e3.name];
        if (e3.autoIncrement ? B2(n2) ? t2[e3.name] = ++this.autoIncrementValue[e3.name] : W(n2) === r2.Number && n2 > this.autoIncrementValue[e3.name] && (this.autoIncrementValue[e3.name] = n2) : void 0 !== e3.default && B2(n2) && (t2[e3.name] = e3.default), this.query.validation)
          return this.checkNotNullAndDataType_(e3, t2);
      }, e2.prototype.getError = function(e3, t2) {
        return new R(e3, t2);
      }, e2;
    }(), M2 = function() {
      function e2(e3) {
        this.table = e3;
      }
      return e2.prototype.check = function(e3, t2) {
        var n2, o2 = this;
        return typeof e3 === r2.Object ? this.table ? this.table.columns.every(function(t3) {
          return t3.name in e3 && (n2 = o2.checkByColumn_(t3, e3[t3.name])), !n2;
        }) : n2 = new R(g2, { tableName: t2 }) : n2 = new R(_), n2;
      }, e2.prototype.checkByColumn_ = function(e3, t2) {
        if (true === e3.notNull && B2(t2))
          return new R(m, { ColumnName: e3.name });
        var n2 = W(t2), r3 = null != t2;
        if (e3.dataType && r3 && n2 !== e3.dataType && "object" !== n2)
          return new R(b, { column: e3.name });
        if (r3 && "object" === n2) {
          var o2 = ["+", "-", "*", "/", "{push}"];
          for (var u2 in t2)
            if (o2.indexOf(u2) < 0 && e3.dataType && n2 !== e3.dataType)
              return new R(b, { column: e3.name });
        }
      }, e2;
    }(), K2 = function() {
      function e2(e3) {
        this.db = e3;
      }
      return e2.prototype.validate = function(e3, t2) {
        switch (e3) {
          case o.Select:
          case o.Remove:
          case o.Count:
            return this.checkSelect(t2);
          case o.Insert:
            return this.checkInsertQuery(t2);
          case o.Update:
            return this.checkUpdate(t2);
        }
      }, e2.prototype.getTable_ = function(e3) {
        return this.db.tables.find(function(t2) {
          return t2.name === e3;
        });
      }, e2.prototype.isInsertQryValid = function(e3) {
        var t2, n2 = this.getTable_(e3.into);
        if (n2)
          switch (W(e3.values)) {
            case r2.Array:
              break;
            case r2.Null:
              t2 = new R(p2);
              break;
            default:
              t2 = new R(h2);
          }
        else
          t2 = new R(g2, { tableName: e3.into });
        return { table: n2, log: t2 };
      }, e2.prototype.checkUpdate = function(e3) {
        var t2 = new M2(this.getTable_(e3.in)).check(e3.set, e3.in);
        if (t2)
          return t2;
        if (null != e3.where) {
          if (t2 = this.checkForNullInWhere_(e3))
            return t2;
          this.addGreatAndLessToNotOp_(e3);
        }
      }, e2.prototype.checkSelect = function(e3) {
        if (!e3.store && !this.getTable_(e3.from))
          return new R(g2, { tableName: e3.from });
        if (e3.where) {
          var t2 = this.checkForNullInWhere_(e3);
          if (t2)
            return t2;
          this.addGreatAndLessToNotOp_(e3);
        }
      }, e2.prototype.checkForNullInWhere_ = function(e3) {
        for (var t2 in e3.where)
          if (null == e3.where[t2])
            return new R(k2, { column: t2 });
      }, e2.prototype.addGreatAndLessToNotOp_ = function(e3) {
        var t2 = e3.where, n2 = function(e4, t3) {
          return t3.findIndex(function(t4) {
            return null != e4[t4][i.NotEqualTo];
          }) >= 0;
        }, o2 = function(e4, t3) {
          var n3;
          return t3.forEach(function(t4) {
            null != (n3 = e4[t4])[i.NotEqualTo] && (e4[t4][i.GreaterThan] = n3[i.NotEqualTo], void 0 === e4[i.Or] ? (e4[i.Or] = {}, e4[i.Or][t4] = {}) : void 0 === e4[i.Or][t4] && (e4[i.Or][t4] = {}), e4[i.Or][t4][i.LessThan] = n3[i.NotEqualTo], delete e4[t4][i.NotEqualTo]);
          }), e4;
        };
        if (W(t2) === r2.Object) {
          var u2 = Object.keys(t2);
          if (n2(t2, u2))
            if (1 === u2.length)
              e3.where = o2(t2, u2);
            else {
              var a2 = [];
              u2.forEach(function(e4) {
                var n3;
                a2.push(o2(((n3 = {})[e4] = t2[e4], n3), [e4]));
              }), e3.where = a2;
            }
        } else {
          var c3 = [];
          t2.forEach(function(e4) {
            var t3 = Object.keys(e4);
            n2(e4, t3) && (e4 = o2(e4, t3)), c3.push(e4);
          }), e3.where = c3;
        }
      }, e2.prototype.checkInsertQuery = function(e3) {
        var t2 = this.isInsertQryValid(e3), n2 = t2.table, r3 = t2.log;
        if (r3)
          return r3;
        if (!e3.skipDataCheck) {
          var o2 = new P(n2, n2.autoIncColumnValue).checkAndModifyValues(e3), u2 = o2.values, i2 = o2.err;
          return e3.values = u2, i2;
        }
      }, e2;
    }(), G2 = (C = function(e2, t2) {
      return C = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
        e3.__proto__ = t3;
      } || function(e3, t3) {
        for (var n2 in t3)
          Object.prototype.hasOwnProperty.call(t3, n2) && (e3[n2] = t3[n2]);
      }, C(e2, t2);
    }, function(e2, t2) {
      if ("function" != typeof t2 && null !== t2)
        throw new TypeError("Class extends value " + String(t2) + " is not a constructor or null");
      function n2() {
        this.constructor = e2;
      }
      C(e2, t2), e2.prototype = null === t2 ? Object.create(t2) : (n2.prototype = t2.prototype, new n2());
    }), F = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.valuesAffected_ = [], null == t3.validation && (t3.validation = true), r3.query = t3, r3.util = n2, r3.tableName = t3.into, r3;
      }
      return G2(t2, e2), t2.prototype.execute = function(e3) {
        var t3 = this, n2 = this.db, r3 = new K2(n2).validate(o.Insert, this.query);
        return r3 ? N2(r3) : e3().then(function(e4) {
          return t3.insertData_(n2).then(function(e5) {
            return t3.query.return ? t3.valuesAffected_ : t3.rowAffected;
          });
        }).catch(function(e4) {
          return t3.util.abortTransaction(), N2(e4);
        });
      }, t2.prototype.insertData_ = function(e3) {
        var t3, n2, r3, o2 = this, u2 = this.query;
        return t3 = u2.return ? function(e4) {
          o2.valuesAffected_.push(e4);
        } : function(e4) {
          ++o2.rowAffected;
        }, r3 = u2.upsert ? "put" : "add", n2 = u2.ignore && !o2.isTxQuery ? function(e4) {
          return o2.util.con.transaction(u2.into, a.ReadWrite).objectStore(u2.into)[r3](e4);
        } : (o2.isTxQuery || o2.util.createTransaction([u2.into, A2.tableName]), o2.objectStore = o2.util.objectStore(o2.tableName), function(e4) {
          return o2.objectStore[r3](e4);
        }), L2(u2.values.map(function(e4) {
          return f(function(r4, o3) {
            var i2 = n2(e4);
            i2.onerror = function(e5) {
              u2.ignore ? r4() : o3(e5);
            }, i2.onsuccess = function() {
              t3(e4), r4();
            };
          });
        })).then(function() {
          return A2.set(A2.dbSchema, e3, o2.util);
        });
      }, t2;
    }(V2), J2 = void 0 === self.alert && "undefined" == typeof ServiceWorkerGlobalScope, U2 = function() {
      try {
        if (indexedDB || (indexedDB = self.mozIndexedDB || self.webkitIndexedDB || self.msIndexedDB), !indexedDB)
          return false;
        IDBTransaction = IDBTransaction || self.webkitIDBTransaction || self.msIDBTransaction, self.IDBKeyRange = self.IDBKeyRange || self.webkitIDBKeyRange || self.msIDBKeyRange;
      } catch (e2) {
        return false;
      }
      return true;
    }(), H = function(e2) {
      return Array.isArray(e2);
    }, z = function(e2) {
      return Object.keys(e2);
    }, $ = function(e2) {
      return z(e2).length;
    }, X2 = function(e2) {
      for (var t2 in e2)
        return t2;
    }, Y2 = function() {
      function e2() {
      }
      return e2.prototype.setCaseAndValue = function(e3, t2) {
        this.caseQuery_ = e3, this.setValue(t2);
      }, e2.prototype.setCaseAndColumn = function(e3, t2) {
        return this.caseQuery_ = e3, this.setColumn(t2), this;
      }, e2.prototype.setColumn = function(e3) {
        return this.columnName_ = e3, this.caseColumnQuery_ = this.caseQuery_[this.columnName_], this.length_ = this.caseColumnQuery_.length, this;
      }, e2.prototype.setValue = function(e3) {
        return this.value = e3, this;
      }, e2.prototype.evaluate = function() {
        for (var e3 = 0; e3 < this.length_; e3++)
          if (true === this.checkCase_(this.caseColumnQuery_[e3]))
            return this.caseColumnQuery_[e3].then;
        var t2 = this.caseColumnQuery_[this.length_ - 1].then;
        return null == t2 ? this.value[this.columnName_] : t2;
      }, e2.prototype.checkCase_ = function(e3) {
        var t2;
        for (t2 in e3) {
          switch (t2) {
            case i.GreaterThan:
              if (this.value[this.columnName_] > e3[t2])
                return true;
              break;
            case i.Equal:
              if (this.value[this.columnName_] === e3[t2])
                return true;
              break;
            case i.LessThan:
              if (this.value[this.columnName_] < e3[t2])
                return true;
              break;
            case i.GreaterThanEqualTo:
              if (this.value[this.columnName_] >= e3[t2])
                return true;
              break;
            case i.LessThanEqualTo:
              if (this.value[this.columnName_] <= e3[t2])
                return true;
              break;
            case i.NotEqualTo:
              if (this.value[this.columnName_] !== e3[t2])
                return true;
              break;
            case i.Between:
              if (this.value[this.columnName_] > e3[t2].low && this.value[this.columnName_] < e3[t2].high)
                return true;
          }
          return false;
        }
      }, e2;
    }(), Z2 = function(e2, t2, n2, r3) {
      if (false === this.limitAtEnd && false === this.skipAtEnd) {
        if (this.skipRecord)
          return this.limitRecord ? r3 : n2;
        if (this.limitRecord)
          return t2;
      }
      return e2;
    }, ee2 = function(e2) {
      var t2 = this, n2 = false;
      return function(r3) {
        var o2 = r3.target.result;
        o2 ? n2 && t2.results.length !== t2.limitRecord ? (t2.shouldAddValue(o2) && t2.pushResult(o2.value), o2.continue()) : (n2 = true, o2.advance(t2.skipRecord)) : e2();
      };
    }, te2 = function(e2) {
      var t2 = this, n2 = false;
      return function(r3) {
        var o2 = r3.target.result;
        o2 ? n2 ? (t2.shouldAddValue(o2) && t2.pushResult(o2.value), o2.continue()) : (n2 = true, o2.advance(t2.skipRecord)) : e2();
      };
    }, ne2 = function(e2) {
      var t2 = this;
      return function(n2) {
        var r3 = n2.target.result;
        r3 && t2.results.length !== t2.limitRecord ? (t2.shouldAddValue(r3) && t2.pushResult(r3.value), r3.continue()) : e2();
      };
    }, re2 = function(e2) {
      var t2 = this;
      return function(n2) {
        var r3 = n2.target.result;
        r3 ? (t2.shouldAddValue(r3) && t2.pushResult(r3.value), r3.continue()) : e2();
      };
    }, oe2 = function(e2) {
      var t2, n2 = this, r3 = false;
      return function(o2) {
        (t2 = o2.target.result) ? r3 && n2.results.length !== n2.limitRecord ? (n2.pushResult(t2.value), t2.continue()) : (r3 = true, t2.advance(n2.skipRecord)) : e2();
      };
    }, ue = function(e2) {
      var t2, n2 = this, r3 = false;
      return function(o2) {
        (t2 = o2.target.result) ? r3 ? (n2.pushResult(t2.value), t2.continue()) : (r3 = true, t2.advance(n2.skipRecord)) : e2();
      };
    }, ie = function(e2) {
      var t2, n2 = this;
      return function(r3) {
        (t2 = r3.target.result) ? (n2.pushResult(t2.value), t2.continue()) : e2();
      };
    }, ae2 = function(e2) {
      var t2, n2 = this;
      return function(r3) {
        (t2 = r3.target.result) && n2.results.length !== n2.limitRecord ? (n2.pushResult(t2.value), t2.continue()) : e2();
      };
    }, ce2 = function(e2) {
      return e2.replace(/\s/g, "");
    }, se2 = function(e2) {
      var t2;
      if (!this.query.store)
        if (null == this.query.join)
          t2 = this.getColumnInfo(e2);
        else {
          var n2 = ce2(e2).split("."), r3 = n2[1];
          t2 = this.getColumnInfo(r3, n2[0]);
        }
      if (null == t2) {
        var o2 = this.results[0][e2];
        if (o2)
          return { dataType: W(o2), name: e2 };
        throw new R(y, { column: e2, isOrder: true });
      }
      return t2;
    }, le = function(e2, t2) {
      return t2.localeCompare(e2);
    }, fe2 = function(e2, t2) {
      return e2.localeCompare(t2);
    }, he2 = function(e2, t2) {
      return new String(t2).localeCompare(e2);
    }, pe = function(e2, t2) {
      return new String(e2).localeCompare(t2);
    }, ye2 = function(e2, t2) {
      return t2 - e2;
    }, de = function(e2, t2) {
      return e2 - t2;
    }, ve2 = function(e2, t2) {
      return t2.getTime() - e2.getTime();
    }, me2 = function(e2, t2) {
      return e2.getTime() - t2.getTime();
    }, be2 = function(e2, t2) {
      switch (e2.dataType) {
        case r2.String:
          return "asc" === t2.type ? fe2 : le;
        case r2.Number:
          return "asc" === t2.type ? de : ye2;
        case r2.DateTime:
          return "asc" === t2.type ? me2 : ve2;
        default:
          return "asc" === t2.type ? pe : he2;
      }
    }, ge2 = function(e2) {
      var t2;
      e2.type = _e2(e2.type);
      var n2 = e2.by, o2 = this.thenEvaluator;
      if (null != n2 && typeof n2 === r2.Object) {
        var u2 = n2, i2 = function(e3, t3) {
          return function(n3, i3) {
            for (var a3 in u2) {
              o2.setCaseAndValue(u2, n3);
              var c4 = o2.setColumn(a3).evaluate();
              o2.setCaseAndValue(u2, i3);
              var s3 = o2.setColumn(a3).evaluate();
              return typeof n3[c4] === r2.String ? e3(n3[c4], i3[s3]) : t3(n3[c4], i3[s3]);
            }
          };
        }, a2 = "asc" === e2.type ? i2(fe2, de) : i2(le, ye2);
        this.results.sort(a2);
      } else {
        var c3 = se2.call(this, n2);
        if (null != c3) {
          var s2 = be2(c3, e2);
          n2 = c3.name, null == e2.case ? this.results.sort(function(e3, t3) {
            return s2(e3[n2], t3[n2]);
          }) : (o2.setCaseAndColumn(((t2 = {})[n2] = e2.case, t2), n2), this.results.sort(function(e3, t3) {
            return s2(o2.setValue(e3).evaluate(), o2.setValue(t3).evaluate());
          }));
        }
      }
    }, _e2 = function(e2) {
      return null == e2 ? "asc" : e2.toLowerCase();
    }, we2 = function(e2) {
      var t2, n2, r3 = e2.split("%");
      switch (r3[1] ? (t2 = r3[1], n2 = r3.length > 2 ? c2.Any : c2.Last) : (t2 = r3[0], n2 = c2.First), n2) {
        case c2.First:
          return new RegExp("^".concat(t2), "i");
        case c2.Last:
          return new RegExp("".concat(t2, "$"), "i");
        default:
          return new RegExp("".concat(t2), "i");
      }
    }, xe2 = function(e2) {
      return "object" === W(e2) && !(e2 instanceof RegExp);
    }, ke2 = function(e2) {
      if (xe2(e2)) {
        var t2 = {};
        for (var n2 in e2)
          t2[n2] = null != e2[n2] && xe2(e2[n2]) ? ke2(e2[n2]) : e2[n2];
        return t2;
      }
      return e2;
    }, Te = function(e2, t2, n2) {
      var o2 = W(e2);
      if (o2 !== W(t2))
        return false;
      switch (o2 === r2.DateTime && (e2 = e2.getTime(), t2 = t2.getTime()), n2) {
        case i.GreaterThan:
          return e2 > t2;
        case i.LessThan:
          return e2 < t2;
        case i.LessThanEqualTo:
          return e2 <= t2;
        case i.GreaterThanEqualTo:
          return e2 >= t2;
        case i.NotEqualTo:
          return e2 !== t2;
        default:
          var u2;
          return "array" === o2 ? e2.length === t2.length && (e2.every(function(e3, n3) {
            return u2 = e3 === t2[n3];
          }), u2) : e2 === t2;
      }
    }, Se2 = function() {
      function e2(e3, t2) {
        this.where = ke2(e3), this.checkFlag = t2;
      }
      return e2.prototype.remove = function(e3) {
        var t2 = e3.pop();
        delete e3.reduce(function(e4, t3) {
          return e4 && e4[t3];
        }, this.where)[t2];
      }, e2.prototype.check = function(e3) {
        var t2 = this, n2 = true;
        if (!this.checkFlag)
          return n2;
        var r3 = this.where, o2 = function(o3) {
          if (!n2)
            return { value: n2 };
          var u3 = r3[o3], a3 = e3[o3], c3 = H(a3), s2 = H(u3), l3 = function(e4) {
            c3 && !s2 ? a3.every(function(t3) {
              return !(n2 = e4(t3));
            }) : n2 = e4(a3);
          };
          if ("object" === W(u3)) {
            var f2 = function(e4) {
              if (!n2)
                return { value: n2 };
              switch (e4) {
                case i.In:
                  l3(function(e5) {
                    return t2.checkIn(u3[i.In], e5);
                  });
                  break;
                case i.Like:
                  l3(function(e5) {
                    return t2.checkLike_(o3, e5);
                  });
                  break;
                case i.Regex:
                  l3(function(e5) {
                    return t2.checkRegex(o3, e5);
                  });
                  break;
                case i.Between:
                case i.GreaterThan:
                case i.LessThan:
                case i.GreaterThanEqualTo:
                case i.LessThanEqualTo:
                case i.NotEqualTo:
                  l3(function(n3) {
                    return t2.checkComparisionOp_(o3, n3, e4);
                  });
                  break;
                default:
                  n2 = false;
              }
            };
            for (var h3 in u3) {
              var p3 = f2(h3);
              if ("object" == typeof p3)
                return p3;
            }
          } else
            l3(function(e4) {
              return Te(u3, e4);
            });
        };
        for (var u2 in r3) {
          var a2 = o2(u2);
          if ("object" == typeof a2)
            return a2.value;
        }
        return n2;
      }, e2.prototype.checkIn = function(e3, t2) {
        return null != e3.find(function(e4) {
          return Te(e4, t2);
        });
      }, e2.prototype.checkLike_ = function(e3, t2) {
        return we2(this.where[e3][i.Like]).test(t2);
      }, e2.prototype.checkRegex = function(e3, t2) {
        return this.where[e3][i.Regex].test(t2);
      }, e2.prototype.checkComparisionOp_ = function(e3, t2, n2) {
        var r3 = this.where[e3][n2];
        return n2 != i.Between ? Te(t2, r3, n2) : Te(t2, r3.low, ">=") && Te(t2, r3.high, "<=");
      }, e2;
    }(), Ee2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), Oe2 = function(e2) {
      function t2() {
        var t3 = null !== e2 && e2.apply(this, arguments) || this;
        return t3.limitAtEnd = false, t3.skipAtEnd = false, t3;
      }
      return Ee2(t2, e2), t2.prototype.goToWhereLogic = function() {
        var e3 = this, t3 = this.query, n2 = t3.where, r3 = function() {
          for (var t4 in n2)
            if (e3.objectStore.indexNames.contains(t4))
              return t4;
        }();
        if (null == r3 && (r3 = X2(n2), !t3.store))
          return N2(new R(d, { column: r3 }));
        var o2 = n2[r3];
        if ("object" !== W(o2))
          return u2 = $(n2) > 1, this.whereChecker = new Se2(n2, u2), this.whereChecker.remove([r3]), this.executeWhereLogic(r3, o2, null, "next");
        var u2 = $(o2) > 1 || $(n2) > 1;
        this.whereChecker = new Se2(n2, u2);
        var a2 = X2(o2);
        switch (this.whereChecker.remove([r3, a2]), a2) {
          case i.Like:
            var c3 = we2(o2[i.Like]);
            return this.executeRegexLogic(r3, c3);
          case i.Regex:
            return this.executeRegexLogic(r3, o2[i.Regex]);
          case i.In:
            return this.executeInLogic(r3, o2[i.In]);
          case i.Between:
          case i.GreaterThan:
          case i.LessThan:
          case i.GreaterThanEqualTo:
          case i.LessThanEqualTo:
            return this.executeWhereLogic(r3, o2, a2, "next");
          case i.Aggregate:
            break;
          default:
            return this.executeWhereLogic(r3, o2, null, "next");
        }
      }, t2;
    }(V2), Ce2 = function(e2, t2) {
      var n2 = this;
      return function(r3) {
        var o2 = r3.target.result;
        n2.results.length !== n2.limitRecord && o2 ? (n2.shouldAddValue(o2) && t2(o2.value), o2.continue()) : e2();
      };
    }, je2 = function(e2, t2) {
      var n2 = this;
      return function(r3) {
        var o2 = r3.target.result;
        o2 ? (n2.shouldAddValue(o2) && t2(o2.value), o2.continue()) : e2();
      };
    }, Ae = function() {
      return Ae = Object.assign || function(e2) {
        for (var t2, n2 = 1, r3 = arguments.length; n2 < r3; n2++)
          for (var o2 in t2 = arguments[n2])
            Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
        return e2;
      }, Ae.apply(this, arguments);
    }, qe2 = function() {
      function e2(e3) {
        this.joinQueryStack_ = [], this.currentQueryStackIndex_ = 0, this.tablesFetched = [], this.results = [], this.select = e3;
      }
      return Object.defineProperty(e2.prototype, "query", { get: function() {
        return this.select.query;
      }, enumerable: false, configurable: true }), e2.prototype.getTable = function(e3) {
        return this.select.table(e3);
      }, e2.prototype.executeSelect = function(e3) {
        return new Ne2(e3, this.select.util).execute();
      }, e2.prototype.execute = function() {
        var e3 = this, t2 = this.query;
        this.joinQueryStack_ = W(t2.join) === r2.Object ? [t2.join] : t2.join;
        var n2 = t2.from, o2 = [];
        n2 && o2.push(n2);
        for (var u2 = this.joinQueryStack_, i2 = 0, a2 = u2.length; i2 < a2; i2++) {
          var c3 = u2[i2], s2 = this.getJoinTableInfo_(c3.on);
          c3.with === s2.table1.table && (s2 = { table1: s2.table2, table2: s2.table1 });
          var l3 = this.checkJoinQuery_(s2, c3);
          if (l3)
            return N2(l3);
          u2[i2].joinTableInfo = s2, c3.with && o2.push(c3.with);
        }
        !this.select.isTxQuery && o2.length > 0 && this.select.util.createTransaction(o2);
        var f2 = t2.where;
        if (f2 && !t2.store) {
          var h3 = this.getTable(n2), p3 = function(e4) {
            var t3;
            if (Array.isArray(e4))
              t3 = [], e4 = e4.filter(function(e5) {
                var n4 = p3(e5);
                return Object.keys(n4.whereQryAfterJoin).length > 0 && t3.push(n4.whereQryAfterJoin), !n4.isWhereEmpty;
              });
            else {
              t3 = {};
              var n3 = function(n4) {
                if ("or" === n4) {
                  var r4 = {}, o3 = e4[n4], u3 = function(e5) {
                    h3.columns.find(function(t4) {
                      return t4.name === e5;
                    }) || (r4[e5] = o3[e5]);
                  };
                  for (var i3 in o3)
                    u3(i3);
                  if ($(r4) > 0)
                    for (var i3 in t3.or = r4, r4)
                      delete o3[i3];
                } else
                  h3.columns.find(function(e5) {
                    return e5.name === n4;
                  }) || (t3[n4] = f2[n4]);
              };
              for (var r3 in e4)
                n3(r3);
              for (var r3 in t3)
                delete e4[r3];
            }
            return { isWhereEmpty: 0 === $(e4), whereQryAfterJoin: t3, whereQueryModified: e4 };
          }, y2 = p3(f2), d2 = y2.whereQryAfterJoin;
          t2.where = y2.whereQueryModified, y2.isWhereEmpty && delete t2.where;
          var v2 = this.joinQueryStack_[0];
          Object.assign(v2.whereJoin, d2);
        }
        return this.executeSelect({ from: n2, where: t2.where, case: t2.case, flatten: t2.flatten, store: t2.store, meta: t2.meta }).then(function(t3) {
          return e3.results = t3.map(function(t4) {
            var n3;
            return (n3 = {})[e3.currentQueryStackIndex_] = t4, n3;
          }), e3.tablesFetched.push(u2[0].joinTableInfo.table1.table), e3.startExecutingJoinLogic_();
        });
      }, e2.prototype.onJoinQueryFinished_ = function() {
        if (0 !== this.results.length) {
          var e3 = this.select;
          try {
            var t2 = [], n2 = z(this.results[0]).length;
            this.results.forEach(function(e4) {
              for (var r3 = e4[0], o2 = 1; o2 < n2; o2++)
                r3 = Ae(Ae({}, r3), e4[o2]);
              t2.push(r3);
            }), e3.results = t2, e3.setLimitAndSkipEvaluationAtEnd_(), e3.query.flatten = null, e3.processOrderBy();
          } catch (e4) {
            return N2(new R(T, e4.message));
          }
        }
      }, e2.prototype.startExecutingJoinLogic_ = function() {
        var e3 = this, t2 = this.joinQueryStack_[this.currentQueryStackIndex_];
        if (!t2)
          return this.onJoinQueryFinished_();
        try {
          var n2 = t2.joinTableInfo;
          return this.executeSelect({ from: t2.with, where: t2.where, case: t2.case, flatten: t2.flatten, store: t2.store, meta: t2.meta }).then(function(r3) {
            return e3.jointables(t2, n2, r3), e3.tablesFetched.push(n2.table2.table), ++e3.currentQueryStackIndex_, e3.startExecutingJoinLogic_();
          });
        } catch (e4) {
          return N2(new R(T, e4.message));
        }
      }, e2.prototype.jointables = function(e3, t2, n2) {
        var r3, o2, u2, i2, a2 = e3.type, c3 = [], s2 = t2.table1.column, l3 = t2.table2.column, f2 = this.tablesFetched.indexOf(t2.table1.table), h3 = this.currentQueryStackIndex_ + 1, p3 = e3.as, y2 = p3 ? function(e4) {
          for (var t3 in p3) {
            var n3 = p3[t3];
            void 0 === e4[n3] && (e4[n3] = e4[t3], delete e4[t3]);
          }
          return e4;
        } : function(e4) {
          return e4;
        }, d2 = 0, v2 = Object.assign({}, e3.whereJoin), m2 = new Se2(v2, $(v2) > 0);
        "left" === a2 ? (i2 = {}, e3.store ? z(e3.store).forEach(function(e4) {
          i2[e4] = null;
        }) : this.getTable(t2.table2.table).columns.forEach(function(e4) {
          i2[e4.name] = null;
        }), o2 = 1 === h3 ? function(e4, t3) {
          return t3[f2][s2] === e4[l3];
        } : function(e4, t3) {
          var n3 = t3[f2];
          return null != n3 && n3[s2] === e4[l3];
        }, u2 = function() {
          0 === r3.length && (r3 = [i2]);
        }) : (o2 = function(e4, t3) {
          return t3[f2][s2] === e4[l3];
        }, u2 = function() {
        }), this.results.forEach(function(e4) {
          r3 = [], n2.forEach(function(t3) {
            o2(t3, e4) && r3.push(Ae({}, t3));
          }), u2(), r3.forEach(function(t3) {
            t3 = y2(t3), m2.check(t3) && (c3[d2] = Ae({}, e4), c3[d2++][h3] = t3);
          });
        }), this.results = c3;
      }, e2.prototype.getJoinTableInfo_ = function(e3) {
        var t2 = (e3 = ce2(e3)).split("="), n2 = t2[0].split("."), r3 = t2[1].split(".");
        return { table1: { table: n2[0], column: n2[1] }, table2: { table: r3[0], column: r3[1] } };
      }, e2.prototype.checkJoinQuery_ = function(e3, t2) {
        if (t2.store)
          return null;
        var n2, r3 = e3.table1, o2 = e3.table2, u2 = this.getTable(r3.table), i2 = this.getTable(o2.table);
        t2.with !== o2.table && (n2 = new R(T, "on value should contains value of with")), null == u2.columns.find(function(e4) {
          return e4.name === r3.column;
        }) ? n2 = new R(T, "column ".concat(r3.column, " does not exist in table ").concat(r3.table)) : null == i2.columns.find(function(e4) {
          return e4.name === o2.column;
        }) && (n2 = new R(T, "column ".concat(o2.column, " does not exist in table ").concat(o2.table))), null == t2.as && (t2.as = {}), u2.columns.every(function(e4) {
          var u3 = i2.columns.find(function(t3) {
            return t3.name === e4.name && t3.name !== r3.column;
          });
          return null == u3 || null != t2.as[u3.name] || (n2 = new R(T, "column ".concat(e4.name, " exist in both table ").concat(r3.table, " & ").concat(o2.table)), false);
        });
        var a2 = t2.where, c3 = {};
        if (a2) {
          var s2 = function(e4) {
            switch (e4) {
              case "or":
              case "in":
                break;
              default:
                i2.columns.find(function(t3) {
                  return t3.name === e4;
                }) || (c3[e4] = a2[e4], delete a2[e4]);
            }
          };
          for (var l3 in a2)
            s2(l3);
          0 === $(a2) && (t2.where = null);
        }
        return t2.whereJoin = c3, n2;
      }, e2;
    }(), Ie2 = function() {
      function e2(e3) {
        this.data = e3;
      }
      return Object.defineProperty(e2.prototype, "indexNames", { get: function() {
        var e3 = z(this.data[0]);
        return { contains: function(t2) {
          return e3.indexOf(t2) >= 0;
        } };
      }, enumerable: false, configurable: true }), e2.prototype.index = function(e3) {
        var t2 = this;
        return { openCursor: function(n2) {
          var r3 = {}, o2 = 0, u2 = { continue: function() {
            ++o2, a2();
          } }, i2 = function(e4) {
            r3.onsuccess({ target: { result: e4 } });
          }, a2 = function() {
            var r4 = t2.data[o2];
            if (r4) {
              var a3 = r4[e3];
              a3 && (null == n2 || n2.includes(a3)) ? (u2.key = a3, u2.value = r4, i2(u2)) : u2.continue();
            } else
              i2(null);
          };
          return l2().then(a2), r3;
        } };
      }, e2;
    }(), Re2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), Qe2 = function() {
      return Qe2 = Object.assign || function(e2) {
        for (var t2, n2 = 1, r3 = arguments.length; n2 < r3; n2++)
          for (var o2 in t2 = arguments[n2])
            Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
        return e2;
      }, Qe2.apply(this, arguments);
    }, Le2 = function(e2, t2, n2) {
      if (n2 || 2 === arguments.length)
        for (var r3, o2 = 0, u2 = t2.length; o2 < u2; o2++)
          !r3 && o2 in t2 || (r3 || (r3 = Array.prototype.slice.call(t2, 0, o2)), r3[o2] = t2[o2]);
      return e2.concat(r3 || Array.prototype.slice.call(t2));
    }, Ne2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        r3.sorted = false, r3.isSubQuery = false, r3.thenEvaluator = new Y2(), r3.returnResult_ = function() {
          if (r3.results.length > 0) {
            var e3 = r3.query;
            if (e3.flatten) {
              var t4 = [], n3 = /* @__PURE__ */ new Map();
              e3.flatten.forEach(function(e4) {
                r3.results.forEach(function(r4, o4) {
                  r4[e4].forEach(function(n4) {
                    var o5;
                    t4.push(Qe2(Qe2({}, r4), ((o5 = {})[e4] = n4, o5)));
                  }), n3.set(o4, true);
                });
              });
              var o3 = 0;
              n3.forEach(function(e4, t5) {
                r3.results.splice(t5 - o3, 1), ++o3;
              }), r3.results = r3.results.concat(t4);
            }
            r3.processGroupDistinctAggr(), r3.processOrderBy(), r3.skipAtEnd && r3.results.splice(0, e3.skip), r3.limitAtEnd && (r3.results = r3.results.slice(0, e3.limit));
          }
          return r3.results;
        }, r3.query = t3, r3.util = n2, r3.tableName = t3.from, r3.setPushResult(), H(t3.where) ? (r3.isArrayQry = true, r3.setLimitAndSkipEvaluationAtEnd_()) : (r3.skipRecord = t3.skip, r3.limitRecord = t3.limit);
        var o2 = t3.order;
        return o2 ? ((H(o2) || o2.case || "object" == typeof o2.by) && (o2.idbSorting = false), r3.setLimitAndSkipEvaluationAtEnd_()) : t3.groupBy && r3.setLimitAndSkipEvaluationAtEnd_(), r3;
      }
      return Re2(t2, e2), t2.prototype.execute = function(e3) {
        var t3 = this;
        e3 || (e3 = function() {
          return l2(null);
        });
        var n2 = this.query;
        try {
          var r3 = new K2(this.db).validate(o.Select, n2);
          return r3 ? N2(r3) : e3().then(function(e4) {
            return t3.initTransaction_(), (null == n2.join ? null != n2.where ? H(n2.where) ? t3.processWhereArrayQry() : t3.processWhere_() : t3.executeWhereUndefinedLogic() : t3.executeJoinQuery()).then(t3.returnResult_.bind(t3));
          });
        } catch (e4) {
          return this.onException(e4);
        }
      }, t2.prototype.processWhereArrayQry = function() {
        var e3 = this;
        this.isArrayQry = true;
        var n2, r3 = this.query.where, o2 = this.primaryKey(), u2 = true, a2 = [], c3 = function() {
          var t3;
          return n2 === i.And ? true === u2 ? a2 = e3.results : a2.length > 0 && (t3 = [], e3.results.forEach(function(e4) {
            var n3;
            n3 = e4[o2], a2.findIndex(function(e5) {
              return e5[o2] === n3;
            }) >= 0 && t3.push(e4);
          }), a2 = t3, t3 = null) : (a2.length > 0 && (e3.results = Le2(Le2([], a2, true), e3.results, true), e3.removeDuplicates()), a2 = e3.results), u2 = false, r3.length > 0 ? (e3.results = [], f2()) : (e3.results = a2, l2());
        }, s2 = function(n3) {
          return new t2({ from: e3.query.from, where: n3 }, e3.util).execute().then(function(t3) {
            return e3.results = t3, c3();
          });
        }, f2 = function() {
          var t3 = r3.shift(), o3 = t3[i.Or];
          if (o3) {
            if (H(o3))
              return n2 = i.Or, s2(o3);
            1 === $(t3) ? (n2 = i.Or, t3 = o3) : n2 = i.And;
          } else if (n2 = i.And, H(t3))
            return s2(t3);
          return e3.query.where = t3, e3.processWhere_().then(c3);
        };
        return f2();
      }, t2.prototype.initTransaction_ = function() {
        var e3 = this.query.store;
        e3 ? this.objectStore = new Ie2(e3) : (this.isTxQuery || this.util.createTransactionIfNotExist([this.tableName], a.ReadOnly), this.objectStore = this.util.objectStore(this.tableName));
      }, t2.prototype.processWhere_ = function() {
        var e3 = this;
        return this.shouldAddValue = function(t3) {
          var n2 = t3.value, r3 = e3, o2 = new Proxy(n2, { get: function(e4, t4, o3) {
            var u2 = n2[t4];
            if (!u2) {
              var i2 = r3.getColumnInfo(t4);
              if (i2 && i2.keyPath)
                return i2.keyPath.map(function(e5) {
                  return n2[e5];
                });
            }
            return u2;
          } });
          return e3.whereChecker.check(o2);
        }, this.query.where.or && this.processOrLogic_(), this.goToWhereLogic().then(function() {
          return e3.onWhereEvaluated();
        });
      }, t2.prototype.onWhereEvaluated = function() {
        if (this.isOr)
          return this.orQuerySuccess_();
      }, t2.prototype.orQueryFinish_ = function() {
        this.isOr = false, this.results = this.orInfo.results, this.orInfo = null, this.removeDuplicates();
      }, t2.prototype.orQuerySuccess_ = function() {
        var e3 = this.query;
        this.results.length > 0 && (this.orInfo.results = Le2(Le2([], this.orInfo.results, true), this.results, true)), this.results = [];
        var t3 = X2(this.orInfo.orQuery);
        if (null != t3) {
          var n2 = {};
          return n2[t3] = this.orInfo.orQuery[t3], delete this.orInfo.orQuery[t3], e3.where = n2, this.goToWhereLogic().then(this.onWhereEvaluated.bind(this));
        }
        return this.orQueryFinish_();
      }, t2.prototype.processOrLogic_ = function() {
        this.isOr = true;
        var e3 = this.query.where;
        this.orInfo = { orQuery: e3.or, results: [] }, this.setLimitAndSkipEvaluationAtEnd_(), delete e3.or;
      }, t2;
    }(Oe2);
    Ne2.prototype.executeInLogic = function(e2, t2) {
      var n2 = this, r3 = this.skipRecord, o2 = function(e3) {
        0 === r3 ? n2.pushResult(e3) : --r3;
      }, u2 = Z2.call(this, re2, ne2, je2, Ce2);
      return L2(t2.map(function(t3) {
        return f(function(r4, i2) {
          var a2 = n2.objectStore.index(e2).openCursor(n2.util.keyRange(t3));
          a2.onsuccess = u2.call(n2, r4, o2), a2.onerror = i2;
        });
      }));
    }, Ne2.prototype.executeWhereUndefinedLogic = function() {
      var e2, t2 = this, n2 = this.query, r3 = n2.store;
      if (r3)
        return this.results = r3, this.setLimitAndSkipEvaluationAtEnd_(), l2();
      var o2 = n2.order, u2 = this.objectStore;
      if (o2 && false !== o2.idbSorting && o2.by) {
        if (!u2.indexNames.contains(o2.by))
          return N2(new R(y, { column: o2.by, isOrder: true }));
        var i2 = o2.type && "desc" === o2.type.toLowerCase() ? "prev" : "next";
        this.sorted = true, e2 = u2.index(o2.by).openCursor(null, i2);
      } else
        e2 = u2.openCursor();
      var a2 = Z2.call(this, ie, ae2, ue, oe2);
      return f(function(n3, r4) {
        e2.onerror = r4, e2.onsuccess = a2.call(t2, n3);
      });
    }, Ne2.prototype.executeWhereLogic = function(e2, t2, n2, r3) {
      var o2 = this;
      t2 = n2 ? t2[n2] : t2;
      var u2 = this.objectStore.index(e2).openCursor(this.util.keyRange(t2, n2), r3), i2 = Z2.call(this, re2, ne2, te2, ee2);
      return f(function(e3, t3) {
        u2.onerror = t3, u2.onsuccess = i2.call(o2, e3);
      });
    }, Ne2.prototype.executeRegexLogic = function(e2, t2) {
      var n2 = this, r3 = this.skipRecord, o2 = function(e3) {
        0 === r3 ? n2.pushResult(e3) : --r3;
      };
      this.shouldAddValue = function(e3) {
        return t2.test(e3.key) && n2.whereChecker.check(e3.value);
      };
      var u2 = this.objectStore.index(e2).openCursor(), i2 = Z2.call(this, re2, ne2, je2, Ce2);
      return f(function(e3, t3) {
        u2.onerror = t3, u2.onsuccess = i2.call(n2, e3, o2);
      });
    }, Ne2.prototype.setLimitAndSkipEvaluationAtEnd_ = function() {
      this.query.limit && (this.limitAtEnd = true), this.query.skip && (this.skipAtEnd = true);
    }, Ne2.prototype.setPushResult = function() {
      var e2 = this, t2 = this.query.case;
      this.pushResult = t2 ? function(n2) {
        var r3;
        for (r3 in e2.thenEvaluator.setCaseAndValue(t2, n2), t2)
          n2[r3] = e2.thenEvaluator.setColumn(r3).evaluate();
        e2.results.push(n2);
      } : function(t3) {
        e2.results.push(t3);
      };
    }, Ne2.prototype.removeDuplicates = function() {
      for (var e2 = this.results, t2 = this.primaryKey(), n2 = /* @__PURE__ */ new Map(), r3 = 0, o2 = e2.length; r3 < o2; r3++)
        n2.set(e2[r3][t2], e2[r3]);
      this.results = Array.from(n2.values());
    }, Ne2.prototype.executeJoinQuery = function() {
      return new qe2(this).execute();
    }, Ne2.prototype.processGroupDistinctAggr = function() {
      var e2 = this.query;
      if (e2.distinct) {
        var t2 = [], n2 = this.results[0];
        for (var r3 in n2)
          t2.push(r3);
        var o2 = this.primaryKey(), u2 = t2.indexOf(o2);
        t2.splice(u2, 1), e2.groupBy = t2.length > 0 ? t2 : null;
      }
      e2.groupBy ? e2.aggregate ? this.executeAggregateGroupBy() : this.processGroupBy() : e2.aggregate && this.processAggregateQry();
    }, Ne2.prototype.processOrderBy = function() {
      var e2 = this.query.order;
      if (e2 && this.results.length > 0 && !this.sorted) {
        var t2 = W(e2);
        if (t2 === r2.Object)
          ge2.call(this, e2);
        else if (t2 === r2.Array) {
          ge2.call(this, e2[0]);
          for (var n2 = function(t3, n3) {
            var r3 = e2[t3 - 1].by, u3 = e2[t3], i3 = u3.by, a2 = se2.call(o2, i3);
            if (null != a2) {
              i3 = a2.name, u3.type = _e2(u3.type);
              var c3 = be2(a2, u3);
              o2.results.sort(function(e3, t4) {
                return e3[r3] === t4[r3] ? c3(e3[i3], t4[i3]) : 0;
              });
            }
          }, o2 = this, u2 = 1, i2 = e2.length; u2 < i2; u2++)
            n2(u2);
        }
      }
    }, Ne2.prototype.processAggregateQry = function() {
      var e2, t2 = this.results, n2 = t2.length, o2 = {}, u2 = function() {
        var n3 = 0;
        for (var r3 in t2)
          n3 += t2[r3][e2] ? 1 : 0;
        return n3;
      }, i2 = function() {
        var n3 = 0;
        for (var r3 in t2)
          n3 = n3 > t2[r3][e2] ? n3 : t2[r3][e2];
        return n3;
      }, a2 = function() {
        var n3 = 1 / 0, r3 = 1 / 0;
        for (var o3 in t2)
          n3 = n3 < (r3 = t2[o3][e2] ? t2[o3][e2] : 1 / 0) ? n3 : r3;
        return n3;
      }, c3 = function() {
        var n3 = 0;
        for (var r3 in t2)
          n3 += t2[r3][e2];
        return n3;
      }, s2 = function() {
        return c3() / n2;
      }, l3 = this.query.aggregate;
      for (var f2 in l3) {
        var h3 = l3[f2], p3 = W(h3), y2 = void 0;
        switch (f2) {
          case "count":
            y2 = u2;
            break;
          case "max":
            y2 = i2;
            break;
          case "min":
            y2 = a2;
            break;
          case "sum":
            y2 = c3;
            break;
          case "avg":
            y2 = s2;
        }
        switch (p3) {
          case r2.String:
            e2 = h3, o2["".concat(f2, "(").concat(e2, ")")] = y2();
            break;
          case r2.Array:
            for (var d2 in h3)
              e2 = h3[d2], o2["".concat(f2, "(").concat(e2, ")")] = y2();
        }
      }
      for (var f2 in o2)
        t2[0][f2] = o2[f2];
      this.results = [t2[0]];
    }, Ne2.prototype.executeAggregateGroupBy = function() {
      var e2, t2, n2, o2, u2 = this.query.groupBy, a2 = this.results, c3 = /* @__PURE__ */ new Map(), s2 = this.query.aggregate, l3 = function() {
        var u3 = function() {
          return n2 = (n2 = c3.get(t2)) ? n2["count(" + o2 + ")"] : 0, n2 += a2[e2][o2] ? 1 : 0;
        }, l4 = function() {
          return (n2 = (n2 = c3.get(t2)) ? n2["list(" + o2 + ")"] : []).push(a2[e2][o2]), n2;
        }, f3 = function() {
          return n2 = (n2 = c3.get(t2)) ? n2["max(" + o2 + ")"] : 0, a2[e2][o2] = a2[e2][o2] ? a2[e2][o2] : 0, n2 > a2[e2][o2] ? n2 : a2[e2][o2];
        }, h4 = function() {
          return n2 = (n2 = c3.get(t2)) ? n2["min(" + o2 + ")"] : 1 / 0, a2[e2][o2] = a2[e2][o2] ? a2[e2][o2] : 1 / 0, n2 < a2[e2][o2] ? n2 : a2[e2][o2];
        }, p4 = function() {
          return n2 = (n2 = c3.get(t2)) ? n2["sum(" + o2 + ")"] : 0, n2 += a2[e2][o2] ? a2[e2][o2] : 0;
        }, y3 = function() {
          var r3 = (n2 = c3.get(t2)) ? n2["sum(" + o2 + ")"] : 0;
          r3 += a2[e2][o2] ? a2[e2][o2] : 0, a2[e2]["sum(" + o2 + ")"] = r3, n2 = n2 ? n2["count(" + o2 + ")"] : 0, n2 += a2[e2][o2] ? 1 : 0, a2[e2]["count(" + o2 + ")"] = n2;
        };
        for (var d3 in s2) {
          var v3 = s2[d3], m3 = W(v3), b3 = void 0;
          switch (d3) {
            case i.Count:
              b3 = u3;
              break;
            case i.Max:
              b3 = f3;
              break;
            case i.Min:
              b3 = h4;
              break;
            case i.Sum:
              b3 = p4;
              break;
            case i.Avg:
              b3 = y3;
              break;
            case i.List:
              b3 = l4;
          }
          switch (m3) {
            case r2.String:
              o2 = v3, a2[e2]["".concat(d3, "(").concat(o2, ")")] = b3();
              break;
            case r2.Array:
              for (var g4 in v3)
                o2 = v3[g4], a2[e2]["".concat(d3, "(").concat(o2, ")")] = b3();
          }
        }
      };
      if (W(u2) === r2.String)
        for (e2 in a2)
          t2 = a2[e2][u2], l3(), c3.set(t2, a2[e2]);
      else
        for (e2 in a2) {
          for (var f2 in t2 = "", u2)
            t2 += a2[e2][u2[f2]];
          l3(), c3.set(t2, a2[e2]);
        }
      a2 = Array.from(c3.values());
      var h3 = s2.avg;
      if (h3)
        if (W(h3) === r2.String)
          for (e2 in a2) {
            var p3 = a2[e2]["sum(" + h3 + ")"], y2 = a2[e2]["count(" + h3 + ")"];
            a2[e2]["avg(" + h3 + ")"] = p3 / y2, s2.count !== h3 && delete a2[e2]["count(" + h3 + ")"], s2.sum !== h3 && delete a2[e2]["sum(" + h3 + ")"];
          }
        else {
          var d2 = W(s2.count) === r2.String, v2 = W(s2.sum) === r2.String;
          for (e2 in a2)
            for (var f2 in h3) {
              var m2 = h3[f2], b2 = a2[e2]["sum(" + m2 + ")"], g3 = a2[e2]["count(" + m2 + ")"];
              a2[e2]["avg(" + m2 + ")"] = b2 / g3, d2 && (s2.count !== m2 || -1 === s2.count.indexOf(m2)) && delete a2[e2]["count(" + m2 + ")"], v2 && (s2.sum !== m2 || -1 === s2.sum.indexOf(m2)) && delete a2[e2]["sum(" + m2 + ")"];
            }
        }
      this.results = a2;
    }, Ne2.prototype.processGroupBy = function() {
      var e2 = this.query.groupBy, t2 = this.results, n2 = /* @__PURE__ */ new Map(), o2 = W(e2);
      if (o2 !== r2.Object)
        if (o2 === r2.String)
          for (var u2 in t2)
            n2.set(t2[u2][e2], t2[u2]);
        else {
          var i2 = void 0;
          for (var u2 in t2) {
            for (var a2 in i2 = "", e2)
              i2 += t2[u2][e2[a2]];
            n2.set(i2, t2[u2]);
          }
        }
      else if (1 === Object.keys(e2).length) {
        var c3 = X2(e2);
        for (var u2 in this.thenEvaluator.setCaseAndColumn(e2, c3), t2)
          n2.set(this.thenEvaluator.setValue(t2[u2]).evaluate(), t2[u2]);
      } else
        for (var u2 in i2 = void 0, t2) {
          for (var a2 in i2 = "", this.thenEvaluator.setCaseAndValue(e2, t2[u2]), e2)
            i2 += this.thenEvaluator.setColumn(a2).evaluate();
          n2.set(i2, t2[u2]);
        }
      this.results = Array.from(n2.values());
    };
    var De2 = function(e2) {
      var t2 = this;
      return function(n2) {
        var r3 = n2.target.result;
        r3 ? (t2.shouldAddValue(r3) && ++t2.resultCount, r3.continue()) : e2();
      };
    }, Ve2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), We2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.resultCount = 0, r3.query = t3, r3.util = n2, r3.tableName = t3.from, r3;
      }
      return Ve2(t2, e2), t2.prototype.execute = function(e3) {
        var t3 = this, n2 = new K2(this.db), r3 = this.query, u2 = n2.validate(o.Count, r3);
        return u2 ? N2(u2) : e3().then(function(e4) {
          var n3;
          try {
            var o2 = function() {
              var e5 = new Ne2(r3, t3.util);
              return e5.isTxQuery = t3.isTxQuery, e5.execute().then(function(e6) {
                t3.resultCount = e6.length;
              });
            };
            t3.initTransaction_(), null == r3.join ? null != r3.where ? r3.where.or || H(r3.where) ? n3 = o2() : (t3.shouldAddValue = function(e5) {
              return t3.whereChecker.check(e5.value);
            }, n3 = t3.goToWhereLogic()) : n3 = t3.executeWhereUndefinedLogic() : n3 = o2();
          } catch (e5) {
            t3.onException(e5);
          }
          return n3.then(function(e5) {
            return t3.resultCount;
          });
        });
      }, t2.prototype.initTransaction_ = function() {
        var e3 = this.query.from;
        this.isTxQuery || this.util.createTransaction([e3], a.ReadOnly), this.objectStore = this.util.objectStore(e3);
      }, t2;
    }(Oe2);
    We2.prototype.executeWhereUndefinedLogic = function() {
      var e2, t2, n2 = this, r3 = this.objectStore, o2 = r3.count ? (e2 = r3.count(), function(t3) {
        return function() {
          n2.resultCount = e2.result, t3();
        };
      }) : (e2 = r3.openCursor(), function(e3) {
        return function(r4) {
          (t2 = r4.target.result) ? (++n2.resultCount, t2.continue()) : e3();
        };
      });
      return f(function(t3, n3) {
        e2.onerror = n3, e2.onsuccess = o2(t3);
      });
    }, We2.prototype.executeWhereLogic = function(e2, t2, n2) {
      var r3, o2 = this;
      t2 = n2 ? t2[n2] : t2;
      var u2 = 1 === $(this.query.where), i2 = this.objectStore;
      return f(function(a2, c3) {
        u2 && i2.count ? (r3 = i2.index(e2).count(o2.util.keyRange(t2, n2))).onsuccess = function() {
          o2.resultCount = r3.result, a2();
        } : (r3 = i2.index(e2).openCursor(o2.util.keyRange(t2, n2))).onsuccess = De2.call(o2, a2), r3.onerror = c3;
      });
    }, We2.prototype.executeRegexLogic = function(e2, t2) {
      var n2 = this, r3 = this.objectStore.index(e2).openCursor();
      return this.shouldAddValue = function(e3) {
        return t2.test(e3.key) && n2.whereChecker.check(e3.value);
      }, f(function(e3, t3) {
        r3.onerror = t3, r3.onsuccess = De2.call(n2, e3);
      });
    }, We2.prototype.executeInLogic = function(e2, t2) {
      var n2 = this, r3 = this.objectStore, o2 = r3.index(e2), u2 = 1 === $(this.query.where);
      return L2(t2.map(function(e3) {
        return t3 = e3, i2 = n2.util.keyRange(t3), u2 && r3.count ? f(function(e4, t4) {
          var r4 = o2.count(i2);
          r4.onsuccess = function(t5) {
            n2.resultCount += t5.target.result, e4();
          }, r4.onerror = t4;
        }) : f(function(e4, t4) {
          var r4 = o2.openCursor(i2);
          r4.onsuccess = De2.call(n2, e4), r4.onerror = t4;
        });
        var t3, i2;
      }));
    };
    var Be2 = function(e2) {
      return (H(e2) ? e2 : e2.split(".")).reduce(function(e3, t2) {
        return e3 && e3[t2];
      }, self);
    }, Pe2 = function(e2, t2) {
      var n2 = e2.set, o2 = e2.mapSet;
      if (o2) {
        var u2 = o2(n2, t2);
        null != u2 && (n2 = u2);
      }
      for (var i2 in n2) {
        var a2 = n2[i2];
        if (W(a2) !== r2.Object)
          t2[i2] = a2;
        else
          for (var c3 in a2) {
            var s2 = a2[c3];
            switch (c3) {
              case "+":
                t2[i2] += s2;
                break;
              case "-":
                t2[i2] -= s2;
                break;
              case "*":
                t2[i2] *= s2;
                break;
              case "/":
                t2[i2] /= s2;
                break;
              case "{push}":
                t2[i2].push(s2);
                break;
              default:
                t2[i2] = a2;
            }
            break;
          }
      }
      return t2;
    }, Me2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), Ke2 = function(e2) {
      function t2(t3, n2) {
        var o2 = e2.call(this) || this;
        o2.query = t3, o2.util = n2, o2.tableName = t3.in;
        var u2 = t3.mapSet;
        if (u2) {
          var i2 = W(u2) === r2.String ? Be2(u2) : u2;
          if (!i2)
            throw new R(E, u2);
          t3.mapSet = i2;
        }
        return o2;
      }
      return Me2(t2, e2), t2.prototype.execute = function(e3) {
        var t3 = this, n2 = this.query;
        try {
          var r3 = new K2(this.db).validate(o.Update, n2);
          return r3 ? N2(r3) : e3().then(function(e4) {
            return t3.initTransaction(), (null != n2.where ? n2.where.or || H(n2.where) ? t3.executeComplexLogic_() : t3.goToWhereLogic() : t3.executeWhereUndefinedLogic()).then(function() {
              return t3.rowAffected;
            });
          });
        } catch (e4) {
          return this.onException(e4);
        }
      }, t2.prototype.executeComplexLogic_ = function() {
        var e3 = this, t3 = this.query, n2 = new Ne2({ from: t3.in, where: t3.where, ignoreCase: t3.ignoreCase }, this.util);
        return n2.isTxQuery = this.isTxQuery, n2.execute().then(function(n3) {
          var r3, o2, u2 = e3.primaryKey(t3.in), a2 = [];
          n3.forEach(function(e4) {
            a2.push(e4[u2]);
          }), n3 = null;
          var c3 = ((r3 = {})[u2] = ((o2 = {})[i.In] = a2, o2), r3);
          return e3.query.where = c3, e3.initTransaction(), e3.goToWhereLogic();
        });
      }, t2.prototype.initTransaction = function() {
        var e3 = this.query.in;
        this.isTxQuery || this.util.createTransaction([e3]), this.objectStore = this.util.objectStore(e3);
      }, t2;
    }(Oe2);
    Ke2.prototype.executeWhereUndefinedLogic = function() {
      var e2 = this, t2 = this.objectStore.openCursor();
      return f(function(n2, r3) {
        t2.onsuccess = function(t3) {
          var o2 = t3.target.result;
          if (o2)
            try {
              var u2 = o2.update(Pe2(e2.query, o2.value));
              u2.onsuccess = function() {
                ++e2.rowAffected, o2.continue();
              }, u2.onerror = r3;
            } catch (e3) {
              r3(e3);
            }
          else
            n2();
        }, t2.onerror = r3;
      });
    }, Ke2.prototype.executeWhereLogic = function(e2, t2, n2) {
      var r3 = this, o2 = this.query;
      t2 = n2 ? t2[n2] : t2;
      var u2 = this.objectStore.index(e2).openCursor(this.util.keyRange(t2, n2));
      return f(function(e3, t3) {
        u2.onsuccess = function(n3) {
          var u3 = n3.target.result;
          if (u3)
            if (r3.whereChecker.check(u3.value))
              try {
                var i2 = u3.update(Pe2(o2, u3.value));
                i2.onsuccess = function() {
                  ++r3.rowAffected, u3.continue();
                }, i2.onerror = t3;
              } catch (e4) {
                t3(e4);
              }
            else
              u3.continue();
          else
            e3();
        }, u2.onerror = t3;
      });
    }, Ke2.prototype.executeRegexLogic = function(e2, t2) {
      var n2, r3 = this, o2 = this.objectStore.index(e2).openCursor();
      return this.shouldAddValue = function(e3) {
        return t2.test(e3.key) && r3.whereChecker.check(e3.value);
      }, f(function(e3, t3) {
        o2.onsuccess = function(o3) {
          if (n2 = o3.target.result)
            if (r3.shouldAddValue(n2))
              try {
                var u2 = n2.update(Pe2(r3.query, n2.value));
                u2.onsuccess = function() {
                  ++r3.rowAffected, n2.continue();
                }, u2.onerror = t3;
              } catch (e4) {
                t3(e4);
              }
            else
              n2.continue();
          else
            e3();
        }, o2.onerror = t3;
      });
    }, Ke2.prototype.executeInLogic = function(e2, t2) {
      var n2 = this, r3 = this.objectStore.index(e2), o2 = this.query;
      return L2(t2.map(function(e3) {
        return t3 = e3, f(function(e4, u2) {
          var i2 = r3.openCursor(n2.util.keyRange(t3));
          i2.onsuccess = function(t4) {
            var r4 = t4.target.result;
            if (r4) {
              var i3 = r4.value;
              if (n2.whereChecker.check(i3))
                try {
                  var a2 = r4.update(Pe2(o2, i3));
                  a2.onsuccess = function() {
                    ++n2.rowAffected, r4.continue();
                  }, a2.onerror = u2;
                } catch (e5) {
                  u2(e5);
                }
              else
                r4.continue();
            } else
              e4();
          }, i2.onerror = u2;
        });
        var t3;
      }));
    };
    var Ge2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), Fe2 = function() {
      return Fe2 = Object.assign || function(e2) {
        for (var t2, n2 = 1, r3 = arguments.length; n2 < r3; n2++)
          for (var o2 in t2 = arguments[n2])
            Object.prototype.hasOwnProperty.call(t2, o2) && (e2[o2] = t2[o2]);
        return e2;
      }, Fe2.apply(this, arguments);
    }, Je2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.query = t3, r3.util = n2, r3;
      }
      return Ge2(t2, e2), t2.prototype.execute = function() {
        var e3, t3, n2 = this, r3 = this.query, o2 = 0, u2 = {}, i2 = {}, a2 = true, c3 = r3.queries, s2 = c3.length;
        if (c3.every(function(e4, t4) {
          return !(t4 + 1 < s2 && e4.from !== c3[t4 + 1].from && (a2 = false, 1));
        }), a2) {
          var l3 = this.primaryKey(c3[0].from);
          e3 = function(e4) {
            return e4[l3];
          };
        } else
          e3 = function(e4) {
            var t4 = "";
            for (var n3 in e4)
              t4 += e4[n3];
            return t4;
          };
        var f2 = function() {
          if (o2 < s2)
            return (t3 = new Ne2(c3[o2], n2.util)).execute().then(function(t4) {
              return u2 = {}, t4.forEach(function(t5) {
                var n3 = e3(t5);
                0 === o2 ? i2[n3] = t5 : null != i2[n3] && (u2[n3] = t5);
              }), o2 > 0 && (i2 = Fe2({}, u2)), ++o2, f2();
            });
          var a3, l4 = [], h3 = void 0, p3 = r3.skip, y2 = r3.limit, d2 = false, v2 = function() {
            l4.push(u2[a3]);
          }, m2 = function() {
            l4.length < y2 ? v2() : d2 = true;
          }, b2 = function(e4) {
            0 === p3 ? e4() : --p3;
          };
          if (h3 = r3.skip && r3.limit ? function() {
            b2(function() {
              m2();
            });
          } : r3.limit ? m2 : r3.skip ? function() {
            b2(function() {
              v2();
            });
          } : function() {
            v2();
          }, y2) {
            for (a3 in u2)
              if (h3(a3), d2)
                break;
          } else
            for (a3 in u2)
              h3(a3);
          return t3.results = l4, Object.assign(t3.query, { order: r3.order, join: {} }), t3.processOrderBy(), t3.processGroupDistinctAggr(), t3.results;
        };
        return f2();
      }, t2;
    }(V2), Ue2 = function() {
      function e2() {
      }
      return e2.prototype.execute = function(e3) {
        return f(function(t2, n2) {
          var r3 = indexedDB.deleteDatabase(e3);
          r3.onblocked = function() {
            var e4 = new R(w);
            return n2(D2(e4));
          }, r3.onerror = function(e4) {
            return n2(D2(e4));
          }, r3.onsuccess = function() {
            t2();
          };
        });
      }, e2;
    }(), He2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), ze2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.query = t3, r3.util = n2, r3;
      }
      return He2(t2, e2), t2.prototype.execute = function() {
        var e3, t3 = this, n2 = this.query, r3 = 0, o2 = /* @__PURE__ */ new Map(), u2 = true, i2 = n2.length;
        if (n2.every(function(e4, t4) {
          return !(t4 + 1 < i2 && e4.from !== n2[t4 + 1].from && (u2 = false, 1));
        }), u2) {
          var a2 = this.primaryKey(n2[0].from);
          e3 = function(e4) {
            return e4[a2];
          };
        } else
          e3 = function(e4) {
            var t4 = "";
            for (var n3 in e4)
              t4 += e4[n3];
            return t4;
          };
        var c3 = function() {
          return r3 < n2.length ? new Ne2(n2[r3++], t3.util).execute().then(function(t4) {
            return t4.forEach(function(t5) {
              o2.set(e3(t5), t5);
            }), c3();
          }) : Array.from(o2.values());
        };
        return c3();
      }, t2;
    }(V2), $e2 = function(e2) {
      var t2 = this;
      return function(n2) {
        var r3 = n2.target.result;
        r3 ? (t2.shouldAddValue(r3.value) && (r3.delete(), ++t2.rowAffected), r3.continue()) : e2();
      };
    }, Xe2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), Ye2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.query = t3, r3.util = n2, r3.tableName = t3.from, r3;
      }
      return Xe2(t2, e2), t2.prototype.execute = function(e3) {
        var t3, n2 = this, r3 = new K2(this.db), u2 = this.query, i2 = r3.validate(o.Remove, u2);
        return i2 ? N2(i2) : e3().then(function(e4) {
          try {
            n2.initTransaction_(), t3 = null != u2.where ? H(u2.where) ? n2.processWhereArrayQry() : n2.processWhere_() : n2.executeWhereUndefinedLogic();
          } catch (e5) {
            return n2.onException(e5);
          }
          return t3.then(function() {
            return n2.rowAffected;
          });
        });
      }, t2.prototype.processWhereArrayQry = function() {
        var e3 = this, t3 = new Ne2(this.query, this.util);
        return t3.isTxQuery = this.isTxQuery, t3.execute().then(function(t4) {
          var n2, r3, o2 = [], u2 = e3.primaryKey(e3.query.from);
          t4.forEach(function(e4) {
            o2.push(e4[u2]);
          }), t4 = null;
          var a2 = ((n2 = {})[u2] = ((r3 = {})[i.In] = o2, r3), n2);
          return e3.query[i.Where] = a2, e3.processWhere_();
        });
      }, t2.prototype.processWhere_ = function() {
        var e3 = this;
        return this.shouldAddValue = function(t3) {
          return e3.whereChecker.check(t3);
        }, this.query.where.or && this.processOrLogic(), this.goToWhereLogic().then(function() {
          return e3.onWhereEvaluated();
        });
      }, t2.prototype.initTransaction_ = function() {
        this.isTxQuery || this.util.createTransaction([this.query.from]), this.objectStore = this.util.objectStore(this.query.from);
      }, t2.prototype.onWhereEvaluated = function() {
        if (this.isOr)
          return this.orQuerySuccess_();
      }, t2.prototype.orQuerySuccess_ = function() {
        var e3 = this, t3 = this._orInfo.OrQuery, n2 = X2(t3);
        if (null != n2) {
          var r3 = {};
          return r3[n2] = t3[n2], delete t3[n2], this.query.where = r3, this.goToWhereLogic().then(function() {
            return e3.onWhereEvaluated();
          });
        }
        this.isOr = true;
      }, t2.prototype.processOrLogic = function() {
        this.isOr = true;
        var e3 = this.query.where;
        this._orInfo = { OrQuery: e3.or }, delete e3.or;
      }, t2;
    }(Oe2);
    Ye2.prototype.executeInLogic = function(e2, t2) {
      var n2 = this, r3 = this.objectStore.index(e2);
      return L2(t2.map(function(e3) {
        return t3 = e3, f(function(e4, o2) {
          var u2 = r3.openCursor(n2.util.keyRange(t3));
          u2.onsuccess = $e2.call(n2, e4), u2.onerror = o2;
        });
        var t3;
      }));
    }, Ye2.prototype.executeWhereUndefinedLogic = function() {
      var e2, t2 = this, n2 = this.objectStore.openCursor();
      return f(function(r3, o2) {
        n2.onsuccess = function(n3) {
          (e2 = n3.target.result) ? (e2.delete(), ++t2.rowAffected, e2.continue()) : r3();
        }, n2.onerror = o2;
      });
    }, Ye2.prototype.executeWhereLogic = function(e2, t2, n2) {
      var r3 = this;
      t2 = n2 ? t2[n2] : t2;
      var o2 = this.objectStore.index(e2).openCursor(this.util.keyRange(t2, n2));
      return f(function(e3, t3) {
        o2.onsuccess = $e2.call(r3, e3), o2.onerror = t3;
      });
    }, Ye2.prototype.executeRegexLogic = function(e2, t2) {
      var n2, r3 = this, o2 = this.objectStore.index(e2).openCursor();
      return this.shouldAddValue = function(e3) {
        return t2.test(e3.key) && r3.whereChecker.check(e3.value);
      }, f(function(e3, t3) {
        o2.onsuccess = function(t4) {
          (n2 = t4.target.result) ? (r3.shouldAddValue(n2) && (n2.delete(), ++r3.rowAffected), n2.continue()) : e3();
        }, o2.onerror = t3;
      });
    };
    var Ze2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), et2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.query = t3, r3.util = n2, r3.tableName = t3, r3;
      }
      return Ze2(t2, e2), t2.prototype.execute = function(e3) {
        var t3 = this, n2 = this.query;
        return this.isTxQuery || this.util.createTransaction([n2, A2.tableName]), e3().then(function(e4) {
          var r3 = t3.util.objectStore(n2).clear();
          try {
            return f(function(e5, o2) {
              r3.onsuccess = function(r4) {
                var u2 = t3.table(n2);
                for (var i2 in u2.autoIncColumnValue)
                  u2.autoIncColumnValue[i2] = 0;
                A2.set(A2.dbSchema, t3.util.db, t3.util).then(e5).catch(o2);
              }, r3.onerror = o2;
            });
          } catch (e5) {
            return t3.onException(e5);
          }
        });
      }, t2;
    }(V2), tt2 = function() {
      var e2 = function(t2, n2) {
        return e2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e3, t3) {
          e3.__proto__ = t3;
        } || function(e3, t3) {
          for (var n3 in t3)
            Object.prototype.hasOwnProperty.call(t3, n3) && (e3[n3] = t3[n3]);
        }, e2(t2, n2);
      };
      return function(t2, n2) {
        if ("function" != typeof n2 && null !== n2)
          throw new TypeError("Class extends value " + String(n2) + " is not a constructor or null");
        function r3() {
          this.constructor = t2;
        }
        e2(t2, n2), t2.prototype = null === n2 ? Object.create(n2) : (r3.prototype = n2.prototype, new r3());
      };
    }(), nt2 = function(e2) {
      function t2(t3, n2) {
        var r3 = e2.call(this) || this;
        return r3.results = {}, r3.reqQueue = [], r3.isQueryExecuting = false, r3.isTxStarted_ = false, r3.query = t3, r3.util = n2, r3;
      }
      return tt2(t2, e2), t2.prototype.execute = function(e3) {
        var t3 = this;
        this.beforeExecute = e3;
        var n2 = this.validate();
        return n2 ? N2(n2) : (this.startExecution_(), f(function(e4, n3) {
          t3.onSuccess = e4, t3.onError = n3;
        }).then(function(e4) {
          return t3.beforeExecute = null, t3.log("transaction finished"), e4;
        }));
      }, t2.prototype.validate = function() {
        var e3 = this.query, t3 = this.notExistingTable_(e3.tables);
        if (t3)
          return new R(g2, { tableName: t3 });
        var n2 = e3.method;
        return Be2(n2) ? void 0 : new R(E, n2);
      }, t2.prototype.startExecution_ = function() {
        var e3 = this, t3 = this.query, n2 = function(t4) {
          return function(n3) {
            return e3.pushReq_({ name: t4, query: n3 });
          };
        }, r3 = t3.method, u2 = Be2(r3);
        return this.log("transaction query started"), u2.call(this, { data: t3.data, insert: n2(o.Insert), select: n2(o.Select), update: n2(o.Update), remove: n2(o.Remove), count: n2(o.Count), setResult: function(t4, n3) {
          e3.results[t4] = n3;
        }, getResult: function(t4) {
          return e3.results[t4];
        }, abort: function(t4) {
          e3.abortTx_(t4);
        }, start: function() {
          e3.startTx_();
        } });
      }, t2.prototype.log = function(e3) {
        this.util.logger.log(e3);
      }, t2.prototype.startTx_ = function() {
        var e3 = this;
        try {
          this.isTxStarted_ = true;
          var t3 = this.query.tables;
          return t3 = t3.concat(A2.tableName), this.util.createTransaction(t3).then(function(t4) {
            e3.onSuccess(e3.results);
          }).catch(function(t4) {
            e3.onError(t4);
          }), this.processExecutionOfQry_();
        } catch (e4) {
          this.onError(this.onException(e4));
        }
      }, t2.prototype.onReqFinished_ = function(e3) {
        var t3 = this.reqQueue.shift();
        this.log("finished request : ".concat(t3.name, " ")), t3 && (e3.error ? (this.abortTx_("automatic abort of transaction due to error occured"), this.log("transaction aborted due to error occured"), this.onError(e3.error)) : (this.isQueryExecuting = false, t3.onSuccess && t3.onSuccess(e3), this.processExecutionOfQry_()));
      }, t2.prototype.abortTx_ = function(e3) {
        this.reqQueue = [], this.util.abortTransaction(), this.log("transaction aborted. Msg : ".concat(e3));
      }, t2.prototype.executeRequest_ = function(e3) {
        var t3, n2 = this;
        this.isQueryExecuting = true, this.log("executing request : ".concat(e3.name, " "));
        var r3 = this.onReqFinished_.bind(this), u2 = e3.query, i2 = function(e4) {
          t3 = new e4(u2, n2.util);
        };
        switch (e3.name) {
          case o.Select:
            i2(Ne2);
            break;
          case o.Insert:
            i2(F);
            break;
          case o.Update:
            i2(Ke2);
            break;
          case o.Remove:
            i2(Ye2);
            break;
          case o.Count:
            i2(We2);
        }
        t3.isTxQuery = true, t3.execute(this.beforeExecute).then(r3).catch(function(e4) {
          r3({ error: e4 });
        });
      }, t2.prototype.pushReq_ = function(e3) {
        var t3 = f(function(t4, n2) {
          e3.onSuccess = function(e4) {
            t4(e4);
          }, e3.onError = function(e4) {
            n2(e4);
          };
        });
        return this.reqQueue.push(e3), true === this.isTxStarted_ && this.processExecutionOfQry_(), this.log("request pushed : ".concat(e3.name)), t3;
      }, t2.prototype.processExecutionOfQry_ = function() {
        false === this.isQueryExecuting && this.reqQueue.length > 0 && this.executeRequest_(this.reqQueue[0]);
      }, t2.prototype.notExistingTable_ = function(e3) {
        var t3 = this, n2 = null;
        return e3.every(function(e4) {
          return null != t3.table(e4) || (n2 = e4, false);
        }), n2;
      }, t2;
    }(V2), rt2 = function(e2) {
      if (null == e2)
        throw new Error("userDbSchema db is null");
      var t2 = { name: e2.name, version: e2.version, tables: [] };
      return e2.tables.forEach(function(e3) {
        var n2 = { name: e3.name, columns: {} };
        e3.columns.forEach(function(e4) {
          n2.columns[e4.name] = e4;
        }), t2.tables.push(n2);
      }), t2;
    }, ot2 = function() {
      function e2(e3) {
        this.middlewares = [], this.util = new Q2(), this.onQryFinished = J2 ? function(e4) {
          self.postMessage(e4);
        } : e3;
      }
      return Object.defineProperty(e2.prototype, "db", { get: function() {
        return this.util.db;
      }, enumerable: false, configurable: true }), Object.defineProperty(e2.prototype, "logger", { get: function() {
        return this.util.logger;
      }, enumerable: false, configurable: true }), e2.prototype.executeMiddleware_ = function(e3) {
        var t2 = this, n2 = $(this.middlewares) - 1;
        if (n2 < 0)
          return l2();
        var r3 = {}, o2 = this.db;
        return Object.defineProperty(r3, "database", { get: function() {
          return rt2(o2);
        } }), f(function(o3) {
          var u2 = 0, i2 = function() {
            if (u2 <= n2) {
              var a2 = Be2(t2.middlewares[u2++])(e3, r3);
              a2 && a2.then || (a2 = Promise.resolve(a2)), a2.then(function(e4) {
                i2();
              });
            } else
              o3();
          };
          i2();
        });
      }, e2.prototype.executeQuery = function(e3, t2) {
        var n2, r3 = e3.query, u2 = this, i2 = u2.util, a2 = function(e4, t3) {
          n2 = new e4(r3, i2).execute(t3);
        };
        switch (e3.name) {
          case o.OpenDb:
            t2(), n2 = u2.openDb(r3);
            break;
          case o.InitDb:
            t2(), n2 = u2.initDb(r3);
            break;
          case o.CloseDb:
            t2(), n2 = u2.closeDb();
            break;
          case o.Insert:
            a2(F, t2);
            break;
          case o.Select:
            a2(Ne2, t2);
            break;
          case o.Count:
            a2(We2, t2);
            break;
          case o.Update:
            a2(Ke2, t2);
            break;
          case o.Intersect:
            t2(), a2(Je2);
            break;
          case o.DropDb:
            t2(), n2 = u2.dropDb();
            break;
          case o.Terminate:
            t2(), n2 = u2.terminate();
            break;
          case o.Union:
            t2(), a2(ze2);
            break;
          case o.Remove:
            a2(Ye2, t2);
            break;
          case o.Clear:
            a2(et2, t2);
            break;
          case o.Transaction:
            a2(nt2, t2);
            break;
          case o.MapGet:
            t2(), n2 = A2.get(r3, i2);
            break;
          case o.MapSet:
            t2(), n2 = A2.set(r3.key, r3.value, i2);
            break;
          case o.MapHas:
            t2(), n2 = A2.has(r3, i2);
            break;
          case o.MapDelete:
            t2(), n2 = A2.remove(r3, i2);
            break;
          case o.ImportScripts:
            t2(), n2 = u2.importScripts_(e3);
            break;
          case o.ChangeLogStatus:
            t2(), u2.logger.status = r3, n2 = Promise.resolve();
            break;
          case o.Middleware:
            return t2(), Be2(r3) ? (u2.middlewares.push(r3), l2()) : N2(new R(O, r3));
          default:
            n2 = l2();
        }
        return u2.logger.log("Executing query ".concat(e3.name, " in web worker")), n2;
      }, e2.prototype.callMiddleware_ = function(e3, t2) {
        return f(function(n2) {
          var r3 = 0, o2 = $(e3) - 1, u2 = function() {
            if (r3 <= o2) {
              var i2 = e3[r3++](t2);
              i2 instanceof Promise || (i2 = l2(i2)), i2.then(function(e4) {
                t2 = e4, u2();
              });
            } else
              n2(t2);
          };
          u2();
        });
      }, e2.prototype.run = function(e3) {
        var t2 = this, n2 = [], r3 = [];
        e3.onResult = function(e4) {
          n2.push(function(t3) {
            return e4(t3);
          });
        }, e3.beforeExecute = function(e4) {
          r3.push(function(t3) {
            return e4(t3);
          });
        }, this.executeMiddleware_(e3).then(function(o2) {
          return t2.executeQuery(e3, function() {
            return t2.callMiddleware_(r3);
          }).then(function(e4) {
            return t2.callMiddleware_(n2, e4).then(function(e5) {
              t2.returnResult_({ result: e5 });
            });
          });
        }).catch(function(e4) {
          n2 = [];
          var r4 = { error: D2(e4) };
          t2.returnResult_(r4);
        });
      }, e2.prototype.importScripts_ = function(e3) {
        return f(function(t2, n2) {
          try {
            importScripts.apply(void 0, e3.query), t2();
          } catch (e4) {
            n2(new R(S, e4.message));
          }
        });
      }, e2.prototype.returnResult_ = function(e3) {
        this.logger.log("Query finished inside web worker"), this.util && this.util.emptyTx(), this.onQryFinished(e3);
      }, e2.prototype.dropDb = function() {
        var e3 = this.db.name;
        return this.terminate().then(function() {
          return new Ue2().execute(e3);
        });
      }, e2.prototype.closeDb = function() {
        return this.util.close();
      }, e2.prototype.terminate = function() {
        var e3 = this;
        return this.closeDb().then(function() {
          e3.util.db = null;
        });
      }, e2.prototype.openDb = function(e3) {
        var t2 = this;
        return this.closeDb().then(function(n2) {
          return (t2.db && e3.name === t2.db.name ? t2.initDb() : t2.initDb({ name: e3.name, tables: [], version: e3.version })).then(function() {
            return t2.db;
          });
        });
      }, e2.prototype.initDb = function(e3) {
        var t2 = this;
        if (!U2)
          return N2(new R(x2));
        var n2 = e3 ? new q(e3) : this.db;
        if (null == n2)
          throw new Error("dbMeta is null");
        return this.util = new Q2(), this.util.initDb(n2).then(function(e4) {
          return A2.get(A2.dbSchema, t2.util).then(function(r3) {
            return e4.isCreated ? (r3 && r3.tables.forEach(function(e5) {
              var t3 = n2.tables.find(function(t4) {
                return t4.name === e5.name;
              });
              if (t3)
                for (var r4 in e5.autoIncColumnValue) {
                  var o2 = e5.autoIncColumnValue[r4];
                  o2 && (t3.autoIncColumnValue[r4] = o2);
                }
            }), t2.util.db = n2, e4.database = rt2(t2.db), A2.set(A2.dbSchema, n2, t2.util).then(function() {
              return e4;
            })) : A2.get(A2.dbSchema, t2.util).then(function(n3) {
              return t2.util.db = n3, e4.database = rt2(t2.db), e4;
            });
          });
        });
      }, e2;
    }();
    if (J2) {
      var ut2 = new ot2();
      self.onmessage = function(e2) {
        ut2.run(e2.data);
      };
    }
    jsstore_worker_commonjs2_min.exports = t;
  })();
  return jsstore_worker_commonjs2_min.exports;
}
var worker_injector = { setup(r2, e) {
  r2.$worker = requireJsstore_worker_commonjs2_min(), r2.initQueryManager_();
} };
const workerInjector = /* @__PURE__ */ getDefaultExportFromCjs(worker_injector);
const DB_NAME = "english";
const TABLE_NAMES = {
  WORD: "word",
  SET: "set",
  SETS: "sets",
  TEST_TYPE: "test-type"
};
function initJSStoreDB() {
  const word = {
    name: TABLE_NAMES.WORD,
    columns: {
      id: { primaryKey: true, autoIncrement: true },
      word: { notNull: true, dataType: "string" },
      translation: { notNull: true, dataType: "string" },
      transcription: { dataType: "string" },
      description: { dataType: "string" }
    }
  };
  const set2 = {
    name: TABLE_NAMES.SET,
    columns: {
      id: { primaryKey: true, autoIncrement: true },
      name: { notNull: true, dataType: "string" },
      type_ids: { dataType: "array" }
    }
  };
  const sets = {
    name: TABLE_NAMES.SETS,
    columns: {
      id: { primaryKey: true, autoIncrement: true },
      set_id: { dataType: "number", notNull: true },
      word_id: { dataType: "number", notNull: true }
    }
  };
  const database = {
    name: DB_NAME,
    tables: [word, set2, sets],
    version: 1
  };
  return database;
}
class CommonJsStoreRepository {
  _dbContext;
  constructor(dbContext) {
    this._dbContext = dbContext;
  }
  async importData(data) {
    await this._dbContext.clear("word");
    await this._dbContext.clear("set");
    await this._dbContext.clear("sets");
    await this._dbContext.insert({
      into: "word",
      values: data.words,
      return: true
    });
    await this._dbContext.insert({
      into: "set",
      values: data.sets,
      return: true
    });
    await this._dbContext.insert({
      into: "sets",
      values: data.setsWithWords,
      return: true
    });
  }
}
const initialData = {
  sets: [
    { id: 20, name: "1 - Impression", type_ids: [4, 5, 7, 8, 1] },
    { id: 21, name: "2 - Impression and opinions", type_ids: [4, 5, 7, 8, 1] },
    { id: 22, name: "3 - Communication", type_ids: [1, 2, 4, 5, 7, 8] },
    { id: 23, name: "4 - Connection", type_ids: [1, 2, 4, 5, 7, 8] },
    { id: 24, name: "5 - Dreams come true", type_ids: [1, 2, 4, 5, 7, 8] },
    { id: 25, name: "6 - Reach for the sky", type_ids: [1, 2, 4, 5, 7, 8] },
    { id: 26, name: "7 - Life Circles", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 27, name: "8 - Life ups and downs", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 28, name: "9 - Amazing people", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 29, name: "10 - People are awesome", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 30, name: "11 - Forever Friends", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 31, name: "12 - Besties", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 32, name: "13 - Work", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 33, name: "14 - Things to be done", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 34, name: "15 - How ambitious you are", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 35, name: "16 - Are you ambitious?", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 36, name: "17 - Risk", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 37, name: "18 - Risk taking", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 38, name: "19 - Money and business", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 39, name: "20 - Get down to business", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 40, name: "21 - Behavior", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 41, name: "22 - Attitude", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 42, name: "23 - Health, Diet, Addictions", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 43, name: "24 - Let’s get fit", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 44, name: "25 - Tales", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 45, name: "26 - More tales", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 46, name: "27 - Troubles. Mishaps", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 47, name: "28 - Other accidents", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 48, name: "29 - Beauty", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
    { id: 49, name: "30 - Elegance", type_ids: [1, 2, 3, 4, 5, 6, 7, 8, 9] }
  ],
  words: [
    {
      word: "laid-back",
      transcription: "ˌleɪdˈbæk",
      translation: "спокійний",
      description: "EXAMPLE\nI've never seen her worried or anxious in any way - she's so laid-back.\n\nDEFINITION\nrelaxed in manner and character; not usually worried about other people's behavior or things that need to be done:\n\nSYNONYMS\ncalm, quiet, easygoing",
      id: 4
    },
    {
      word: "shake hands",
      transcription: "ʃeɪk hænd",
      translation: "обмінятися рукостисканням",
      description: "EXAMPLE\n\nA firm handshake is the basic greeting, and people shake hands again when they part.\n\nHe broke off in mid-sentence to shake hands with the new arrivals.\n\nHe had scarcely shaken our hands when the phone rang.\n\nDEFINITION\n\nClasp someone's right hand in one's own at meeting.",
      id: 5
    },
    {
      word: "flattering",
      transcription: "ˈflætərɪŋ",
      translation: "улесливий",
      description: "EXAMPLE\n\nCara found this more flattering than any compliment.\n\na flattering color\n\nA great suit is the result of a flattering cut, good tailoring, and fabric that is distinctive, comfortable, and has a good drape .\n\nDEFINITION\n\nfull of praise and compliments:",
      id: 6
    },
    {
      word: "reckless",
      transcription: "ˈrekləs",
      translation: "нерозсудливий",
      description: "EXAMPLE\nAll of them are presented as taking place in an environment of such reckless irresponsibility and callous disregard of the value of human life as to strain credulity.\na reckless driver\nbecame the fiercest and most reckless of partisans\n\nDEFINITION\nvery careless; acting or done without any thought of the consequences:\n\nSYNONYMS\ncareless, rash, precipitous",
      id: 7
    },
    {
      word: "cunning",
      transcription: "ˈkʌnɪŋ",
      translation: "хитрий",
      description: "EXAMPLE\n\nI'd stay away from that cunning chap..he's pretty weird.\n\nCun Cun is connecting the communities in Malaysia, gathering and reallocating the resources for a greater economic benefits for all.\n\nDEFINITION\n\nshrewdness as demonstrated by being skilled in deception:\n\nSYNONYMS\nsly, clever, tricky",
      id: 8
    },
    {
      word: "creepy-crawly",
      transcription: "ˌkriː.piˈkrɔː.li",
      translation: "моторошний",
      description: "EXAMPLE\n\nI love the creepy-crawly critters, the ones with the fangs and the stingers and the claws.\nWe're a 110-acre theme park with alligators, snakes, spiders, and creepy-crawly stuff.\nAnd of course, he should always be ready to get rid of any creepy-crawly insects or stinging/biting creatures that enter our house.\n\nDEFINITION\nFeeling or causing a sensation as of creatures crawling on one's skin.\n\nSYNONYMS\ncreepy",
      id: 9
    },
    {
      word: "floppy",
      transcription: "ˈflɒpi",
      translation: "висячий",
      description: "EXAMPLE\nThe very sad-looking pooch with one blue eye and one floppy ear on the story lead page is our beloved Luna.\nHe's got floppy blond hair that's always falling in his eyes.\nThere's a skinny, floppy-haired scamp on stage wearing a slightly silly outfit.\n\nDEFINITION\nsoft and not able to keep a firm shape or position:\n\nSYNONYMS\nsagging, slack, droopy",
      id: 10
    },
    {
      word: "outgoing",
      transcription: "ˌaʊtˈgəʊɪŋ",
      translation: "комунікабельний",
      description: "EXAMPLE\nShe has an outgoing personality.\nSales reps need to be outgoing, because they are constantly meeting customers.\nI like his sister - she's so outgoing.\n\nDEFINITION\nfriendly and socially confident:\n\nSYNONYMS\nsociable, open, communicative",
      id: 11
    },
    {
      word: "loner",
      transcription: "ˈləʊnər",
      translation: "одинак",
      description: "EXAMPLE\nHe was temperamental , a kind of simple man, withdrawn, a loner.\nHey look at her, she's such a loner! Happy loner!\nLoners just like to be by themselves. That's all there is to it.\n\nDEFINITION\na person who avoids the company or assistance of others\n\nSYNONYMS\none, lone wolf",
      id: 12
    },
    {
      word: "limp",
      transcription: "lɪmp",
      translation: "кульгати",
      description: "EXAMPLE\nWe cannot limp along with no policy, no one obeying the Deputy Prime Minister and a lack-lustre, do-nothing government with a lame-duck leader.\nThat movie was so limp, it didn't even make sense.\nJoe: Dude i cant make it to this crazy party tonight! Ryan: LIMP! It was going to be wazza!\n\nDEFINITION\nWalk with difficulty, typically because of a damaged or stiff leg or foot.\n\nSYNONYMS\nhobble, hitch, gimp",
      id: 13
    },
    {
      id: 14,
      word: "hectic",
      transcription: "ˈhektɪk",
      translation: "гарячковий",
      description: "EXAMPLE\nThe area has become a haven for people tired of the hectic pace of city life.\n\nDEFINITION\nfull of activity, or very busy and fast:\n\nSYNONYMS\nbusy, chaotic, fever"
    },
    {
      id: 15,
      word: "good-natured",
      transcription: "ˌgʊdˈneɪtʃəd",
      translation: "добродушний",
      description: "EXAMPLE\nHe couldn't sleep at night, only thinking of her slim and attractive figure with a good-natured mind.\nTheir relationship - and his recovery - has been punctuated by similar conversations, along with plenty of good-natured razzing .\nNemo is a little fish kid whose overprotective dad, Marlin, is perfectly voiced by Albert Brooks, that prince of good-natured anxiety.\n\nDEFINITION\nKind, friendly, and patient.\n\nSYNONYMS\ngenerous, considerate, friendly"
    },
    {
      id: 16,
      word: "fun-loving",
      transcription: "fʌn ˈlʌvɪŋ",
      translation: "любитель повеселитися",
      description: "EXAMPLE\nFun-loving, spirited, humorous and attracted to outdoor amour, be warned that these high energy, exuberant wooers set a strapping pace.\nAnd I will miss all of my pets - my two beloved, fun-loving dogs, my seven lively cats, my canaries , my horses, and even my chickens.\nWho grew up from being a carefree and fun-loving girl to be the matron of female infanticide.\n\nDEFINITION\nLight-hearted and lively."
    },
    {
      id: 17,
      word: "chatterbox",
      transcription: "ˈtʃætəbɒks",
      translation: "балакун",
      description: "EXAMPLE\nAdu this is Anu and she is the chatterbox I was telling you about earlier.\nBut Echo was a chatterbox and teller of tales, and many of her stories were lies about the other nymphs and the gods and goddesses.\nThe mother of two daughters and four sons, Mrs Scadden was a part-time cleaner ‘who was a bit of a chatterbox and a bubbly person’.\n\nDEFINITION\nA person who talks at length about trivial matters.\n\nSYNONYMS\nbabbler, chatterer, jay"
    },
    {
      id: 18,
      word: "burst out",
      transcription: "bɜːst aʊt",
      translation: "вибухнути",
      description: "EXAMPLE\nHe came around the car as she tried to cover herself with her sweater and then, as she looked imploringly into his eyes, he burst out laughing.\nThe girls burst out with genuine laughter at him, which only angered him even more.\nThe water skin filled, quickly, and out of the top a stream of water burst out.\n\nDEFINITION\nFeel a very strong or irrepressible emotion or impulse.\n\nSYNONYMS\nflare, pop out"
    },
    {
      id: 19,
      word: "fellow",
      transcription: "ˈfeləʊ",
      translation: "приятель",
      description: "EXAMPLE\none eye was blue but its fellow was brown\n1.if I'd known he was her boyfriend I wouldn't have asked 2.that chap is your host; there's a fellow at the door; he's a likable cuss 3.the surgeon consulted his colleagues; he sent e-mail to his fellow hackers 4.drinking companions; comrades in arms 5.Say, fellow, what are you doing?; Hey buster, what's up?\nActress: Romeo, where for art thou Romeo? Actor: ...fellow?\n\nDEFINITION\none of a pair\n\nSYNONYMS\nboy, mate, man"
    },
    {
      id: 20,
      word: "adore",
      transcription: "əˈdɔːr",
      translation: "обожнювати",
      description: "EXAMPLE\nYou know how I adore those empire bacon scones.\nWe do better to adore the mysteries of Deity than to investigate them.\nMost Hindus revere and adore the many manifestations of the Divine as Siva, Vishnu, Rama, Krishna or Durga even as they focus on an ishta devata, a favorite Deity.\n\nDEFINITION\nto love and respect someone deeply:\n\nSYNONYMS\nlove, like, cherish"
    },
    {
      id: 21,
      word: "frightened",
      transcription: "ˈfraɪtnd",
      translation: "напуганий",
      description: "EXAMPLE\nthe frightened child cowered in the corner\n'Yo bro dog, i busted out the frightener on a chick last night now she wont text me back\nthe savagery of his thoughts frightened him at his age, I guess he doesn't frighten any more\n\nDEFINITION\nmade afraid\n\nSYNONYMS\nterrified, scared, panicky"
    },
    {
      id: 22,
      word: "grain",
      transcription: "ɡreɪn",
      translation: "зерно",
      description: "EXAMPLE\nThe resale of grain to villages which claimed to be deficient in food supplies hampered the flow of grain to the cities.\nuse wholegrain breakfast cereals wherever possible\nPigs' or boars' tusks are markedly curved but small in cross-section and with no visible grain.\n\nDEFINITION\nthe physical composition of something (especially with respect to the size and shape of the small constituents of a substance)\n\nSYNONYMS\nseed, cereal, texture"
    },
    {
      id: 23,
      word: "dormitory",
      transcription: "ˈdɔːrmətɔːri",
      translation: "студентський гуртожиток",
      description: "EXAMPLE\nOvernight guests are not allowed in the dormitory.\nGuests at the camp can stay in private cabins or for a smaller fee in the dormitories.\n\nDEFINITION\na large room containing many beds, for example in a boarding school:\n\nSYNONYMS\nhall, dorm, dorm room"
    },
    {
      id: 24,
      word: "anxious",
      transcription: "ˈæŋkʃəs",
      translation: "тривожний",
      description: "EXAMPLE\nMy mother always gets a bit anxious if we don't arrive when we say we will.\nI saw my sister's anxious face at the window.\nThe drought has made farmers anxious about the harvest.\n\nDEFINITION\nworried and nervous:\n\nSYNONYMS\nfearful, nervous, worried"
    },
    {
      id: 25,
      word: "saucer",
      transcription: "ˈsɔːsər",
      translation: "блюдце",
      description: "EXAMPLE\nTricia opened the fridge and pulled out a carton of milk, then pulled a saucer out of a cabinet.\nCup and saucer! That Saucer; I'll get him one day!\nHe's my saucer right now, but we may become more than that later in our relationship.\n\nDEFINITION\na shallow dish; a round spacecraft that some people claim to have seen and that some people believe comes from another planet:\n\nSYNONYMS\ndish, discus, disk"
    },
    {
      id: 26,
      word: "tray",
      transcription: "treɪ",
      translation: "піднос",
      description: "EXAMPLE\nI mean, it's bad enough the media portrays that we should be blonde , blue-eyed and skinny.\nThey then tattoo the inside of the ear of animals that they spay and neuter so that they do not try to operate more than once on the same stray animal.\nThe media frenzy following her arrest portrayed an image of a person more beast than human.\n\nDEFINITION\nan open receptacle for holding or displaying or serving articles or food\n\nSYNONYMS\ndish, plate, platter"
    },
    {
      id: 27,
      word: "kettle",
      transcription: "ˈketl",
      translation: "чайник",
      description: "EXAMPLE\ni moved to him for his kettle.\nPolice officers illegally kettled peaceful climate activists at the G20 protests in 2009 to stop their gathering being hijacked by violent protesters from another demonstration, the high court has heard. --Guardian 23 March 2011\nAt the 24 November student demonstration in London, police were kettling students, some as young as 14, keeping them in the cold until midnight. Shame the American media didn't have time to cover it....\n\nDEFINITION\na large hemispherical brass or copper percussion instrument with a drumhead that can be tuned by adjusting the tension on it\n\nSYNONYMS\nboiler, kettledrum, timpani"
    },
    {
      id: 28,
      word: "plumber",
      transcription: "ˈplʌmə",
      translation: "сантехнік",
      description: "EXAMPLE\nThey call me the plumber, 'cause I'm always layin' the pipe.\nOh look the pipe burst we should call the plumber\nPlumber? I didn't call for a Plumber!\n\nDEFINITION\na craftsman who installs and repairs pipes and fixtures and appliances"
    },
    {
      id: 29,
      word: "handkerchief",
      transcription: "ˈhæŋkətʃiːf",
      translation: "носова хустинка",
      description: "EXAMPLE\nI blew my nose in a napkin and blew my nose again on his handkerchief .\nbro, do you want to come over and try out my new handkerchief?\nI didn't have a handkerchief but the farmers handkerchief is always available\n\nDEFINITION\nA square of cotton or other finely woven material intended for wiping one's nose.\n\nSYNONYMS\nkerchief, tissue, hanky"
    },
    {
      id: 30,
      word: "turn out",
      transcription: "tɜːrn aʊt",
      translation: "виявитися",
      description: "EXAMPLE\nThe suspicion that the bill is merely a ploy to divert public attention away from the fuel price hikes could turn out to be justifiable.\nHe encouraged everyone to put pressure on family , relatives and friends to turn out.\nAs I finish the inward sweep to my belly button , my hands turn out and push back.\n\nDEFINITION\nGo somewhere in order to do something, especially to attend a meeting, to play a game, or to vote.\n\nSYNONYMS\ncut, bear, output"
    },
    {
      id: 31,
      word: "necessary",
      transcription: "ˈnesəseri",
      translation: "необхідний",
      description: "EXAMPLE\nIf necessary, your child's doctor may prescribe medicines.\nPeople started to realize the basic game center could move to life support instead of death support and it was now necessary to work for only 6 hours per year instead of the current 2,000, to support war mongers.\nMike: Hey, how was the Red Sox- Angels game last night? John: The game was if necessaried; the Angels already swept. Mike: Ahh, that sucks.\n\nDEFINITION\nNeeded to be done or present\n\nSYNONYMS\nrequirement, essential, necessity"
    },
    {
      id: 32,
      word: "appropriate",
      transcription: "əˈprəʊpriət",
      translation: "відповідний",
      description: "EXAMPLE\nThey feel they have to make some worthy comment, treat the city with some kind of moral scrupulousness and say something appropriate.\nThat movie better be appropriate for Sarah to watch.\nhow appropriate is that swim suit?\n\nDEFINITION\nSuitable or proper.\n\nSYNONYMS\nallow, fit, reserve"
    },
    {
      id: 33,
      word: "heaven",
      transcription: "ˈhevn",
      translation: "небеса",
      description: "EXAMPLE\nThe capricious god changed Ariadne into the Corona Cressa, or Cretan Diadem, already visible in the heavens in Titian's Bacchus and Ariadne as an omen at their first meeting.\nButler's cafe has raised the coffee bar to super-latte levels, and the chocolate truffles are worthy of a place in bonbon heaven.\nIf we cannot find peace in the heavens, what hope on the ground?\n\nDEFINITION\nany place of complete bliss and delight and peace\n\nSYNONYMS\nparadise, eden, nirvana"
    },
    {
      id: 34,
      word: "victim",
      transcription: "ˈvɪktɪm",
      translation: "жертва",
      description: "EXAMPLE\nThe new drug might help save the lives of cancer victims.\nNo one should be a victim of anyone's abuse.\n\nDEFINITION\na harmed person:\n\nSYNONYMS\ncasualty, fatality, object"
    },
    {
      id: 35,
      word: "disadvantage",
      transcription: "ˌdɪsədˈvɑːntɪdʒ",
      translation: "нестача",
      description: "EXAMPLE\nthis change will disadvantage men\nHowever persistent snow cover might be disadvantageous.\nThe disability facilitated romantic disadvantage effect is an issue where people with disabilities have a harder time getting into and maintaining romantic relationships compared to the average person. The best way to correct this problem is to remind people of all the things these people are capable of doing just as well as the average person. It is very unfortunate this issue is still very prevalent.\n\nDEFINITION\nAn unfavourable circumstance or condition.\n\nSYNONYMS\ncatch, obstacle, drawback"
    },
    {
      id: 36,
      word: "sudden",
      transcription: "ˈsʌdən",
      translation: "раптово",
      description: "EXAMPLE\nThe man is not unpleasant but when he speaks, his words cut deep into her and she sees him as suddenly ugly.\nAll the sudden, the red alert sounded and all the girls stopped playing cards in response.\nHolly suddenly moved her head, and a few strands of her black hair fell across her face.\n\nDEFINITION\nhappening without warning or in a short space of time\n\nSYNONYMS\nsurprise"
    },
    {
      id: 37,
      word: "saw",
      transcription: "sɔː",
      translation: "пила",
      description: "EXAMPLE\nThey ran on stage, as you saw, tried to pelt her with pies, but, boy , she was fast.\nNow, the lions are a social cat , unlike that tiger that you saw in Columbus.\nHer smile faded slowly as she saw her father's face turn serious.\n\nDEFINITION\na power tool for cutting wood\n\nSYNONYMS\naxiom, maxim, proverb"
    },
    {
      id: 38,
      word: "mess up",
      transcription: "mes ʌp",
      translation: "зіпсувати",
      description: "EXAMPLE\nWe all curse the patent office for granting patents on things which we find obvious, but they don't always mess up.\nHe was, without a doubt, the devil's evil spawn , sent down to earth to mess up the lives of innocent and simple girls.\nThen he got a dustpan and brush, and swept the whole mess up.\n\nDEFINITION\nmishandle a situation:\n\nSYNONYMS\nmess, blow, screw up"
    },
    {
      id: 39,
      word: "rye",
      transcription: "raɪ",
      translation: "жито",
      description: "EXAMPLE\nI went out with this guy from Rye who was totally prepped in is going to yale Lets go to coldstone in Rye and then pick up some Juicy Jeans at Ragz\nHave you ever wondered as to the whereabouts of the mate to those odd socks you find in the dryer or your sock drawer?\nThe study is researching the practice of planting soybeans into cover crops of winter rye.\n\nDEFINITION\nhardy annual cereal grass widely cultivated in northern Europe where its grain is the chief ingredient of black bread and in North America for forage and soil improvement"
    },
    {
      id: 40,
      word: "neither",
      transcription: "ˈnaɪðər",
      translation: "ніякий",
      description: "EXAMPLE\nNeither side had won a game this season, but fortune smiled on SCU Yellow, who now climb off the bottom of the ladder and move clear of the unlucky Eagles.\nThe director is tall and thin with good posture, and he appears neither old nor young.\nHe steps forward and touches my cheek , his hand neither warm nor cold against my skin."
    },
    {
      id: 41,
      word: "affair",
      transcription: "əˈfeər",
      translation: "справа",
      description: "EXAMPLE\nHe was uncovered after his employers fingered him to police over the affair.\nIt is as if we, temperamental and capricious , have been having a stormy affair with aloof, indifferent El Niño.\nThe true gods are fickle and capricious and care little for the affairs of men, but the piper was different.\n\nSYNONYMS\ndeal, point, matter"
    },
    {
      id: 42,
      word: "pace",
      transcription: "peɪs",
      translation: "темп",
      description: "EXAMPLE\n-*walks into a room Pace. -Bye. Love you. - Love you. Pace.\nIo voglio pace=i want peace\n\nDEFINITION\na unit of length equal to 3 feet; defined as 91.44 centimeters; originally taken to be the average length of a stride\n\nSYNONYMS\nMarch, walk, rate"
    },
    {
      id: 43,
      word: "deliberately",
      transcription: "dɪˈlɪbərətli",
      translation: "свідомо",
      description: "EXAMPLE\nshe was working deliberately\nI deliberately didn't do my homework.\nThe American legislature is supposed to have a deliberative process whereby law-making is slow because of the time it takes to determine the best policy and build a consensus in its favor. For Your Deliberation - phrase used by TheDelibero.com when referring to a fact or opinion that merits discussion\n\nDEFINITION\nin a deliberate unhurried manner\n\nSYNONYMS\nslow, slowly, intentionally"
    },
    {
      id: 44,
      word: "inquiry",
      transcription: "ɪnˈkwaɪəri",
      translation: "запит",
      description: "EXAMPLE\nI hope you will stick with this inquiry and expose their disgusting operations.\nIt may yet take a national inquiry to establish the full extent of this disgusting phenomenon.\nsome geographers perceive hydrology to be a separate field of scientific inquiry\n\nDEFINITION\na systematic investigation of a matter of public interest\n\nSYNONYMS\nmarket, research, question"
    },
    {
      id: 45,
      word: "imaginative",
      transcription: "ɪˈmædʒɪnətɪv",
      translation: "творчий",
      description: "EXAMPLE\nScott's really imaginative and creative and has a definite vision of what he wants his business to be.\nHis imaginative writing is spell-binding.\nI am clever, sensitive and imaginative.\n\nDEFINITION\nHaving or showing creativity or inventiveness.\n\nSYNONYMS\ninventive, picturesque"
    },
    {
      id: 46,
      word: "butler",
      transcription: "ˈbʌtlər",
      translation: "дворецький",
      description: "EXAMPLE\nMatt: I was 50p short for a drink, and Steve wouldn't give it to me Phil: What a butler\nI haven't seen much of Paul since he became Andrew's butler!\nBartender: What can I get for you? Customer: Yes, I'll take a Butler on the rocks.\n\nDEFINITION\na manservant (usually the head servant of a household) who has charge of wines and the table"
    },
    {
      id: 47,
      word: "held",
      transcription: "held",
      translation: "позичати",
      description: "EXAMPLE\nSeveral huge branches were quite literally held in place by lengths of rope.\nIn addition, they should continue calls for a political settlement that reflects the results of the free and fair elections held in 1990.\nThe film is really just a series of slickly filmed action sequences dangling off a thin plot and held together by the force of Jackson's charisma.\n\nSYNONYMS\ntake, hold, rest"
    },
    {
      id: 48,
      word: "deceased",
      transcription: "dɪˈsiːst",
      translation: "померлий",
      description: "EXAMPLE\nShe says they are sending her a letter of authority to enable her to accompany the deceased back to China.\nshe talked about her recently deceased husband\nNeoreligious communities have emerged in which people are guided to the other side to communicate with deceased family members and kin .\n\nSYNONYMS\nlate, later, gone"
    },
    {
      id: 49,
      word: "urgently",
      transcription: "ˈɜːdʒəntli",
      translation: "терміново",
      description: "EXAMPLE\nVolunteers are urgently needed to help plant daffodils and tulips bulbs.\nBoy is called urgently to obscure Greek Island, where it seems girl has disappeared forever into the realm of dreams.\nI dashed into a shop and told the shopkeeper that I had to use his phone urgently.\n\nSYNONYMS\nquickly, desperately"
    },
    {
      id: 50,
      word: "autopsy",
      transcription: "ˈɔːtɒpsi",
      translation: "розтин трупа",
      description: "EXAMPLE\n1. To perform an autopsy. 2. The autopsy revealed that the individual had drowned.\nBeing an embalmer might suck sometimes when you receive a body that is a post-autopsy case. You have to clean up the mess, and man does it stink. Literally.\nGuy 1. Hey fall out boy is cool Guy 2. NO way Autopsy would kill them\n\nDEFINITION\nan examination and dissection of a dead body to determine cause of death or the changes produced by disease\n\nSYNONYMS\nremoval, post-mortem, pm"
    },
    {
      id: 51,
      word: "nearby",
      transcription: "ˌnɪəˈbaɪ",
      translation: "сусідній",
      description: "EXAMPLE\nThere are regular scheduled flights to the island by light aircraft, from Dar es Salaam or the nearby Selous.\nWith no tall buildings nearby to obstruct your sight, you can see for miles around.\nthe nearby towns\n\nDEFINITION\nclose at hand\n\nSYNONYMS\naround, near, next"
    },
    {
      id: 52,
      word: "poured",
      transcription: "pɔːr",
      translation: "виливати",
      description: "EXAMPLE\nhe poured out his heart to me\nIt is very unlikely that the medication can be poured into the container on the sterile field without touching the lip of the container.\nThese have poured in from Vietnam, where cooperative farming produces much cheaper rice.\n\nDEFINITION\nWhen you accidentally send a snapchat and instantly forget what it said or what it means.\n\nSYNONYMS\nflow, stream, run"
    },
    {
      id: 53,
      word: "glamorous",
      transcription: "ˈglæmərəs",
      translation: "чарівний",
      description: "EXAMPLE\nOnce she arrives she will be given a glamorous wardrobe packed with designer gowns, swimwear and suits.\nThe TV work isn't as glamorous as it sounds, he warns, citing early starts, long days and only a basic daily pay rate of around £70.\nPerhaps this is a subtle statement on the unglamorous reality of commercialised sex, but the witty script resists such neat categorisations.\n\nDEFINITION\nattractive in an exciting and special way:\n\nSYNONYMS\ncharming, lovely, glamourous"
    },
    {
      id: 54,
      word: "captivated",
      transcription: "ˈkæptɪveɪt",
      translation: "зачаровувати",
      description: "EXAMPLE\nThe sentimental and emotional atmosphere captivated them and induced them to seek in death an ideal dream world, transcending reality.\nThe larger goal is to encourage a strategy for thinking broadly about contentious issues so that the church maintains its intellectual and theological integrity and is not simply captivated by insistent or importunate voices.\nI'm under the captivity of negativity If you ever touch her you'll be under my captivity of negativity.\n\nSYNONYMS\nenthralled, delighted, attract"
    },
    {
      id: 55,
      word: "inquiries",
      transcription: "ɪnˈkwaɪəri",
      translation: "розпитування",
      description: "EXAMPLE\nHowever, my frantic eye-fluttering demonstrations merely provoked inquiries after my contact lenses rather than the swoons of desire I had anticipated.\nWe both welcome and encourage inquiries from people who would like to either use our services or find out more about volunteering for them.\nUpon further inquiries, I was told that humanities combines the study of geography and history .\n\nDEFINITION\nAsking a question yo.\n\nSYNONYMS\nresearch, review, question"
    },
    {
      id: 56,
      word: "tearfully",
      transcription: "ˈtɪəfəli",
      translation: "слезно",
      description: "EXAMPLE\nI knew when I got home I'd find her, my faithful wife, tearfully afraid I would not return, waiting for me.\nThe son pleads guilty, tearfully begging for leniency based on his claim that his father molested him."
    },
    {
      id: 57,
      word: "remarks",
      transcription: "rɪˈmɑːk",
      translation: "зауваження",
      description: "EXAMPLE\nA Schrute remark: Jim Halpert looks out window Hey look everyone, It's snowing. Dwight Schrute pretend cute-kid voice Omigod! It's the first snowfall of Christmas. Is that just so magical for you, little girl? Can you not wait to have a hot chocolate and cuddle up with papa and tell him all of your Christmas dreams? Hmm? turns serious It's not even real snow. Look, it's a dusting. Pitiful.\nSince then, some critics have objected to the editors' contentious remarks and their narrow definition of Asian American literature.\n\nSYNONYMS\nobservation, input, annotation"
    },
    {
      id: 58,
      word: "love-struck",
      transcription: "lʌv",
      translation: "По вуха закоханий",
      description: "EXAMPLE\nA LOVE-STRUCK granny may have to wait a year to learn if she can bring her young Moroccan husband into the UK.\nShe walked into the room and he was love struck and smitten; barely able to talk he spilled his drink\n\nDEFINITION\nA real life disease. Symptoms Include: When a girl you are head-over-heels for makes your heart beat super fast"
    },
    {
      id: 59,
      word: "yew",
      transcription: "ju:",
      translation: "тис",
      description: "EXAMPLE\nThe June meeting will be a visit to Conderton Pottery followed by a meal at the Yew Tree Inn.\nEyewitness testimony in court cases - even from witnesses who are absolutely positive about what they saw - should be taken with a grain of salt.\nChristopher knows his trade and selects his wood from birch , oak or yew.\n\nDEFINITION\nany of numerous evergreen trees or shrubs having red cup-shaped berries and flattened needlelike leaves"
    },
    {
      id: 60,
      word: "plain",
      transcription: "pleɪn",
      translation: "простий",
      description: "EXAMPLE\n\nIn short, it is a travesty of not only scholarship, but plain common sense.\n\nInside a pizzeria: Vinny: next? Customer: I'll have two plain and a Diet Coke.\n\nthat girl is pretty!guy 1 nooo! she is sucha plain jane guy 2 well what girl is pretty to youu, around here? guy 1 that one shes diffrent, see those clothes look vinatge-y. and she has a diffrent interesting nose! pretty! guy 2 yeah i guess your right, who wants a plain girl? guy 1\n\nDEFINITION\n\nHaving no pretensions; not remarkable or special.\n\nSYNONYMS\n\napparently, field, obviously"
    },
    {
      id: 61,
      word: "classy",
      transcription: "ˈklɑːsi",
      translation: "шикарний",
      description: "EXAMPLE\n\nThat stimulates other departments to think that they, too, can be classy.\n\nDEFINITION\n\nstylish or fashionable:\n\nSYNONYMS\n\nclass, swish, posh"
    },
    {
      id: 62,
      word: "well-dressed",
      transcription: "ˌwelˈdrest",
      translation: "добре одягнений",
      description: "EXAMPLE\n\nMany of these young tigers are well-dressed and oblivious, yapping away into their mobile phones.\n\nWell-dressed families, couples and young artsy types mill about sampling foods like saj, a traditional Lebanese flatbread usually smeared with thyme and olive oil and baked on a rounded open grill.\n\nEvery well-dressed man should have some stylish knitwear in his wardrobe.\n\nDEFINITION\n\nSomeone who is well-dressed is wearing smart or elegant clothes.\n\nSYNONYMS\n\nsmart, elegant, well-groomed"
    },
    {
      id: 63,
      word: "hostile",
      transcription: "hɒstʌɪl",
      translation: "ворожий",
      description: "EXAMPLE\n\nThe situation soon turned violent, and cadets were forced to confront the hostile crowd.\n\nDEFINITION\n\nshowing or feeling opposition or dislike; unfriendly:\n\nSYNONYMS\n\nenemy, unfriendly, inimical"
    },
    {
      id: 64,
      word: "insecure",
      transcription: "ˌɪnsɪˈkjʊər",
      translation: "невпевнений",
      description: "EXAMPLE\n\nIn effect she is punishing her parents for making her feel threatened and insecure.\n\nan insecure future\n\nI always tell her how beautiful she is but she won't believe me, she's so insecure.\n\nDEFINITION\n\nIf you are insecure, you lack confidence because you think that you are not good enough or are not loved.\n\nSYNONYMS\n\nunreliable, unstable, dangerous"
    },
    {
      id: 65,
      word: "vain",
      transcription: "veɪn",
      translation: "самозакоханий",
      description: "EXAMPLE\n\nI think he is shallow, vain and untrustworthy.\n\nHe was very vain about his hair and his clothes.\n\nEmployers clearly hoped that the workers would stay longer, but their efforts were largely in vain (= unsuccessful).\n\nDEFINITION\n\nIf you describe someone as vain, you are critical of their extreme pride in their own beauty, intelligence, or other good qualities.\n\nSYNONYMS\n\nnarcissistic, fruitless, conceited"
    },
    {
      id: 66,
      word: "messy",
      transcription: "ˈmesi",
      translation: "безладний",
      description: "EXAMPLE\n\nIt solves the problem of trying to hide away messy cables and unsightly stereos.\n\na child's messy eating habits\n\nfirst girl...hey did u hear that angie was cheating on her boyfriend second girl... girl u need to quit being so messy\n\nDEFINITION\n\nConfused and difficult to deal with.\n\nSYNONYMS\ndirty"
    },
    {
      id: 67,
      word: "wimp",
      transcription: "wɪmp",
      translation: "безхарактерна людина",
      description: "EXAMPLE\n\nIn some ways I am just a scared little guy, a wimp .\n\nThat little wimp is pathetic.\n\ndont call people wimps its not nice, dont be a bully\n\nDEFINITION\n\nA weak and cowardly or unadventurous person.\n\nSYNONYMS\n\nchicken, crybaby"
    },
    {
      id: 68,
      word: "thrill seeker",
      transcription: "θrɪl ˈsiːkər",
      translation: "екстремал",
      description: "EXAMPLE\n\nYour sister's a bit of a thrill seeker.\n\nDEFINITION\n\na person who is eager to take part in exciting activities that involve physical risk"
    },
    {
      id: 69,
      word: "take up",
      transcription: "teɪk ʌp",
      translation: "обговорювати",
      description: "EXAMPLE\n\nDr Mahathir intends to take up the proposal with the prime minister.\n\nFollowing a rigorous round of auditions and interviews Tony was chosen ahead of hundreds of others a fortnight ago to take up the one year course.\n\nThe artist, inspired by her grandmother to take up a needle and thread at the age of five , is determined it does not become a dying art.\n\nDEFINITION\n\n1. If you take up a question, problem, or cause, you act on it or discuss how you are going to act on it. 2. Become interested in activity and spend time doing it.\n\nSYNONYMS\n\nstart, pick up, undertake"
    },
    {
      id: 70,
      word: "sporty",
      transcription: "ˈspɔːti",
      translation: "спортивний",
      description: "EXAMPLE\n\nThey drive a sporty red car.\n\nYou’re looking very sporty in your new jacket.\n\nGuy wasn't really the sporty type.\n\nDEFINITION\n\nstylish and suitable for active people; a sporty person enjoys sport and is good at it:\n\nSYNONYMS\n\nactive, fit, smart"
    },
    {
      id: 71,
      word: "sloppy",
      transcription: "ˈslɒpi",
      translation: "недбалий",
      description: "EXAMPLE\n\nIt is a sloppy piece of journalism which I am amused you allowed to appear on your front page.\n\nShe thinks the Rendezvous duplicates the softer ride of a Buick sedan without being sloppy, thanks in part to an independent rear suspension.\n\nHer wavy brown hair was messy, tangled, and pulled into a sloppy ponytail at the nape of her neck.\n\nDEFINITION\n\nCareless and unsystematic; excessively casual.\n\nSYNONYMS\n\ncareless ,muddy, sentimental"
    },
    {
      id: 72,
      word: "scruffy",
      transcription: "ˈskrʌfi",
      translation: "неохайний",
      description: "EXAMPLE\n\nIt's all about contrasts and contradictions - the smart and the scruffy , the rough and the smooth.\n\nShe couldn't take her eyes off of Scruffy.\n\nHe looked very scruffy; his hair was messy, he hadn't shaved his beard and he had worn the same clothes for ages.\n\nDEFINITION\n\nShabby and untidy or dirty.\n\nSYNONYMS\n\ndirty, messy, foul"
    },
    {
      id: 73,
      word: "risk taker",
      transcription: "rɪsk ˈteɪkər",
      translation: "авантюрист",
      description: "EXAMPLE\n\nShe was a risk-taker, a people person , one of those people who walked into the room and captured attention because there was an energy that came from her.\n\nAs in most genres of art, the nautical or marine artist is a risk taker.\n\nman Trevor sure is a risk taker.-Eryn no he is just a BAMF-Aarie\n\nDEFINITION\n\nA person who takes risks."
    },
    {
      id: 74,
      word: "reserved",
      transcription: "rɪˈzɜːvd",
      translation: "стриманий",
      description: "EXAMPLE\n\nThe English have a reputation for being reserved.\n\nThat guy over there is so reserved.\n\nRobbie is reserved.\n\nDEFINITION\n\nnot wanting to show what you are thinking or feeling:\n\nSYNONYMS\n\nmoderate, reticent"
    },
    {
      id: 75,
      word: "neat",
      transcription: "niːt",
      translation: "акуратний",
      description: "EXAMPLE\n\nHere, in one neat package, we have all the liberal platitudes .\n\n1. That is a really neat car. 2. I like my whiskey neat. 3. James likes to keep a house very neat.\n\nThe way that we flogged that BMW at the lights.... yes dude that was neat!\n\nDEFINITION\n\nA person is habitually tidy, smart, or well organized.\n\nSYNONYMS\n\ngreat, straight, careful"
    },
    {
      id: 76,
      word: "suddenly",
      transcription: "ˈsʌdənli",
      translation: "несподівано",
      description: "EXAMPLE\n\nHe knew how to get a horse ready for the track but suddenly he was responsible for everything.\n\nI was really drunk at this club, and some guy led me to the bathroom. Next thing I know I was suddenly sodomized! It's not rape, it's suddenly sodomy!\n\nSuddenly Wheatley isn't very well accepted by the Portal 2 fandom, since Chell's supposed to be canonically mute and therefore, incapable of singing\n\nDEFINITION\n\nQuickly and unexpectedly.\n\nSYNONYMS\n\non the spur of the moment, dead, short"
    },
    {
      id: 77,
      word: "appropriate",
      transcription: "əˈprəʊpriət",
      translation: "підходящий",
      description: "EXAMPLE\n\nThey feel they have to make some worthy comment, treat the city with some kind of moral scrupulousness and say something appropriate.\n\nThat movie better be appropriate for Sarah to watch.\n\nhow appropriate is that swim suit?\n\nDEFINITION\n\nSuitable or proper.\n\nSYNONYMS\n\nallow, fit, reserve"
    },
    {
      id: 78,
      word: "collar",
      transcription: "ˈkɒlər",
      translation: "нашийник",
      description: "EXAMPLE\n\nAround his throat, a black leather dog collar with large silver spikes completed Sean's attire.\n\nToday he was wearing a cobalt button-down casual shirt with a collar neck .\n\nThe chain was fastened to the back of her collar, giving her a gleaming silver stripe down her back.\n\nDEFINITION\n\nThe part around the neck of a shirt, blouse, jacket or coat, either upright or turned over.\n\nSYNONYMS\n\ncatch, nail, ring"
    },
    {
      id: 79,
      word: "secretive",
      transcription: "ˈsiːkrətɪv",
      translation: "потайний",
      description: "EXAMPLE\n\nNaturally talkative , Theroux discovered the candour as well as the secretiveness of the island's people.\n\nBut the courts are ready , willing and able to deal with highly secretive and sensitive evidence.\n\nhe would carry these documents home to appease his secretive magpie instinct\n\nDEFINITION\n\ninclined to secrecy or reticence about divulging information\n\nSYNONYMS\n\nclose, reticent, closemouthed"
    },
    {
      id: 80,
      word: "cuffs",
      transcription: "kʌf",
      translation: "манжети",
      description: "EXAMPLE\n\nIt was low, yet not revealing, and her sleeves were long and loose with tight cuffs at the wrists .\n\nEmbroidery of colorful dragons chasing their tails encircles the cuffs of her wrists , hemline and neckline.\n\nWhat began as a heated exchange of words soon became full-blown fisticuffs.\n\nDEFINITION\n\nThings people on the television series Cops are not good at breaking.\n\nSYNONYMS\ncup"
    },
    {
      id: 81,
      word: "affairs",
      transcription: "əˈfeər",
      translation: "справи",
      description: "EXAMPLE\n\nThe true gods are fickle and capricious and care little for the affairs of men, but the piper was different.\n\nthis is a disgusting state of affairs!\n\nBut this stuff is being purveyed by the Religious Affairs Department of the Saudi Armed Forces.\n\nDEFINITION\n\nmatters of personal concern\n\nSYNONYMS\n\nwork, personal business, personal matters"
    },
    {
      id: 82,
      word: "ponds",
      transcription: "pɒnd",
      translation: "ставки",
      description: "EXAMPLE\n\nOut ahead lay a wide cultivated basin - ponds near its center, small clumps of trees, many acres of barley and beans and hay and grazing pastures.\n\nThe Teshekpuk area, a network of wet meadows , river deltas, coastal lagoons and small ponds, is the prime calving grounds for a 25,000-strong caribou herd.\n\nIt responds to heat treatment on the improved permanent set stress and ultimate strength with some loss of elongation.\n\nSYNONYMS\n\nbasin, water, pool"
    },
    {
      id: 83,
      word: "openly",
      transcription: "ˈəʊpənli",
      translation: "відкрито",
      description: "EXAMPLE\n\nSome cultures are much more openly superstitious .\n\nOne group has proposed that he can openly join the national cry for urgent action by the Government and its many arms which exist to deal specifically with the problem.\n\nDEFINITION\n\nin an open way\n\nSYNONYMS\nplain, in broad daylight"
    },
    {
      id: 84,
      word: "tell off",
      transcription: "tel ɒf",
      translation: "сварити",
      description: "EXAMPLE\n\nHe never listened to us when we told him off.\n\nMum told me off for slopping water all down her shirt.\n\nIf you make your sister cry, you'll get told off.\n\nDEFINITION\n\nIf someone in authority tells you off, they speak to you angrily about something wrong that you have done.\n\nSYNONYMS\n\nmeasure, criticize, take away"
    },
    {
      id: 85,
      word: "object to",
      transcription: "əbˈdʒɛkt tuː",
      translation: "заперечувати",
      description: "EXAMPLE\n\nA lot of people will object to the book.\n\nI swear, if she didn't give it up soon I was going to brain her with the nearest object to hand.\n\nWe wish to object to the disgusting sight we have to put up with whenever we look out of our window.\n\nDEFINITION\n\nto say something to express one's opposition to or disagreement with something:"
    },
    {
      id: 86,
      word: "surrender",
      transcription: "sərˈendər",
      translation: "здаватися",
      description: "EXAMPLE\n\nWhatever happens, we will never surrender.\n\nDEFINITION\n\nto stop resisting to an enemy or opponent and submit to their authority:\n\nSYNONYMS\n\ngive up, fall, resignation"
    },
    {
      id: 87,
      word: "tell off",
      transcription: "tel ɒf",
      translation: "сварити",
      description: "Example:\nHe never listened to us when we told him off.\nMum told me off for slopping water all down her shirt.\nIf you make your sister cry, you'll get told off.\nDefinition:\nIf someone in authority tells you off, they speak to you angrily about something wrong that you have done."
    },
    {
      id: 88,
      word: "object to",
      transcription: "əbˈdʒɛkt tuː",
      translation: "заперечувати",
      description: "Example:\nA lot of people will object to the book.\nI swear, if she didn't give it up soon I was going to brain her with the nearest object to hand.\nWe wish to object to the disgusting sight we have to put up with whenever we look out of our window.\nDefinition:\nto say something to express one's opposition to or disagreement with something:"
    },
    {
      id: 89,
      word: "surrender",
      transcription: "sərˈendər",
      translation: "здаватися",
      description: "Example:\nWhatever happens, we will never surrender.\nDefinition:\nto stop resisting to an enemy or opponent and submit to their authority:"
    },
    {
      id: 90,
      word: "stare at",
      transcription: "steər ət",
      translation: "витріщатися на",
      description: "Example:\nI happen to know that miserable wretch intimately, as I stare at him each morning in the mirror.\nThere was a sudden clatter and I turned to stare at the couple in surprise.\nClay pointed an accusing finger at Hunter who spun around to stare at the three glaring boys.\nDefinition:\nIf you stare at someone or something, you look at them for a long time."
    },
    {
      id: 91,
      word: "in the limelight",
      transcription: "ɪn ði: ˈlaɪmlaɪt",
      translation: "у центрі уваги",
      description: "Example:\nAnother dumb creature has also been in the limelight.\nDid she not realise that the cost of being an actor is to burn forever in the limelight of intrusive media questioning?\nTonight, amid a galaxy of sporting stars, curling will be back in the limelight.\nDefinition:\nto stand in the spotlight, to enjoy the triumph of an achievement and/or\r\nmaking oneself the centre of attention."
    },
    {
      id: 92,
      word: "influence",
      transcription: "ˈɪnfluəns",
      translation: "вплив",
      description: "Example:\nThe drug companies have a lot of influence on doctors.\nMe: Hi, what do you do for a living?\n\nInfluencer: I'm a social media influencer\n\nMe: There's a jobcentre as soon as you turn right at the top of the road.\nMe: Hi, what do you do for a living?\n\nInfluencer: I'm a social media influencer\n\nMe: There's a jobcentre as soon as you turn right at the top of the road.\nDefinition:\nthe power to affect how someone thinks or behaves, or how something develops:"
    },
    {
      id: 93,
      word: "accuse somebody of",
      transcription: "əˈkjuːz ˈsʌmbədi əv",
      translation: "звинувачувати когось у",
      description: "Example:\nHe was accusing my mum of having an affair with another man.\n1. I accuse the president of the Palestinian Authority of providing coverage of this holocaust in Gaza, Mashaal said.\n\n2. It was a very tough decision, USOC chairman Peter Ueberroth said before opening a sealed envelope and revealing the winning city. If I had all the power - and sometimes people accuse me of that - I would take the map and merge the two...\n''Stop making up accusations that aren't true'\nDefinition:\nIf you accuse someone of doing something wrong or dishonest, you say or tell them that you believe that they did it."
    },
    {
      id: 94,
      word: "sigh",
      transcription: "saɪ",
      translation: "зітхати",
      description: "Example:\nHe sighed deeply and sat down.\nShe sighed sadly\nHer heart leapt as she caught sight of a car exactly like her father's, only to glimpse the blonde woman sitting in the driver's seat.\nDefinition:\nWhen you sigh, you let out a deep breath, as a way of expressing feelings such as disappointment, tiredness, or pleasure."
    },
    {
      id: 95,
      word: "stutter",
      transcription: "ˈstʌtər",
      translation: "заїкатися",
      description: "Example:\nHe knew he was ready, knew it was real, knew it was her, and the words came without a stutter or a stammer.\nHis answer spilled timid and trembling from his frightened lips, a trickle of stuttering feebleness.\nBut she stuttered badly in the second with a string of double faults , helping Seles to take four games on the trot to claim the set from 2-4 down.\nDefinition:\nTalk with continued involuntary repetition of sounds."
    },
    {
      id: 96,
      word: "approve of",
      transcription: "əˈpruːv əv",
      translation: "схвалювати щось",
      description: "Example:\nhe didn't approve of the proposal to pig it in the studio\nthey wouldn't approve of that kind of thing\nPublic opinion is as changeable as the wind , but for today, the crowd decided to approve of Charlie.\nDefinition:\nA mutual approving between a party."
    },
    {
      id: 97,
      word: "sign language",
      transcription: "saɪn ˈlæŋgwɪdʒ",
      translation: "мова жестів",
      description: "Example:\nInstead, Maureen returned to the nearest town of any substance, several hours away by road, and in sign language described to a druggist what she had seen.\nsign language interpreters represent a vital link between the deaf and hearing communities\nSome speak Spanish, Persian , or American Sign Language.\nDefinition:\nA Language for the Deaf or Mute. Known as ASL (American Sign Language) In america.\n\nUses lots of hand Motions to make out sentences. Can be learned easily at any age."
    },
    {
      id: 98,
      word: "gossip",
      transcription: "ˈgɒsɪp",
      translation: "пліткувати",
      description: "Example:\nThey were gossiping about her boss.\nI can't stand here gossiping all day.\nShe's been gossiping about you.\nDefinition:\nto talk about other people's private lives:"
    },
    {
      id: 99,
      word: "get worked up",
      transcription: "gɛt wɜːkt ʌp",
      translation: "завестись",
      description: "Example:\nI dunno … is there anyone out there who can actually get worked up one way or the other over this?\nI dunno … is there anyone out there who can actually get worked up one way or the other over this?\nJustin was so worked up over his sisters friend he would feel sweaty and excited for her return\r\n\r\nGabe was all worked up in anticipation for the expected date with the model\r\n\r\nEvery night before bed he would get worked up over the blonde girls picture\r\n\r\nWaiting to see if she was picked to dance for the next song, Mellissa would get worked up before it even started.\r\nSource: JLynnW, Seattle\nDefinition:\nEmotionally aroused."
    },
    {
      id: 100,
      word: "confess",
      transcription: "kənˈfes",
      translation: "визнавати",
      description: "Example:\nHe confessed that he had attacked the old man.\nHe has confessed to the murder.\nI wanted to confess my feelings for you...\nDefinition:\nto admit that one has committed a crime or done something wrong:"
    },
    {
      id: 101,
      word: "bully",
      transcription: "ˈbʊli",
      translation: "залякувати",
      description: "Example:\nThe union claimed the Royal Mail was trying to intimidate and bully workers into agreeing unacceptable working practices.\nThey should not minimize, rationalize, or explain the bullying away .\nRyan threw a right hook , catching the bully in the jaw.\nDefinition:\nSeek to harm, intimidate, or coerce someone perceived as vulnerable."
    },
    {
      id: 102,
      word: "state",
      transcription: "steɪt",
      translation: "стверджувати",
      description: "Definition:\n"
    },
    {
      id: 103,
      word: "purpose",
      transcription: "ˈpɜːpəs",
      translation: "ціль",
      description: "Example:\nThe purpose of this deliberate deception is easy to see.\nPrinceton spent the whole show looking for his purpose.\nI don't know how I know, but I'm gonna find my purpose.\nDefinition:\nthe reason for which something is done or created or for which something exists."
    },
    {
      id: 104,
      word: "reckon",
      transcription: "ˈrekən",
      translation: "вважати",
      description: "Example:\nI reckon that there are twenty four hours in a day. Anyone think I'm wrong?\r\n\r\nThe man was quite a force to be reckoned with, as he had many good friends in the business.\nI reckon we better get out of here before we get shot.\nI reckon it'll take three hours to get to Birmingham.\r\n\r\nWhat do you reckon we'll have to do to convince him?\r\n\r\nRain tomorrow, d'you reckon?\nDefinition:\nhave faith or confidence in"
    },
    {
      id: 105,
      word: "temptation",
      transcription: "tempˈteɪʃən",
      translation: "спокуса",
      description: "Example:\nThe temptation is enormous to escape into fantasy, or close our eyes and pretend nothing has changed.\nHe said that just a bit of thought could help avoid temptation for the criminals.\nHe can't help but be envious of those in the private sector - there is the great temptation.\nDefinition:\nThe desire to do something, especially something wrong or unwise."
    },
    {
      id: 106,
      word: "euphoria",
      transcription: "juːˈfɔːriə",
      translation: "ейфорія",
      description: "Example:\nWhen ingesting low doses of ethanol, most humans exhibit responses such as disinhibition and euphoria.\n‘Tree surfing’ is euphoria-induced skylarking on a windy day.\nPerhaps we were still a bit dehydrated but nothing could take away the feeling of euphoria we had at our joint achievement.\nDefinition:\na feeling of great (usually exaggerated) elation"
    },
    {
      id: 107,
      word: "mutter",
      transcription: "ˈmʌtər",
      translation: "бурмотіти",
      description: "Example:\nJason muttered, his swarthy face breaking into a grin.\nPicking up the receiver wrathfully , I muttered a monotonous ‘hello’.\nA soft noise came from inside, a quiet shuffling and a low muttering.\nDefinition:\ntalk indistinctly; usually in a low voice"
    },
    {
      id: 108,
      word: "make oneself understood",
      transcription: "meɪk ˌwʌnˈself ˌʌndəˈstud",
      translation: "порозумітися",
      description: "Example:\nI want all of this cleaned up right now, or I'll take away your video games for the weekend. Have I made myself understood?\nIn a foreign country, it's essential to learn a few basic phrases to make oneself understood in common situations.\nWhen facing a language barrier, using gestures and simple expressions becomes necessary to make oneself understood in a foreign environment.\nDefinition:\nMake your meaning clear, especially in another language"
    },
    {
      id: 109,
      word: "yell at",
      transcription: "jel ət",
      translation: "кричати на",
      description: "Example:\nI'm sorry I yelled at you last night.\nAll I want to do is yell at the top of my lungs and throttle people.\nShe'd probably yell at me for giving you too much lenience as a child.\nDefinition:\nIf you yell, you shout loudly, usually because you are excited, angry, or in pain."
    },
    {
      id: 110,
      word: "get across",
      transcription: "get əˈkrɒs",
      translation: "чітко викласти",
      description: "Example:\nI think that's a really important message that we need to get across to people, because whenever you say energy conservation, they immediately think turning off their heaters and not being warm and stuff.\nOne of the key messages we try to get across to our readers is the importance of managing debts.\nAt the end of it all are words, pure and simple - and how you phrase those words and get across what you're saying is the most important thing.\nDefinition:\nWhen an idea gets across or when you get it across, you succeed in making other people understand it."
    },
    {
      id: 111,
      word: "moan",
      transcription: "məʊn",
      translation: "стогнати",
      description: "Example:\nRapid eye movement is at all times detected, and occasionally the patient will moan , even scream during his rest.\nSo, Eskimoan languages are really extraordinary in their productive word-building capability, for any root you might pick.\nAt the edge of the wallow , a young brown and white steer was standing knee deep in the muck, calling to his mother, and she was moaning back at him.\nDefinition:\nA long, low sound made by a person expressing physical or mental suffering."
    },
    {
      id: 112,
      word: "yawn",
      transcription: "jɔːn",
      translation: "позіхати",
      description: "Example:\nThe film is just one big yawn\nThe pain is aggravated by eating, gum chewing, teeth clenching, or yawning.\nI blinked my eyes blearily and opened my mouth to yawn; I felt thick and slow.\nDefinition:\nInvoluntarily open one's mouth wide and inhale deeply due to tiredness or boredom."
    },
    {
      id: 113,
      word: "sympathize",
      transcription: "ˈsɪmpəθaɪz",
      translation: "висловлювати співчуття",
      description: "Example:\nOne of the main reasons they have risen to such prominence is the fact that the police are at best indifferent to them and, at worst, actively sympathize.\nIn fact, it's not hard to sympathize with the fallen devil, or even side with him - his character is more fleshy and alluring than that of the somewhat bland God of the poem.\nSometimes I feel cursed because I see and sympathize with so many sides of so many housing debates.\nDefinition:\nto feel or express sympathy or compassion"
    },
    {
      id: 114,
      word: "apprehensive",
      transcription: "ˌæprɪˈhentsɪv",
      translation: "тривожний",
      description: "Example:\nAnyway… I never realised just how worried and apprehensive he was about her visiting.\nRebecca spent her entire taxi ride apprehensive about showing up at a stranger's place.\nOne of these youths stole a four- figure sum from me recently and I am now very apprehensive.\nDefinition:\nAnxious or fearful that something bad or unpleasant will happen."
    },
    {
      id: 115,
      word: "contradict",
      transcription: "ˌkɒntrəˈdɪkt",
      translation: "заперечувати",
      description: "Example:\nThose who relish the contradiction of something so bad it's good, will wallow like pigs in clover.\nSome trends may be apparent but other changes may occur which may contradict the general direction of the trend.\nThe new antithesis forms out of elements of the original contradiction that didn't make it into the synthesis.\nDefinition:\ndeny the truth of"
    },
    {
      id: 116,
      word: "deny",
      transcription: "dɪˈnaɪ",
      translation: "заперечувати",
      description: "Example:\nThat all has to come, and I don't deny that there are complexities in taking these treatments.\nShe is a deny for doing that\nShe is a deny for doing that\nDefinition:\nto refuse to admit the truth:"
    },
    {
      id: 117,
      word: "redrafted",
      transcription: "ˌriːˈdrɑːfted",
      translation: "переписаний",
      description: "Example:\nHe didn't send the letter, in fact he spent the remaining five years of his life redrafting it - he was notorious for redrafting scientific papers - and he redrafted this letter.\nTheir motive is to help people, and the definition of treason needs to be redrafted so that they can do their important humanitarian work without fear of being charged with treason.\nThe various security documents held by the Bank were redrafted in early 1985.\nDefinition:\nIf you redraft something you have written, you write it again in order to improve it or change it."
    },
    {
      id: 118,
      word: "slander",
      transcription: "ˈslɑːndər",
      translation: "зводити наклеп",
      description: "Example:\nThere is therefore no basis for a cause of action of slander of title.\nThe editor slandered the actress in the newspaper.\nemigration is a major problem for the islanders\nDefinition:\nMake false and damaging statements about someone."
    },
    {
      id: 119,
      word: "retort",
      transcription: "rɪˈtɔːt",
      translation: "різка та дотепна відповідь",
      description: "Example:\nA touch of humour, a clever retort or even quiet, dominant doggedness can be brilliantly effective - if it comes from a person whose very presence commands respect.\nAnd when that draws sarcastic comment from the management team, his ability to offer quick-witted retorts allows him to ride the banter as effortlessly as another lunge from a desperate defender.\nShe spoke for cosmeticians around the world when she retorted, ‘I'm tired of all this nonsense about beauty being only skin-deep.’\nDefinition:\nSay something in answer to a remark or accusation, typically in a sharp, angry, or wittily incisive manner."
    },
    {
      id: 120,
      word: "reconsider",
      transcription: "ˌriːkənˈsɪdər",
      translation: "переглядати",
      description: "Example:\nThis is an insulting and ill-founded belief which I would advise you to reconsider.\nI once again implore that you reconsider your stance on this matter.\nsince writing the above , I have reconsidered\nDefinition:\nConsider something again, especially for a possible change of decision regarding it."
    },
    {
      id: 121,
      word: "pretend",
      transcription: "prɪˈtend",
      translation: "прикидатися",
      description: "Example:\n I can't pretend that I like him.\nThe children pretended (that) they were dinosaurs.\nWere you just pretending to be interested?\nDefinition:\nto behave so as to make it appear that something is the case when in fact it is not:"
    },
    {
      id: 122,
      word: "mark",
      transcription: "mɑːk",
      translation: "Оцінка",
      description: "Definition:\n"
    },
    {
      id: 123,
      word: "silly",
      transcription: "ˈsɪli",
      translation: "дурний",
      description: "Example:\nIt is a silly thing to do.\nDon't be silly!\nNo, silly, I didn't mean that.\nDefinition:\nhaving a lack of common sense or judgment:"
    },
    {
      id: 124,
      word: "jewelry",
      transcription: "ˈdʒuːəlri",
      translation: "коштовності",
      description: "Example:\nShe wears a lot of gold jewelry.\nThe jewelry showed exquisite craftsmanship.\nShe doesn't like ornate jewelry.\nDefinition:\npersonal ornaments, such as necklaces, rings, or bracelets, that are typically made from or contain jewels and precious metal:"
    },
    {
      id: 125,
      word: "occur",
      transcription: "əˈkɜːr",
      translation: "траплятися",
      description: "Example:\nBut the foreseers do not believe this is the last time a war over land will occur between these neighbors.\nDave: Did you hear about the secret message you can get at urbandictionary.com?\r\nDan: No I didn't.\r\nDave: The message says {error:An error occurred.}\nOh my God. How many OCCURANCES!?\nDefinition:\n(especially of accidents and other unexpected events) to happen:"
    },
    {
      id: 126,
      word: "species",
      transcription: "ˈspiːʃiːz",
      translation: "вид",
      description: "Example:\nThe fact that a new genus of partridge was formally described just three years ago tells how little is known about a large percentage of the species in that group.\nWe've got African wild cats, the black-footed cat , on the farm and they inter-breed with these feral cats and it destroys the whole species.\nI sure don't want to be Specis.\nDefinition:\na group of living organisms consisting of similar individuals capable of exchanging genes or interbreeding:"
    },
    {
      id: 127,
      word: "conciliation",
      transcription: "kənˌsɪlɪˈeɪʃən",
      translation: "примирення",
      description: "Example:\nIn the hierarchy of local raja he was the most junior of the twelve in the Kei Islands, but he was able to approach the others and start a movement of customary reconciliation.\nHe was a competent experienced man with unusual gifts of conciliation and tact.\nThe morning after, the cathedral's stonemason fashioned two charred oaken beams from the wreckage into a cross which became a symbol of reconciliation rather than revenge.\nDefinition:\nthe act of placating and overcoming distrust and animosity"
    },
    {
      id: 128,
      word: "aspiration",
      transcription: "ˌæspɪˈreɪʃən",
      translation: "прагнення",
      description: "Example:\nIt's a story about the lives and aspirations of poor Irish immigrants.\nBe careful not to choke on your aspirations.\nBe careful not to choke on your aspirations.\nDefinition:\na hope or ambition of achieving something:"
    },
    {
      id: 129,
      word: "drowsy",
      transcription: "ˈdraʊzi",
      translation: "сонний",
      description: "Example:\nI was enjoying the moment of drowsy bliss before reality hit me like a brick of lead.\nSome human lung diseases such as chronic bronchitis may leave the patient drowsy or even comatose because of the build up of carbon dioxide in the body.\nAlso, there was a black stream in Mirkwood that made he who drank out of it suddenly very drowsy and forgetful of previous events.\nDefinition:\nshowing lack of attention or boredom"
    },
    {
      id: 130,
      word: "farewell dinner",
      transcription: "ˌfeəˈwel ˈdɪnər",
      translation: "прощальний обід",
      description: "Example:\nOn 8 August 1952 he and Joan gave a farewell party to Cambridge friends.\nDefinition:\nA party or dinner that you have because someone is leaving a job, city etc"
    },
    {
      id: 131,
      word: "insight into",
      transcription: "ˈɪnsaɪt ˈɪntu",
      translation: "розуміння чогось",
      description: "Example:\nAnd two decades later, he re-visits the underarm delivery and provides a fascinating insight into why he asked his younger brother Trevor to bowl that infamous delivery.\nPatton shows a marked insight into training horse and rider as he cautions against harsh movements with the bridle hand that would cause a horse to shy .\nI have a sudden insight into how deeply tiresome it must be to be famous.\nDefinition:\nunderstanding, intuition, wisdom, perception."
    },
    {
      id: 132,
      word: "terrify",
      transcription: "ˈterəfaɪ",
      translation: "жахати",
      description: "Example:\nThe terrifying sound of the lion's roar made his heart beat with fright.\nPeople came from Norway on an arduous, and in some cases terrifying, voyage, vividly described here.\nIt is always terrifying to give birth; how much more so without one's mate there to share the moment?\nDefinition:\nIf something terrifies you, it makes you feel extremely frightened."
    },
    {
      id: 133,
      word: "fantasize",
      transcription: "ˈfæntəsaɪz",
      translation: "фантазувати",
      description: "Example:\nHe fantasized about winning the Nobel Prize.\nHe returned his cold stare to the carefree couple below and fantasized about his victory.\nAfter that I fantasized for hours about living in such a house and having several maids and butlers instead of our one.\nDefinition:\nIndulge in daydreaming about something desired."
    },
    {
      id: 134,
      word: "figment of",
      transcription: "ˈfɪgmənt əv",
      translation: "вигадка",
      description: "Example:\nThe attack wasn't just a figment of my imagination.\nI posted my poem on figment and people are loving it\nSocial figments, feints, and formalism. --Mrs. Browning\r\nIt carried rather an appearance of figment and invention . . . than of truth and reality. --Woodward.\nDefinition:\nIf you say that something is a figment of someone's imagination, you mean that it does not really exist and that they are just imagining it."
    },
    {
      id: 135,
      word: "get rid of",
      transcription: "get rɪd əv",
      translation: "позбавитися від",
      description: "Example:\nCan't we just get rid of the young pretenders and instal him as King of England?\nThe Tories were keen to get rid of the National Dock Labour Scheme, which protected dockers from casual labour .\nThis guy thinks we should get rid of the dime and replace it with an 18 cent piece .\nDefinition:\nTake free of something."
    },
    {
      id: 136,
      word: "oversleep",
      transcription: "ˌəʊvəˈsliːp",
      translation: "проспати",
      description: "Example:\nHe explained that he was in fact on indefinite exile from the Parish for committing the unforgivable and irredeemable sins of garrulity , irreverent laughter, vile thoughts and oversleeping.\nIf I don't get that much, I tend to oversleep until I've had the 4 hours, no matter how many alarms I have set.\nTry and get an early night so I don't oversleep tomorrow.\nDefinition:\nsleep longer than intended"
    },
    {
      id: 137,
      word: "indispensable",
      transcription: "indiˈspensəbl",
      translation: "необхідний",
      description: "Example:\nYet what makes this set truly indispensable is its array of extras.\nBut let them also desist from their futile campaign to make it an indispensable badge or emblem of our sense of ‘Irishness’.\nA mesh strainer is indispensable for grain cookery.\nDefinition:\nabsolutely necessary:"
    },
    {
      id: 138,
      word: "homesick",
      transcription: "ˈhəʊmsɪk",
      translation: "який тужить за домом",
      description: "Example:\nAfter sometime I felt homesick and took a ten-day break from there.\nIt's all made me dreadfully homesick for Costa Rica, and for all my friends.\nFor the first two terms there I was very homesick and if anyone said anything cross to me, I'd burst into tears.\nDefinition:\nExperiencing a longing for one's home during a period of absence from it."
    },
    {
      id: 139,
      word: "favor",
      transcription: "ˈfeɪvər",
      translation: "послуга",
      description: "Example:\nWe solved your case, now I get my favor.\nthat style is in favor this season\nTyrone sure does favor his mother. Girl, they look just alike!\nDefinition:\nAn act of kindness beyond what is due or usual."
    },
    {
      id: 140,
      word: "daunting",
      transcription: "ˈdɔːntɪŋ",
      translation: "бентежний",
      description: "Example:\nWhen I first started my career in carpentry , building a set of stairs seemed like a complicated and daunting task.\nto daunt one's adversaries. \r\n\nThey were faced with the daunting task of restoring the house.\nDefinition:\nSeeming difficult to deal with in anticipation; intimidating."
    },
    {
      id: 141,
      word: "challenging",
      transcription: "ˈtʃælɪndʒɪŋ",
      translation: "багатообіцяючий",
      description: "Example:\nI accept that there are strong flavours and challenging textures here which may not be everyone's idea of good eating.\nI had a very challenging childhood. My parents pushed me through school and out into the real world without giving me an ounce of real love.\nDefinition:\nDemanding or stimulating."
    },
    {
      id: 142,
      word: "be off",
      transcription: "biː ɒf",
      translation: "йти геть",
      description: "Example:\nI'll be off soon.\nI'll be off at five o'clock tomorrow.\nUnfortunately, the best part of his interview was off air.\nDefinition:\nGo away; leave."
    },
    {
      id: 143,
      word: "crucial",
      transcription: "ˈkruː.ʃəl",
      translation: "важливий",
      description: "Example:\nUnderstanding the basics is crucial for advanced learning.\nRegular practice is crucial to improve language skills.\nFeedback is crucial for continuous improvement.\nDefinition:\nextremely important or necessary:"
    },
    {
      id: 144,
      word: "chase",
      transcription: "tʃeɪs",
      translation: "полювати",
      description: "Example:\nThe film featured several car chase sequences.\nThe share purchase obligates the cooperative to accept the unit at an established price.\nThe lions chased him, and savaged his leg before he fell into a thorn bush too dense for them to reach him.\nDefinition:\nto hurry after someone or something in order to catch him, her, or it:"
    },
    {
      id: 145,
      word: "chase",
      transcription: "tʃeɪs",
      translation: "переслідувати",
      description: "Example:\nThe film featured several car chase sequences.\nThe share purchase obligates the cooperative to accept the unit at an established price.\nThe lions chased him, and savaged his leg before he fell into a thorn bush too dense for them to reach him.\nDefinition:\nto hurry after someone or something in order to catch him, her, or it:"
    },
    {
      id: 146,
      word: "surgeon",
      transcription: "ˈsə:dʒən",
      translation: "лікар хірург",
      description: "Example:\nThe surgeon operatued on me yesterday\r\nWatching House made them into a surgeon\nA:I am sorry it took so long, I was surgeoning and could not elbow the door open.\r\nB: No problem. Next time try to wait until someone comes in and you can sneak really fast through the closing door.\n  I couldn't afford my next mortgage payment; and needed the cash to avoid foreclosure,  so I decided to sell my left kidney and spleen.  I found a street surgeon who is more than willing to remove and sell them for a good price.\nDefinition:\na physician who specializes in surgery"
    },
    {
      id: 147,
      word: "needle",
      transcription: "ˈni:dl",
      translation: "голка",
      description: "Example:\nYoure needling me\nThere's always needle when Manchester United play Leeds.\nThe whole table needle(d) Phil until he finally cracked and went on tilt.\nDefinition:\na thin, pointed metal object with a small hole at one end for thread, used in sewing"
    },
    {
      id: 148,
      word: "survey",
      transcription: "ˈsɜːveɪ",
      translation: "обстежити",
      description: "Example:\nJust like social survey research, structured observation necessitates decisions about sampling.\nI just finished a long survey about me .\nhis survey of the battlefield was limited\nDefinition:\nAn investigation of the opinions or experience of a group of people, based on a series of questions."
    },
    {
      id: 149,
      word: "certain",
      transcription: "ˈsɜːtən",
      translation: "впевнений",
      description: "Example:\nNeither, although his comics have brought him a certain degree of wide-eyed adulation , is he any kind of superhero.\nwas sure (or certain) she had seen it\nErnest: How sure are you that you love Emily?\n\nBrent: Certainically sure!!!\n\nErnest: DAMN MAN! She got a sister?!\nDefinition:\nHaving or showing complete conviction about something."
    },
    {
      id: 150,
      word: "tidy",
      transcription: "ˈtaɪdɪ",
      translation: "прибирати",
      description: "Example:\nThe house was clean and tidy.\nI hate to be the one to break it to you but we all think your sister's tidy...\na tidy sum of money\nDefinition:\nput (things or places) in order"
    },
    {
      id: 151,
      word: "chorus",
      transcription: "ˈkɔːrəs",
      translation: "хор",
      description: "Example:\nIn the gala-concert take part leading soloists, chorus, ballet and orchestra of theatre.\nHer biggest excitement, though, was hearing her guests join lustily in the choruses.\nHowever, around the turn of the 15th century, the practice began of having a small chorus sing polyphonically.\nDefinition:\na large organized group of singers; part of a song that is repeated several times, usually after each verse:"
    },
    {
      id: 152,
      word: "astronaut",
      transcription: "ˈæstrənɔ:t",
      translation: "космонавт",
      description: "Definition:\n"
    },
    {
      id: 153,
      word: "claw",
      transcription: "klɔː",
      translation: "кіготь",
      description: "Example:\nThe plate in the field guide shows a strange, golden-brown animal with a prehensile tail, hook-like claws and a funny snub nose.\nIt likely used its muscled shoulders and the enlarged claw on the second toe of each forelimb to grasp its prey.\nDefinition:\na mechanical device that is curved or bent to suspend or hold or pull something"
    },
    {
      id: 154,
      word: "insight",
      transcription: "ˈɪnsaɪt",
      translation: "розуміння",
      description: "Example:\nHe unravels the tangled strands of social identity and interests that surrounded these protests with considerable delicacy and insight.\nAngelia saw great insight to the problem I was having and helped me find a way to solve it..\nthat was so insightful to know that, please tell me more.\nDefinition:\nThe capacity to gain an accurate and deep intuitive understanding of a person or thing."
    },
    {
      id: 155,
      word: "relieve",
      transcription: "rɪˈliːv",
      translation: "полегшувати",
      description: "Example:\nAntibiotics and painkillers can temporarily relieve symptoms such as swelling and pain but they are not long-term solutions.\nAn armoured battalion was sent to relieve the besieged town.\nThe guard is relieved at 6 p.m. by the night watchman.\nDefinition:\nRelease someone from duty by taking their place."
    },
    {
      id: 156,
      word: "lack",
      transcription: "læk",
      translation: "відсутність",
      description: "Example:\nHer only problem is a lack of confidence.\nHe just lacks a little confidence.\nShe certainly has no lack of friends.\nDefinition:\nthe state of being without or not having enough of something:"
    },
    {
      id: 157,
      word: "prey",
      transcription: "preɪ",
      translation: "здобич",
      description: "Example:\nDespite their ugly appearance, their bodies are ideally shaped for relentless running down of prey.\nIt seems, however, that it is not just the adverts that prey on young minds.\nRaptors are known to prey on game species, such as quails, partridges , pheasants and rabbits.\nDefinition:\nprofit from in an exploitatory manner"
    },
    {
      id: 158,
      word: "simultaneously",
      transcription: "ˌsaɪ.məlˈteɪ.ni.əs.li",
      translation: "одночасно",
      description: "Example:\nthey spoke simultaneously\nI masturbate and watch porn simultaneously.\ndude, lets go to tacobell and after lets go back simultane\nDefinition:\nat the same instant"
    },
    {
      id: 159,
      word: "flour",
      transcription: "flaʊər",
      translation: "борошно",
      description: "Example:\na flour tortilla with salsa and shredded cheese\nA Cornish claypit has been transformed into an Eden where over 4,000 species of plants from all over the world flourish under a series of great domes, creating a kind of botanical ark .\nThe whole idea of this is to facilitate the easy movement of through traffic and allow the town to flourish.\nDefinition:\nA powder obtained by grinding grain."
    },
    {
      id: 160,
      word: "ensure",
      transcription: "ɪnˈʃɔːr",
      translation: "запевняти",
      description: "Example:\nHe added that he would soon seek foreign financial support to ensure that safety is restored at the site.\nNow specimens grown from seed have been air-freighted to the Royal Botanic Garden in Edinburgh as part of a global effort to ensure the species' long-term survival.\nUnethical testimony also can be considered unprofessional conduct for purposes of licensure discipline.\nDefinition:\nMake certain that something shall occur or be the case."
    },
    {
      id: 161,
      word: "domestic",
      transcription: "dəuˈmestɪk",
      translation: "домашній",
      description: "Example:\nThere is a guy in Bedfordshire who has sold the world's most expensive cat - a cross breed between a domestic cat and a feral one.\nIf a man wipes his feet on the door mat before coming into the room, you may be sure he will make a good domestic husband.\nRestrictions and slaughter provisions apply to domestic fowls, turkeys, geese, ducks, guinea fowls, quail , ratites, pigeons, pheasants and partridges reared or kept in captivity.\nDefinition:\na servant who is paid to perform menial tasks around the household"
    },
    {
      id: 162,
      word: "curtains",
      transcription: "ˈkɜːtən",
      translation: "штори",
      description: "Example:\nIt was only then that blue flashing lights were seen through the white net curtains of the lounge.\nAnother variation to try is to place a thin voile net over the window, or draw any transparent curtains.\nnet curtains\nDefinition:\nIt's curtainsthe ending of something or realizing it's over with or done for"
    },
    {
      id: 163,
      word: "propensity",
      transcription: "prəˈpensɪtɪ",
      translation: "схильність",
      description: "Example:\nthe propensity of disease to spread\nThe most primitive craniates we know are the living Myxinoidea (hagfishes): eel-like , rather asymmetric creatures with a strong propensity to flood their immediate neighborhood with slime at the slightest provocation.\nArgon is also an ideal carrier gas, a propellant with no propensity to react.\nDefinition:\na natural inclination"
    },
    {
      id: 164,
      word: "farewell",
      transcription: "ˈfɛəˈwel",
      translation: "прощання",
      description: "Example:\nFarewell to you my love.\nAccept the truth that some people don't really care about you OR what you say or do.\n\nThis is when you must say, Farewell forever.\nFarewell my good friend.\nDefinition:\nan acknowledgment or expression of goodwill at parting"
    },
    {
      id: 165,
      word: "intelligence",
      transcription: "ɪnˈtelɪdʒənts",
      translation: "інтелект",
      description: "Example:\nIt's the intelligence of her writing that impresses me.\nHe believes that all children are born with equal intelligence.\nHe is blessed with both good looks and intelligence.\nDefinition:\nthe ability to learn, understand:"
    },
    {
      id: 166,
      word: "hardheaded",
      transcription: "ˈhɑ:dˈhedɪd",
      translation: "твердолоба",
      description: "Example:\nA self-described mama's boy, he combines a puppyish playfulness with an obsessive work ethic and a hardheaded understanding of the business of triathlon.\nThat's because Doctorow writes with the kind of hardheaded humor and logic that makes one suspect this book will be a mind-boggling delight.\na hardheaded appraisal of our position\nDefinition:\nHardhead Moneyclick formally known as (HHMC) is a notorious street gang from Atlanta’s Northside in Cobb county’s Smyrna Georgia. The gang is responsible for numerous murders,robberies and thefts through out Cobb county."
    },
    {
      id: 167,
      word: "baffling",
      transcription: "ˈbæflɪŋ",
      translation: "спантеличує",
      description: "Example:\nThe fact that the film tries to go back to cheeky black comedy after this is simply baffling.\nIt is baffling being a man, especially now, particularly if you are ageing and English.\nBafflingly, a knighthood still awaits, but this present accolade will surely not be the last that comes the way of a musician of unswerving integrity and principle .\nDefinition:\nmaking great mental demands; hard to comprehend or solve or believe"
    },
    {
      id: 168,
      word: "shreds",
      transcription: "ʃred",
      translation: "клапті",
      description: "Example:\nTear down the walls of self-consciousness in your mind, rip to shreds all the self-defeating messages you torture yourself with all the time.\nThe common four-sided box graters have different-size holes on each side, but only the long, flat holes (the ones you use for cheese) will produce the right shreds for a crispy pancake.\nDefinition:\na tiny or scarcely detectable amount"
    },
    {
      id: 169,
      word: "pounce",
      transcription: "paʊnts",
      translation: "Накидатися",
      description: "Example:\nIn October 2002 Evans pounced on the youngster as he went to the shops to buy a pint of milk.\nMake no mistake, there are many who would love to see O'Leary fail and are waiting in the wings to pounce once things start to go wrong.\nHe'd pounce too fast and fall short of the pigeon .\nDefinition:\nmove down on as if in an attack"
    },
    {
      id: 170,
      word: "daydreamer",
      transcription: "ˈdeɪˌdriːmər",
      translation: "мрійник",
      description: "Example:\nI've always been a realist, not a daydreamer .\nHe was often inattentive in his own schooling and was a habitual daydreamer .\nYou're quite a daydreamer and can be a hopeless romantic.\nDefinition:\nsomeone who indulges in idle or absentminded daydreaming"
    },
    {
      id: 171,
      word: "take off",
      transcription: "teɪk ɒf",
      translation: "знімати (відповідальність)",
      description: "Example:\nThe plane took off three hours late.\nThe team plays an important role in ensuring the balloon is prepared and filled to suit the timing of the launch and to ensure the envelope is ready for take off.\nShe's really good at taking people off.\nDefinition:\nan airplane leaves the ground and starts flying; to remove the responsibility:"
    },
    {
      id: 172,
      word: "prevail",
      transcription: "prɪˈveɪl",
      translation: "переважати",
      description: "Example:\nThey complained that corporate interests often prevailed over the needs of the individual.\nGregory was far behind Frank, but ended up prevailing thanks to a second wind on the last lap.\nI am in prevaility of my latest achievement of building a masterpiece.\nDefinition:\nto get control or influence in a particular situation"
    },
    {
      id: 173,
      word: "worst-case scenario",
      transcription: " wɜːst keɪs sɪˈnɑːriəʊ",
      translation: "найгірший варіант розвитку подій",
      description: "Example:\nAs Claire was fond of telling me, I had a habit of reducing every situation to the worst-case scenario.\nLike Christopher Robin's Eeyore, Capricorns adore a worst-case scenario, which brings out their best.\nThey said a worst-case scenario could see it continue on even longer.\nDefinition:\nThe worst-case scenario is the worst possible thing that could happen in a particular situation."
    },
    {
      id: 174,
      word: "nightmare",
      transcription: "ˈnaɪtmeər",
      translation: "нічний кошмар",
      description: "Example:\nI shouldn't have watched that movie - it'll give me nightmares.\nThe whole journey was a nightmare - we lost our luggage and both flights were delayed.\nBeing trapped underwater is my worst nightmare.\nDefinition:\na frightening or unpleasant dream:"
    },
    {
      id: 175,
      word: "unattainable",
      transcription: "ˌʌnəˈteɪnəbl̩",
      translation: "недосяжний",
      description: "Example:\nHe wanted secretly to pursue a more artistic path but his circumstances seemed to make that unattainable.\nhis mind soared to previously unattainable heights of insight\nIt is not unattainable, it is within the reach and grasp of all who strive and aspire to have it.\nDefinition:\nimpossible to achieve"
    },
    {
      id: 176,
      word: "scorching hot",
      transcription: "ˈskɔ:tʃɪŋ hɔt",
      translation: "спекотний",
      description: "Example:\nAlmost immediately, his calf swelled up, and the skin covering it grew scorching hot.\nI had to leave it running for a minute or two until it was scorching hot.\nDid you ever put your fingers on something scorching hot?\nDefinition:\nextremely hot and sweaty:"
    },
    {
      id: 177,
      word: "truthful",
      transcription: "ˈtruːθfəl",
      translation: "правдивий",
      description: "Example:\nshe tried to answer his questions truthfully\nLike a doctor afraid to frighten a patient with a truthful diagnosis, it doesn't say half enough.\nI'm very proud of the film and I think I've been truthful and respectful of his work.\nDefinition:\nexpressing or given to expressing the truth"
    },
    {
      id: 178,
      word: "reminiscent of",
      transcription: "ˌremɪˈnɪsənt əv",
      translation: "що нагадує",
      description: "Example:\nThe scene was reminiscent of the Mafia godfather who goes to confession on Sunday before returning to his normal criminal activities on Monday.\nThe ugly little scene had been so reminiscent of thousands of such incidents over the years; times that caused angry tense silences or stormy exits.\nBig-leaf magnolias , reminiscent of banana trees but much larger, grow profusely across every tangled terrace.\nDefinition:\nawakening memories of something similar; suggestive "
    },
    {
      id: 179,
      word: "recurring dream",
      transcription: "rɪˈkɜːrɪŋ driːm",
      translation: "сон, що повторюється",
      description: "Example:\nWhen Lacuna anesthetizes him, it will repeat endlessly in a recurring dream, skipping like a needle on a scratched record.\nShe has a recurring dream, she confides, in which she is a sloppy and unprofessional actress.\nDefinition:\nA recurring dream is a dream which is experienced repeatedly over a long period."
    },
    {
      id: 180,
      word: "lifelong ambition",
      transcription: "ˈlaɪflɒŋ æmˈbɪʃən",
      translation: "мета всього життя",
      description: "Example:\nShe finally achieved/realized/fulfilled her life's ambition when she started her own business.\nThe pursuit of money is a common thing these days, but I still cannot grasp how money can be a lifelong ambition.\nFor the three of us today this was the fulfillment of lifelong ambitions, but paradoxically is also just the beginning of an adventure which we can't wait to share with thousands of others.\nDefinition:\nThe thing one most wants to do in one's life."
    },
    {
      id: 181,
      word: "wander around",
      transcription: "ˈwɒndər əˈraʊnd",
      translation: "блукати",
      description: "Example:\nWhether or not the main quest is more than just an excuse to introduce cool new gear, it's still fun to wander around lackadaisically .\nI went for a wander around the Castle yesterday, then down the Royal Mile and back along Princes Street.\nThe Museo de las Culturas de Oaxaca is in a former monastery and a wander around the airy cloisters or in the excellent cacti garden offer a respite from any cases of museum fatigue.\nDefinition:\nMove or travel slowly through or over a place or area."
    },
    {
      id: 182,
      word: "vulnerable",
      transcription: "ˈvʌlnərəbl̩",
      translation: "вразливий",
      description: "Example:\nThe trouble was that, with stability restored, and the Tudor dynasty apparently secure, England had started to become vulnerable to a mounting release of forces.\nIt is an immensely tough way of living but one which now, with over-grazing and an increasingly capricious climate, is beginning to look very vulnerable.\nA survey shows that these people are more vulnerable to diseases linked to excessive fat .\nDefinition:\nSusceptible to physical or emotional attack or harm."
    },
    {
      id: 183,
      word: "suppress",
      transcription: "səˈpres",
      translation: "пригнічувати",
      description: "Example:\nThe networks could fight the politicians on First Amendment principles, arguing that it's insane to suppress newsworthy information.\nShe suppressed a curse of anger, when her dress got a hang on a branch.\nDuring the early stages of plant development, internode elongation is suppressed and only leaves expand.\nDefinition:\nForcibly put an end to."
    },
    {
      id: 184,
      word: "prophetic",
      transcription: "prəˈfetɪk",
      translation: "пророчий",
      description: "Example:\nTwenty-five years on, who can gainsay their prophetic analysis?\nThe words of later Hebrew mystics capture accurately prophetic consciousness.\nHe's the world most famous propheteer in the history of false prophecy.\nDefinition:\nAccurately describing or predicting what will happen in the future."
    },
    {
      id: 185,
      word: "plummet",
      transcription: "ˈplʌmɪt",
      translation: "впасти",
      description: "Example:\nOther residents expressed fears that the village's character would be ruined and house values would plummet .\nWhen I tipped my head back, I saw the hawk buckle its wings and plummet behind the trees.\nSo did populations of sooty shearwaters, a seabird that eats young fish and large plankton, which plummeted 90 percent.\nDefinition:\n(of a heavy weight) to fall or drop swiftly:"
    },
    {
      id: 186,
      word: "constantly",
      transcription: "ˈkɒntstəntli",
      translation: "постійно",
      description: "Definition:\nnull"
    },
    {
      id: 187,
      word: "kid",
      transcription: "kɪd",
      translation: "дитя",
      description: "Example:\nHe used to kid me about being chubby.\nKid, did you eat all that pizza??\nDefinition:\nDeceive someone in a playful way; tease."
    },
    {
      id: 188,
      word: "certain",
      transcription: "ˈsɜːtən",
      translation: "визначений",
      description: "Example:\nNeither, although his comics have brought him a certain degree of wide-eyed adulation , is he any kind of superhero.\nwas sure (or certain) she had seen it\nErnest: How sure are you that you love Emily?\n\nBrent: Certainically sure!!!\n\nErnest: DAMN MAN! She got a sister?!\nDefinition:\nHaving or showing complete conviction about something."
    },
    {
      id: 189,
      word: "courage",
      transcription: "ˈkɜːr.ɪdʒ",
      translation: "відвага",
      description: "Example:\nIt took courage to start over in a new city.\nShe found the courage to join the community club.\nIt required courage for him to ask for help in his new role.\nDefinition:\nthe ability to do something that frightens one:"
    },
    {
      id: 190,
      word: "pursue",
      transcription: "pəˈsjuː",
      translation: "домагатися",
      description: "Example:\nThe car was pursued by helicopters.\nThe hunters spent hours pursuing their prey.\nWe will not be pursuing this matter any further.\nDefinition:\nto follow or chase someone or something:"
    },
    {
      id: 191,
      word: "oppression",
      transcription: "əˈpreʃən",
      translation: "пригніченість",
      description: "Example:\nWhile liberation from superstition and autocratic oppression is the great legacy of the Enlightenment, to perpetuate the repression of all spiritual expression in the name of reason is to continue to deny our innate being.\nIt is about the fear of crime, oppression of women and how people feel safer to blinker themselves against poverty and homelessness.\nDespite its grand , stately appearance, this fine city struggles, shrouded in a shadow of gloom and misery, crushed under an iron fist of oppression.\nDefinition:\na feeling of being oppressed"
    },
    {
      id: 192,
      word: "sweat",
      transcription: "swet",
      translation: "піт",
      description: "Example:\nExercise makes one sweat\nhe's in a sweat about exams\nDid you hear about Matt? He sweated on that Call of Duty game that came out yesterday; he's already level 30!\nDefinition:\nexcrete perspiration through the pores in the skin"
    },
    {
      id: 193,
      word: "magnifying",
      transcription: "ˈmægnɪfaɪ",
      translation: "збільшувальний",
      description: "Example:\nI stay away from the cosmetic counters in Neiman Marcus or Nordstroms because they are so Poor Magnifying.\nin Canadian English something like 3 magnifier 10 would be equal to 3 to the power of 10, not 3 multiplied by 10!\nRiding in the back of Elrod's Pinto across West Texas after a bottle of tequila and some peyote buttoms, the gag-o-magnifier kicked into warp mode and had me hurling like exorcist girl.\nDefinition:\nWhen an individual desires a luxury item but cannot afford the item drawing attention to the individual's less than wealthy circumstances."
    },
    {
      id: 194,
      word: "inspire",
      transcription: "ɪnˈspaɪər",
      translation: "надихнути",
      description: "Example:\nHis leadership inspires his followers.\nAfter her trip to Venezuela, she felt inspired to learn Spanish.\nShe inspires great loyalty among her followers.\nDefinition:\nto make someone feel that they want to do something and can do it:"
    },
    {
      id: 195,
      word: "mice",
      transcription: "maɪs",
      translation: "миші",
      description: "Example:\nWe rustled through the branches like mice fleeing from a cat .\nThe gene is known to help determine hair color in many mammals, from humans to mice.\nExample one: MICE fanfiction of Harry Potter: In this fanfiction, Harry's parents are never killed by You-Know-Who\r\n\r\nExample two: Geepers, my mother-in-law just moused out the fact that her daughter and I ever got married - treated me like a total stranger.\nDefinition:\nmerely the protrusion into our dimension of vastly hyperintelligent pandimensional beings. The whole business with the cheese and the squeaking is just a front"
    },
    {
      id: 196,
      word: "scorching",
      transcription: "ˈskɔːtʃɪŋ",
      translation: "спекотний",
      description: "Example:\nTo escape from the scorching, sultry summers of Delhi he would take his trainees to the sand dunes of the Yamuna at Okhla, South Delhi.\nInstead, the attack crashed into the ground scorching it and sending an explosive shower of dust up into the air.\nTo escape from the scorching, sultry summers of Delhi he would take his trainees to the sand dunes of the Yamuna at Okhla, South Delhi.\nDefinition:\nVery hot."
    },
    {
      id: 197,
      word: "futile",
      transcription: "ˈfjuːtaɪl",
      translation: "марний",
      description: "Example:\nWorrying over the results after the exam is a futile exercise as you cannot alter the result.\nMultiple postings may make it futile to proceed against any given site.\nBut let them also desist from their futile campaign to make it an indispensable badge or emblem of our sense of ‘Irishness’.\nDefinition:\nunproductive of success"
    },
    {
      id: 198,
      word: "belittle",
      transcription: "bɪˈlɪtl̩",
      translation: "недооцінювати",
      description: "Example:\nthis is not to belittle his role\nSir Henry Royce belittled leisure activities such as golf and tennis.\nDon't belittle his influence\nDefinition:\nDismiss someone or something as unimportant."
    },
    {
      id: 199,
      word: "adverse conditions",
      transcription: "ˈædvɜːs kənˈdɪʃənz",
      translation: "несприятливі умови",
      description: "Example:\nThe expedition was abandoned because of adverse weather conditions.\nThis adversity can be overcome by the willpower of humans.\nDefinition:\nConditions that make it difficult for something to happen or exist."
    },
    {
      id: 200,
      word: "faith in",
      transcription: "feɪθ ɪn",
      translation: "віра в",
      description: "Example:\nShe has no faith in modern medicine.\nYou'll cope - I have great faith in you.\nAfter the trial, his family said they had lost all faith in the judicial system.\nDefinition:\ngreat trust or confidence in something or someone:"
    },
    {
      id: 201,
      word: "career ladder",
      transcription: "kəˈrɪə ˈlædə",
      translation: "кар'єрні сходи",
      description: "Example:\nIf someone has a good work ethic, they should move up the career ladder.\nFor the students involved in building this buggy and countless other items on display at the show, it is a chance to take a step back from a job well done and appreciate the first step on the career ladder.\nSharing the same characteristics as Hannibal Lecter apparently helps some go-getters to shin up the career ladder in the short term, often elevating them to management jobs.\nDefinition:\na series of jobs from the lower paid with less responsibility to the highest paid with the most responsibility within a company or particular profession:"
    },
    {
      id: 202,
      word: "ponder",
      transcription: "ˈpɒndər",
      translation: "Обмірковувати",
      description: "Example:\nThey were left to ponder on the implications of the announcement.\nKate was determined to ponderize her cult's leaders manifesto, fearing further study would destroy her faith.\nHe ponderized the maid in the hay mow with the intensity of a man who's wife could return home at any minute yet with the care due her innocence and age.\nDefinition:\nThink about something carefully, especially before making a decision or reaching a conclusion."
    },
    {
      id: 203,
      word: "give birth",
      transcription: "gɪv bɜːθ",
      translation: "народити",
      description: "Example:\nIt is always terrifying to give birth; how much more so without one's mate there to share the moment?\nFemale reindeer retain their antlers until after they give birth in the spring.\nDoula is a Greek word meaning slave or servant and stems from ancient Greece where the doula was the top-notch home help privileged to help the lady of the house give birth.\nDefinition:\nWhen a woman or female animal gives birth, she produces a baby or young animal from her body."
    },
    {
      id: 204,
      word: "upbringing",
      transcription: "ˈʌpˌbrɪŋɪŋ",
      translation: "виховання",
      description: "Example:\nThat sunny disposition is matched by a remarkably trouble-free upbringing.\nHe experienced a deeply weird upbringing, living with his mother and many stepfathers in a run-down trailer.\nthe peculiarity of their upbringing\nDefinition:\nhelping someone grow up to be an accepted member of the community"
    },
    {
      id: 205,
      word: "idle",
      transcription: "ˈaɪdl̩",
      translation: "непрацюючий",
      description: "Example:\nidle carpenters\nYahoo said Bob had been idle for 10min and 46sec.\nToday I just idle a little bit.\nDefinition:\nnot having a job"
    },
    {
      id: 206,
      word: "instantly",
      transcription: "ˈɪnstəntli",
      translation: "невідкладно",
      description: "Example:\nWe can now communicate instantly with people on the other side of the world.\nIt secured him, instantly, a reputation for boastfulness which was then at odds with his limited achievements.\nHe grinned his approval, smile instantly fading as he spotted something in the sand ahead.\nDefinition:\nAt once; immediately."
    },
    {
      id: 207,
      word: "immortal",
      transcription: "ɪˈmɔːtəl",
      translation: "безсмертний",
      description: 'Example:\nThe priest said he was endangering his immortal soul.\nHe believed himself immortal.\nIn the immortal words of Samuel Goldwyn, "Include me out."\nDefinition:\nliving or lasting forever:'
    },
    {
      id: 208,
      word: "glance",
      transcription: "ɡlæns",
      translation: "швидкий погляд",
      description: "Example:\nThey filed past, meriting hardly a sidelong glance from the fielders.\nHis eyes continually glanced from the girl sitting opposite him to a notebook that lay on his knees .\nEven in the winter of his years, he maintained his slim necktie, suspicious glances, overall decency and a peculiar use of his fedora onstage.\nDefinition:\nTake a brief or hurried look."
    },
    {
      id: 209,
      word: "end up",
      transcription: "end ʌp",
      translation: "докотитися",
      description: "Example:\nThey will end up on the road fatality lists, victims of poor and dangerous roads and unsafe driving.\nThere, a series of thin moves leads you up the remainder of the corner, then you end up facing a traverse to the right under a huge, overhanging roof.\nAnd even if this is all a big hoax or joke and you don't end up playing for Houston, I still hate you.\nDefinition:\nIf someone or something ends up somewhere, they eventually arrive there, usually by accident."
    },
    {
      id: 210,
      word: "dog’s life",
      transcription: "ˈdɑːɡz laɪf",
      translation: "собаче життя",
      description: "Example:\nHe leads a dog’s life.\nDefinition:\na difficult, boring, and unhappy life:"
    },
    {
      id: 211,
      word: "convict",
      transcription: "kənˈvɪkt",
      translation: "засудити",
      description: "Example:\nShe was convicted of theft.\nTwo of the convicts have escaped from prison.\nThe man was convicted of fraud and sentenced\nDefinition:\nto prove or declare (someone) guilty: a person serving a sentence for a crime;"
    },
    {
      id: 212,
      word: "conspiracy",
      transcription: "kənˈspɪrəsi",
      translation: "змова",
      description: "Example:\nShe would have to do some fairly under handed and crafty lying to convince him to leave without revealing the conspiracy.\nHe was in fact working very hard for the forum and continued to throughout the period of the conspiracy.\nIt's not impossible that such a conspiracy is taking place, because there are many sly people who manipulate the dumb citizens for their own benefit.\nDefinition:\na secret agreement between two or more people to perform an unlawful act"
    },
    {
      id: 213,
      word: "assume",
      transcription: "əˈsjuːm",
      translation: "припускати",
      description: "Example:\nShe assumed strange manners\nThe gods assume human or animal form in these fables\nWhen will the new President assume office?\nDefinition:\nSuppose to be the case."
    },
    {
      id: 214,
      word: "ladder",
      transcription: "ˈlædər",
      translation: "сходи",
      description: "Example:\nFinancially he has been struggling for quite a while, and although he will be falling off the property ladder he will have one less millstone around his neck .\nIf you want to become an actor, you'need to get a ladder.\nHey, bring the ladder, I need to climb some skinny stairs!\nDefinition:\nA piece of equipment consisting of a series of bars or steps between two upright lengths of wood."
    },
    {
      id: 215,
      word: "riddle",
      transcription: "ˈrɪdl",
      translation: "загадка",
      description: "Example:\nRiddles and proverbs can influence each other and sometimes a piece of advice in proverb form can be turned into a riddle, or vice versa.\nHis campaign was riddled with accusations and personal attacks\nThe Bonnie & Clyde Car got riddled with bullets from the FBI.\nDefinition:\nA question or statement intentionally phrased so as to require ingenuity in ascertaining its answer or meaning."
    },
    {
      id: 216,
      word: "career",
      transcription: "kəˈrɪər",
      translation: "кар'єра",
      description: "Example:\nHe's hoping for a career in the police force.\nWhen he retires he will be able to look back over a brilliant career.\nI took this new job because I felt that the career prospects were much better.\nDefinition:\nthe job or series of jobs that you do during your working life, especially if you continue to get better jobs and earn more money:"
    },
    {
      id: 217,
      word: "pass away",
      transcription: "pæs əˈweɪ",
      translation: "помирати",
      description: "Example:\nShe's terribly upset because her father passed away last week.\nDefinition:\nDie, disappear, vanish."
    },
    {
      id: 218,
      word: "go overboard",
      transcription: "gəʊ ˈəʊvəbɔːd",
      translation: "повний ентузіазму",
      description: "Example:\nI think people go overboard at Christmas.\nI think I went overboard cooking this dinner – there is enough to feed a dozen people.\nI don't think there'll be more than six people eating, so I wouldn't go overboard with the food.\nDefinition:\nto do something too much, or to be too excited about something:"
    },
    {
      id: 219,
      word: "retirement",
      transcription: "rɪˈtaɪəmənt",
      translation: "Вихід на пенсію",
      description: "Example:\nThe Governor of the prison and another official are to take early retirement.\nretirement like death comes to us all.\nYay im retired time to sleep for the next 15 years.\nDefinition:\nA person's retirement is the period in their life after they have retired."
    },
    {
      id: 220,
      word: "bring up",
      transcription: "brɪŋ ʌp",
      translation: "виховувати",
      description: "Example:\nFind a nice girl and settle down, bring up some children, get a steady job in management.\nFriend: Hey dude, I was having a bad spout last night but I looked up these name definitions, and These name definitions bring my mood up. I needed that.\n\nFriend 2: That's amazing dude!\nDefinition:\nto look after a child and teach them until they are old enough to look after themselves:"
    },
    {
      id: 221,
      word: "nursing home",
      transcription: "ˈnɜː.sɪŋ həum",
      translation: "будинок пристарілих",
      description: "Example:\nMy grandfather had refused to put her in a nursing home and continued to interact with her as if she was a normal person.\nThey thus become nursing homes rather than hospitals , so that many patients cannot be safely discharged to them.\nThe situation in relation to MRSA in nursing homes and hospitals is still under control, however.\nDefinition:\nA nursing home is a private hospital, especially one for old people."
    },
    {
      id: 222,
      word: "adulthood",
      transcription: "ˈædʌlthʊd",
      translation: "зрілий вік",
      description: "Example:\nMy friend: wanna go to the bar and get wasted?\n\nMe: sorry buddy gotta go to work tomorrow and don't wanna be hungover\r\nMy friend: are you trying out this lame thing called adulthood?\nDude1: Whats the sequel to Kidulthood?\n\nDude2: Adulthood you commie! Can't believe you forgot that!\nYou know Steve he finally hit young adulthood.\nDefinition:\nthe period of time in your life after your physical growth has stopped and you are fully developed"
    },
    {
      id: 223,
      word: "upbeat",
      transcription: "ʌpˈbiːt",
      translation: "оптимістичний",
      description: "Example:\nShe was peppy , bouncy, upbeat, and made up in energy and attack what she lacked in finesse.\nI prefer music that is a little more upbeat.\nTreasury Secretary Paulson says he's upbeat about a possible stimulus package. \nDefinition:\nCheerful; optimistic."
    },
    {
      id: 224,
      word: "stuck",
      transcription: "stʌk",
      translation: "той, хто застряг",
      description: "Example:\nUnfortunately we got stuck in a lengthy traffic jam on the way back, and the drive ended up taking us five and a half hours.\nShe put her arm round his neck, touching the side of his cheek and her fingertips stuck to its surface.\nI got stuck in the mother of all traffic jams\nDefinition:\nBe unable to get rid of or escape from."
    },
    {
      id: 225,
      word: "sacred",
      transcription: "ˈseɪkrɪd",
      translation: "священний",
      description: "Example:\nthe plays were performed within the sacred area of Dionysus, in the presence of his priest\nMy recovery from drug~using is Sacred to me, as well to a lesser degree, my family & friends & even sleep!\nI'm sacred of ordering at Starbucks.\r\nWhy are you sacred of big spaces?\nDefinition:\nRegarded with great respect and reverence by a particular religion, group, or individual."
    },
    {
      id: 226,
      word: "painless",
      transcription: "ˈpeɪnləs",
      translation: "безболісний",
      description: "Example:\nThere were men among them who would receive more punishment for their infractions than just the standard, relatively painless hanging .\nThe option to captive offshoring is to outsource to a third party vendor abroad, something that is seen as being more cost effective and in some ways more painless.\nIn its early stages it is symptomless and painless.\nDefinition:\nNot causing or suffering physical pain."
    },
    {
      id: 227,
      word: "mortality",
      transcription: "mɔːˈtælɪti",
      translation: "смертність",
      description: "Example:\nWe investigated mortality in a population of trauma patients who were intubated before reaching hospital without anaesthetic drugs being used.\nHer death made him more aware of his own mortality.\nConsiderably lower mortalities at all temperatures tested were recorded in the pupal stages.\nDefinition:\nThe state of being subject to death."
    },
    {
      id: 228,
      word: "miraculous",
      transcription: "mɪˈrækjələs",
      translation: "надприродний",
      description: "Example:\nHolland's voice is a remarkably supple instrument: her phrasing and the way she sidles up to notes is nearly miraculous.\nKodama is miraculous.\nRae and April always look Miraculous\nDefinition:\nOccurring through divine or supernatural intervention, or manifesting such power."
    },
    {
      id: 229,
      word: "mercy",
      transcription: "ˈmɜːr.si",
      translation: "співчуття",
      description: "Example:\nShe appealed to the judge to have mercy on her husband.\nThe prisoners pleaded for mercy.\nFishermen are always at the mercy of the forces of nature.\nDefinition:\nkindness that makes you forgive someone, usually someone that you have authority over:"
    },
    {
      id: 230,
      word: "legacy",
      transcription: "ˈlegəsi",
      translation: "спадщина",
      description: "Example:\nGrowing up as the legacy of a living legend isn't easy.\nWhile liberation from superstition and autocratic oppression is the great legacy of the Enlightenment, to perpetuate the repression of all spiritual expression in the name of reason is to continue to deny our innate being.\nthis was his legacy\nDefinition:\nA thing handed down by a predecessor."
    },
    {
      id: 231,
      word: "irreversible",
      transcription: "ˌɪrɪˈvɜːsɪbl̩",
      translation: "незворотній",
      description: "Example:\nThese cells then enter a non-dividing state, termed senescence, which can lead to irreversible cell death .\nMalignant cells incubated with nanoshells and exposed to the light source showed signs of irreversible heat damage and cell death, but control cells were left undamaged.\nEnhancement of food flavor and appearance can improve quality of life in patients with irreversible dysfunction.\nDefinition:\nNot able to be undone or altered."
    },
    {
      id: 232,
      word: "hamster",
      transcription: "ˈhæmpstər",
      translation: "хом'як",
      description: "Example:\nShe carefully nestled the hamster into its cage.\nThe hamster bit the child.\nHow do you tell the sex of a hamster?\nDefinition:\na solitary burrowing rodent with a short tail and large cheek:"
    },
    {
      id: 233,
      word: "vehicle",
      transcription: "ˈviː.ə.kəl",
      translation: "засіб пересування",
      description: "Example:\nThis is very different to most aerodynamic designs, which start with the vehicle and then determine the airflow.\nI rode his vehicle last night.\nThose are sweet vehicles where did you get them ?\nDefinition:\nA thing used for transporting people or goods."
    },
    {
      id: 234,
      word: "gluttony",
      transcription: "ˈɡlʌtnɪ",
      translation: "ненаситність",
      description: "Example:\nAlthough Gluttony is one of the Seven Deadly Sins, it is not considered as dangerous as Pride.\ndean grimshaw wants all of the iced buns\nGluttony is a sin.\nDefinition:\neating to excess (personified as one of the deadly sins)"
    },
    {
      id: 235,
      word: "lust",
      transcription: "lʌst",
      translation: "Бажання",
      description: "Example:\nI don't think it's love so much as lust.\nLust for sex has no bounds.\nWhen ever I saw him, all I wanted to do was kiss him, and touch him.  Strange how I never wanted to talk to him.  It must have been lust.\nDefinition:\na very strong sexual desire:"
    },
    {
      id: 236,
      word: "knit",
      transcription: "nɪt",
      translation: "в'язати",
      description: "Example:\nShe's busy knitting baby clothes.\nI knitted Greg a scarf.\nI enjoy knitting my own jumpers.\nDefinition:\nto make clothes, etc. by using two long needles to connect wool or another type of thread into joined rows:"
    },
    {
      id: 237,
      word: "pride",
      transcription: "praɪd",
      translation: "гордість",
      description: "Example:\nAlso known for his almost demonic pride, he produced masterpieces of boastful verses.\nIn love you have patience, kindness, the absence of jealousy, pride and boastfulness .\nHe prides himself on making it into law school\nDefinition:\na feeling of self-respect and personal worth"
    },
    {
      id: 238,
      word: "envy",
      transcription: "ˈenvi",
      translation: "заздрість",
      description: "Example:\nHe didn't want to see her happy so he set up a plan to attempt to bring her unhappiness.\r\n\r\nShe had envy in her heart of the girl who always beat her talent-wise so she set out to make everyone hate her through lies, manipulate measures and deception.\nI envy her she has a sexy boyfriend\nDamn, I wish i had a cool personality/ good looks/nice car like that but since I don't I'll just talk about the person. Must be envy.\nDefinition:\nspite and resentment at seeing the success of another (personified as one of the deadly sins)"
    },
    {
      id: 239,
      word: "sloth",
      transcription: "sləʊθ",
      translation: "лінощі",
      description: "Example:\n“It’s been a tough week at work so I want to spend the weekend slothing”\r\n“I think it’s time you stop watching TV and do something productive. You’ve been slothing all day”\r\n“I think we’ve slothed enough for the day. We should get out and do something”\nSlothnation\n1)\r\nRob: Oh that is so cool!\r\nEmma: Don't you mean that it's sloth?\n\n2)\n\nJoe: I really want to be a sloth!\r\nMike: You're already awesome man!\nDefinition:\napathy and inactivity in the practice of virtue (personified as one of the deadly sins)"
    },
    {
      id: 240,
      word: "bad-mannered",
      transcription: " bæd ˈmænəd",
      translation: "невихований",
      description: "Example:\nWhat other reason can there possibly be for the number of surly, bad-mannered ignoramuses I stumble across when I'm looking to use, order or buy anything?\nMannerism often used today when referring to ones characteristics of 'acting' feminine, butch, or in between.\nLook at that girl with her cooch on the dinner table, she has the most awful manners!\r\n\r\nGood manners include offering your seat to a pregnant woman on the bus. \nDefinition:\nsocially incorrect in behavior"
    },
    {
      id: 241,
      word: "couch potato",
      transcription: "kaʊtʃ pəˈteɪtəʊ",
      translation: "ледар",
      description: "Example:\nHe's turned into a real couch potato since he subscribed to the sports channel.\nHe's turning into a perfect couch potato.\nDefinition:\nsomeone who spends most of their time watching television and does not exercise:"
    },
    {
      id: 242,
      word: "bigoted",
      transcription: "ˈbɪgətɪd",
      translation: "фанатичний",
      description: "Example:\nYour writing was repetitive and clumsy and bigoted, your villains were stereotyped , your characters all wooden, but so what?\nThis was the ugly face of militant Christianity: intolerant, bigoted and hateful .\nThe last council became bigoted against cars and squandered vast amounts of council tax payer's money waging war on them.\nDefinition:\nblindly and obstinately attached to some creed or opinion and intolerant toward others"
    },
    {
      id: 243,
      word: "freckles",
      transcription: "ˈfrɛklz",
      translation: "веснянки",
      description: "Example:\nHe has red hair and freckles.\nThe brothers were in their early teens, and both had reddish hair and freckles.\nShe had wonderful clear skin with an attractive sprinkling of freckles.\nDefinition:\na small patch of light brown color on the skin:"
    },
    {
      id: 244,
      word: "impartial",
      transcription: "ɪmˈpɑ:ʃəl",
      translation: "неупереджений",
      description: "Example:\nIf you understand those principles, if you apply them, you will be impartial and a fair trial will take place.\nThis provides free, independent, impartial and confidential advice to people with debts.\nUnicorn horns and senatorial impartiality do not exist! And I am a bit suspicious of this Tooth Fairy.\nDefinition:\nfree from undue bias or preconceived opinions"
    },
    {
      id: 245,
      word: "breakneck pace",
      transcription: "ˈbreɪknek peɪs",
      translation: "стрімголов",
      description: "Example:\nNeither do I. Tradition is being manufactured at breakneck pace.\nDefinition:\nextremely and often dangerously fast"
    },
    {
      id: 246,
      word: "forgetful",
      transcription: "fəˈgetfəl",
      translation: "забудькуватий",
      description: "Example:\nEven though the card would probably not help catch a single villain, it would criminalise many thousands of absent-minded , forgetful and inefficient people.\nforgetful of her responsibilities\nIn neat testimony to the process, in academic publishing , history has been collapsing into memory, memory into trauma, and trauma into studies of silence and forgetfulness.\nDefinition:\nfailing to keep in mind"
    },
    {
      id: 247,
      word: "know-it-all",
      transcription: "noʊɪtɑːl",
      translation: "всезнайка",
      description: "Example:\nIt was good to share some of my learning with the group, but I was also conscious of not appearing like a know-it-all .\nHe's a bit like the annoying know-it-all that every office has.\nIt was good to share some of my learning with the group, but I was also conscious of not appearing like a know-it-all .\nDefinition:\nA person who behaves as if they know everything."
    },
    {
      id: 248,
      word: "snobbish",
      transcription: "'snɔbɪʃ",
      translation: "зарозумілий",
      description: "Example:\nOkay? I don't. 'Cause she's just as snobbish and selfish and superior as you are.\n‘For your information this little rat insulted me’ Debbie huffed sticking her chin up snobbishly.\nFor the general publishing and pop-culture industries, this has not seemed so much like a heroic or contrarian stance as a stiff and snobbish one.\nDefinition:\nArrogantly superior and disdainful."
    },
    {
      id: 249,
      word: "grayish",
      transcription: "ˈgreɪɪʃ",
      translation: "сіруватий",
      description: "Example:\nThese grayish black mushrooms look like small, delicate, paper-thin , crinkled leaves.\nWhen infected flowers or leaves are plucked, a grayish-white cloud of fungal spores can usually be seen.\nMen and women everywhere hawked government-controlled newspapers printed on a grayish, low-grade newsprint no doubt full of comparably dull propaganda.\nDefinition:\nSlightly gray in color."
    },
    {
      id: 250,
      word: "down-to-earth",
      transcription: "ˌdaʊntuːˈɜːθ",
      translation: "практичний",
      description: "Example:\na down-to-earth view of marriage\nJACK McConnell came across last week, in the course of a lengthy interview, as rational , down-to-earth, pragmatic and fair.\nI would be intelligent, charming, sexy, a huge flirt , with a sense of humour but a down-to-earth guy in touch with his sensitive side.\nDefinition:\nWith no illusions or pretensions; practical and realistic."
    },
    {
      id: 251,
      word: "docile",
      transcription: "ˈdɑːsəl",
      translation: "слухняний",
      description: "Example:\nThe rapid, repetitious beat of the wings seem to have no limit in flexibility or resiliences and give these creatures a docile appearance.\nThe elephant is at once docible and docile. -- C. J. Smith.\nAnd he just stood there the whole time and did nothing.\r\nDocile.\nDefinition:\nReady to accept control or instruction; submissive."
    },
    {
      id: 252,
      word: "disheveled",
      transcription: "dɪˈʃɛvəld",
      translation: "скуйовджений",
      description: "Example:\nher clothing was disheveled\nI spend hours in front of the mirror, making my hair elegantly disheveled.\nHe was in a severely disheveled state after the effects of the cake wore off.\nDefinition:\nin disarray; extremely disorderly"
    },
    {
      id: 253,
      word: "cold fish",
      transcription: "kəʊld fɪʃ",
      translation: "байдужий",
      description: "Example:\nIf German pianists have a reputation for being cold fish , this reputation is belied by playing such as this.\nMack, for such a cold fish , is enthralling, partly because of the shimmer of uncertainty about what is true and what is not.\nhe is generally thought to be a bit of a cold fish\nDefinition:\nUnfriendly and unemotional."
    },
    {
      id: 254,
      word: "chubby",
      transcription: "ˈtʃʌbi",
      translation: "круглолиций",
      description: "Example:\nBefore he could focus on the living room crammed with people, he was pounced on by a short, chubby, buxom woman who hugged him fiercely.\nThe man carrying the knife was much shorter than his accomplice and was described as chubby with a red face.\nThere is barely an ounce of fat on his body, and he continues to make his team-mates look chubby .\nDefinition:\nPlump and rounded."
    },
    {
      id: 255,
      word: "miserable",
      transcription: "ˈmɪzərəbl̩",
      translation: "нещасний",
      description: "Example:\nShe's miserable living on her own.\nI just woke up feeling miserable.\nGeorge 'dubya' Bush is miserable - even a five year old has a higher IQ.\r\n\r\nOther miserable people include Suddam Hussain, Osama Bin Laden, child molesters, and Hitler.\r\n\r\nAlso see sad\nDefinition:\nvery unhappy:"
    },
    {
      id: 256,
      word: "chase",
      transcription: "tʃeɪs",
      translation: "гнатися",
      description: "Example:\nThe film featured several car chase sequences.\nThe share purchase obligates the cooperative to accept the unit at an established price.\nThe lions chased him, and savaged his leg before he fell into a thorn bush too dense for them to reach him.\nDefinition:\nto hurry after someone or something in order to catch him, her, or it:"
    },
    {
      id: 257,
      word: "appetite",
      transcription: "ˈæpɪtaɪt",
      translation: "бажання",
      description: "Example:\nBut it might also whet the public's appetite and be less of a burden on the taxpayer should motorists stubbornly refuse to leave their cars at home.\nStrictly speaking, the pudding, cut in squares, should be served with gravy before the meat, to take the edge off the appetite.\nBut Johnson's latest performance in the red and green of Leicester showed that he still has a ravenous appetite for club rugby.\nDefinition:\na feeling of craving something"
    },
    {
      id: 258,
      word: "appetite",
      transcription: "ˈæpɪtaɪt",
      translation: "апетит",
      description: "Example:\nBut it might also whet the public's appetite and be less of a burden on the taxpayer should motorists stubbornly refuse to leave their cars at home.\nStrictly speaking, the pudding, cut in squares, should be served with gravy before the meat, to take the edge off the appetite.\nBut Johnson's latest performance in the red and green of Leicester showed that he still has a ravenous appetite for club rugby.\nDefinition:\na feeling of craving something"
    },
    {
      id: 259,
      word: "passion",
      transcription: "ˈpæʃən",
      translation: "Захоплення",
      description: "Example:\nAnton has a consuming passion for science fiction.\nDefinition:\nstrong and barely controllable emotion:"
    },
    {
      id: 260,
      word: "passion",
      transcription: "ˈpæʃən",
      translation: "пристрасть",
      description: "Example:\nAnton has a consuming passion for science fiction.\nDefinition:\nstrong and barely controllable emotion:"
    },
    {
      id: 261,
      word: "ridiculous",
      transcription: "rɪˈdɪkjʊləs",
      translation: "cмішний",
      description: "Example:\nHe is, however, also particularly prone to exaggeration, which may make others think of him as ridiculous.\nThe back of your head is ridiculous!\ndressed in ridicuous red and blue/like I don't see what the big deal is \n\n\nDefinition:\nDeserving or inviting derision or mockery; absurd."
    },
    {
      id: 262,
      word: "though",
      transcription: "ðəʊ",
      translation: "хоча",
      description: "Example:\nIts main driver , though, seems to be the attempt to legislate away the problems of a post-colonial country steeped in racism of all kinds.\nhe couldn't face the thought of jumping out of a plane\nHe felt like a schoolboy on a dare , though he admitted he would have been much more afraid had he been a schoolboy at that time.\nDefinition:\nTo add more unecessary words to a sentence....though is not really used for much when coming at the end of an already complete sentence."
    },
    {
      id: 263,
      word: "genuine",
      transcription: "ˈdʒenjuɪn",
      translation: "справжній",
      description: "Example:\nIt's very rare for a sporting biographer to have simultaneously a genuine intimacy with their subject and the latitude to call a life as they see it.\nGenuine is real- Big L\nStrength. Intellect. Style. Genuine.\nDefinition:\nTruly what something is said to be; authentic."
    },
    {
      id: 264,
      word: "irritated",
      transcription: "ˈɪrɪteɪtɪd",
      translation: "роздратований",
      description: "Example:\nShe asked hopefully in a sweet tone though she was irritated by the man she had just taken an order from.\nmade an irritated gesture\nDefinition:\nShowing or feeling slight anger; annoyed."
    },
    {
      id: 265,
      word: "reigning",
      transcription: "ˈreɪnɪŋ",
      translation: "головний",
      description: "Example:\nThe event attracts a large entry of international teams, including South Africa, the reigning champions, New Zealand, Canada, Zimbabwe, and Japan.\nthe reigning world champion\nHe turned professional two years ago after reigning as Britain's amateur champion for four years from 1998 to 2002.\nDefinition:\nexercising power or authority"
    },
    {
      id: 266,
      word: "fittingly",
      transcription: "ˈfɪtɪŋ",
      translation: "підходяще",
      description: "Definition:\n"
    },
    {
      id: 267,
      word: "grow dark",
      transcription: "grəʊ dɑːk",
      translation: "Темнішати",
      description: "Definition:\nnull"
    },
    {
      id: 268,
      word: "trustworthy",
      transcription: "ˈtrʌstˌwɜːði",
      translation: "заслуговуючий довіри",
      description: "Example:\nProper behavior means to be loyal, filially pious respectful and trustworthy.\neveryone needs a sabrina the trustworthy\nI think she is a very trustworthy friend.\nDefinition:\nable to be relied on as honest or truthful:"
    },
    {
      id: 269,
      word: "sneaky",
      transcription: "ˈsniːki",
      translation: "підлий",
      description: "Example:\nIt's a sneaky way of getting people to buy something they don't need.\nIt was a bit sneaky of him to tell the teacher about me.\n\n\n\n\n\nI pulled me a couple sneaky's last night.\nDefinition:\nmarked by deception"
    },
    {
      id: 270,
      word: "spiky hair",
      transcription: "ˈspaɪki heər",
      translation: "колюче волосся",
      description: "Example:\nPatrick has black spiky hair and wears a beaded necklace around his neck.\nHe yawned boorishly and stretched his arms above his head of crimson spiky hair, leaning backwards for some emphasis of his boredom.\nA year or so ago, he was asked to advise a man who suffered from spiky hair at the crown of his head.\nDefinition:\nHair style in which the hair is made to point in many different directions."
    },
    {
      id: 271,
      word: "smug",
      transcription: "smʌg",
      translation: "самовдоволений",
      description: "Example:\nHe's been unbearably smug since he gave up smoking.\nIf this is the worst trouble we see all tournament, I shall have to fight the feelings of smugness very hard indeedy.\nThe inspection is aimed at helping curb smuggling and undervaluation practices and to nab corrupt customs officials.\nDefinition:\nToo pleased with your skill or success in a way that annoys other people."
    },
    {
      id: 272,
      word: "womanizer",
      transcription: "ˈwʊmənaɪzər",
      translation: "бабій",
      description: "Example:\nI've heard lots of stories about how he's such a ladies' man and womanizer.\nI've heard lots of stories about how he's such a ladies' man and womanizer.\nWorld famous, he is also a great womanizer, acknowledged as such by his colleagues, wife, and friends who themselves enjoy an entertainingly licentious social and sexual life.\nDefinition:\nA man who engages in numerous casual sexual affairs with women."
    },
    {
      id: 273,
      word: "whiz kid",
      transcription: "wɪz kɪd",
      translation: "вундеркінд",
      description: "Example:\na computer whiz kid\nwhiz kid- Engineering and mathematical genius vijayaratnam showed his promise as a top student in the school as well as managing his father's shop at the age of 9\nYo whiz kid, come over and help me with my chemistry.\nDefinition:\nA young person who is outstandingly skillful or successful at something."
    },
    {
      id: 274,
      word: "two-faced",
      transcription: "ˌtuːˈfeɪst",
      translation: "дволикий, лицемірний",
      description: "Example:\nThe car is a two-faced modern symbol: a shiny icon of our freedom and our entrapment.\nAdmittedly the horse is blind, half lame and being whipped by a lying two-faced jockey, but even dead on its feet it still looks like a safer bet than the alternative nags .\nDefinition:\ninsincere and deceitful:"
    },
    {
      id: 275,
      word: "touchy",
      transcription: "ˈtʌtʃi",
      translation: "образливий",
      description: "Example:\nThe city, hoping to stave off a touchy situation, tested the water, which turned out to be harmless.\nNow that the national has gone from relaxed and comfortable to alert but not alarmed, everyone's a little touchy about who might be up to no good.\nBy acquiescing to both England and Germany through the Iberian Indecision, France completely avoids this touchy issue.\nDefinition:\nEasily upset or offended; oversensitive."
    },
    {
      id: 276,
      word: "thick-skinned",
      transcription: "ˌθɪkˈskɪnd",
      translation: "байдужий",
      description: "Example:\nHis loud, belligerent, thick-skinned exterior has always encased a much more emotional inner centre.\nThick-skinned, he fails to heed their hints about getting a replacement, even when they turn up at his house with Tom, a hot young guitar prodigy .\nSo, you just have to be a bit thick-skinned about it and keep going.\nDefinition:\nInsensitive to criticism or insults."
    },
    {
      id: 277,
      word: "simpleton",
      transcription: "ˈsɪmpl̩tən",
      translation: "простак",
      description: "Example:\nHis malapropisms and good old boy manner give him the air of a simpleton, and yet he's not.\nmichelle everest, simpleton\nYou simpletons get off my lawn mower!\nDefinition:\nA foolish or gullible person."
    },
    {
      id: 278,
      word: "humble",
      transcription: "'hʌmbl",
      translation: "скромний",
      description: "Example:\nThis last comment is typical of the band's humble attitude to everything that's happened to them.\nB1zzle is the most humble being on the planet.\nof humble (or lowly) birth\nDefinition:\nNot claiming attention for oneself; retiring and modest."
    },
    {
      id: 279,
      word: "pushy",
      transcription: "ˈpʊʃi",
      translation: "безцеремонний",
      description: "Example:\nBT has introduced new privacy measures to protect punters from annoying phone calls from pushy salespeople.\nThe Tibetans I spoke to were infectiously humble and friendly and politically charged without being pushy about independence after the Chinese invaded.\nAccustomed to yelling at recalcitrant dogs and pushy hunt followers , Ferry exudes authority and self-possession.\nDefinition:\nmarked by aggressive ambition and energy and initiative"
    },
    {
      id: 280,
      word: "pimply",
      transcription: "ˈpɪmpl̩i",
      translation: "прищавий",
      description: "Example:\nWhen you feel bloated, cranky, pimply and crampy on a monthly basis, it's tough to be all that grateful.\nArms and legs are getting goosepimply and lonely sweaters now have companions.\nSurveying the pimply punks pulling wheelies in the rain, Streb sighs.\nDefinition:\nA person who has a lot of pimples on a face."
    },
    {
      id: 281,
      word: "oddball",
      transcription: "ˈɑːdbɔːl",
      translation: "дивак",
      description: "Example:\nYou wanted to tell her to stop trying so hard, because she's stomping all over whatever organic oddball qualities she's got.\nAnd there is always one oddball who creates endless entertainment for everyone else.\nEverything that makes him such a charming, slightly oddball singer remains, not least in the lovably mundane lyrics.\nDefinition:\nA strange or eccentric person."
    },
    {
      id: 282,
      word: "neglect",
      transcription: "nɪˈglekt",
      translation: "нехтувати",
      description: "Example:\nThe scheme will help to address the increasing problems of dereliction and neglect in many rural towns because of rising levels of migration away from rural town areas.\nTheft from a major museum need not necessarily imply neglect or faulty security systems.\nProper grounds for putting children into care are such things as cruelty, neglect or incapacity on the part of the parents, or because the children are orphans .\nDefinition:\nnot pay proper attention to; disregard:"
    },
    {
      id: 283,
      word: "billion",
      transcription: "ˈbɪljən",
      translation: "мільярд",
      description: "Example:\nNumber of pink pounds in their income: 60 billion, according to Barclays Bank.\nYour main defense against them is billions of acidophilus bacteria, your ‘good’ intestinal flora.\nThe millions turned to billions as the technology firm became a member of the prestigious FTSE 100, the ultimate accolade in the business community.\nDefinition:\nthe number that is represented as a one followed by 9 zeros"
    },
    {
      id: 284,
      word: "wealth",
      transcription: "welθ",
      translation: "багатство",
      description: "Example:\nHis wealth is so great that money doesn’t mean much to him.\nAppalling poverty and great wealth coexist in the city.\nDuring a successful business career, she accumulated a great amount of wealth.\nDefinition:\na large amount of money or valuable possessions that someone has:"
    },
    {
      id: 285,
      word: "peer",
      transcription: "pɪər",
      translation: "ровесник",
      description: "Example:\n\nDefinition:\nA person of the same age."
    },
    {
      id: 286,
      word: "seaside",
      transcription: "ðəˈsiːsaɪd",
      translation: "узбережжя",
      description: "Example:\nLet's go to the seaside at the weekend!\nSummers were spent at the seaside.\nHe moved to the seaside for the sake of his health.\nDefinition:\nthe area near the sea, especially where people spend their holidays and enjoy themselves:"
    },
    {
      id: 287,
      word: "unexpectedly",
      transcription: "ˌʌnɪkˈspektɪdli",
      translation: "несподівано",
      description: "Example:\nIt's a small, sleepy place, peopled by fishing folk and farmers, but there are memories of past glories in the unexpectedly imposing church.\nHe still remembers the day when a deer unexpectedly attacked a former zoo official, seriously wounding him in the arm.\nUnexpectedly, Damien dropped the ladle and grabbed the bowl from my hands, setting it down on the table.\nDefinition:\nWithout advance planning."
    },
    {
      id: 288,
      word: "cause dismay",
      transcription: "kɔːz dɪˈsmeɪ",
      translation: "збентежувати",
      description: "Example:\nThere is a large, a large and popular business which you are causing dismay.\nHe caused dismay within Germany and outrage beyond.\nThis caused dismay for club members. \nDefinition:\nTo cause a feeling of despair in the face of obstacles."
    },
    {
      id: 289,
      word: "ease",
      transcription: "iːz",
      translation: "полегшувати",
      description: "Example:\nI gave him some brandy to ease the pain.\nHe passed his exam with ease.\nThe driver eased off as he approached the town.\nDefinition:\n(often with off) to make or become less strong, less severe, less fast ease:"
    },
    {
      id: 290,
      word: "brainwashed",
      transcription: "ˈbreɪn.wɒʃ",
      translation: "з промитими мізками",
      description: 'Example:\nThe youngest boy had the unreasonable zeal of a brainwashed psychopath.\nAs a susceptible child, I was brainwashed into believing that was true.\nAnd before any brainwashed zombie starts screaming that I am trivialising rape, it is this very situation which is doing so.\nDefinition:\n subjected to intensive forced indoctrination resulting in the rejection of old beliefs and acceptance of new ones,brainwashed prisoners of war", captive audiences for TV commercials can become brainwashed consumers'
    },
    {
      id: 291,
      word: "brainstorming",
      transcription: "ˈbreɪnˌstɔːmɪŋ",
      translation: "мозковий штурм",
      description: "Example:\nI collaborated with a music video director, brainstorming for storylines and visuals to go with songs.\nThe search engine relies on its own brainstorming list to keep innovation at the top of the firm's agenda, its co-founders said.\nIt ended as a brainstorming session with tourism officials about a nonstop flight.\nDefinition:\nan activity or business method in which a group of people meet to suggest a lot of new ideas for possible development:"
    },
    {
      id: 292,
      word: "heroically",
      transcription: "hɪˈrəʊɪkli",
      translation: "героїчно",
      description: "Example:\nRomantic notions of serving his country and fighting heroically intoxicated him.\nA new mural on the outside wall of the town hall depicts, in raw Forties naturalist style, a German soldier heroically protecting his womenfolk .\nPre-Christian warriors hoped to meet a quick, short death, hopefully heroically in battle.\nDefinition:\nIf you describe a person or their actions as heroic, you admire them because they show extreme bravery."
    },
    {
      id: 293,
      word: "rely on",
      transcription: "rɪˈlaɪ ɒn",
      translation: "покладатися на",
      description: "Example:\nThough natural history does not privilege the individual moment of perception in quite the way that romanticism does, it does rely on a process of imaginative synthesis.\nOther situations which rely on a different style of leadership and a different style of direction and control have to be accepted as well.\nThis process of using observation and experiment to refute false theories does not rely on induction in any way.\nDefinition:\nBe dependent on."
    },
    {
      id: 294,
      word: "frantically",
      transcription: "ˈfræntɪkli",
      translation: "несамовито",
      description: "Example:\nBy this time, throngs of shoppers had gathered around us to watch the commotion and were whispering frantically.\nShe's prone to frequent bouts of franticity I'm afraid, as is typical of high-strung girls like her. \nEliza: why are you running down the stairs so frantically\r\nAqeela: because I'm mad.\n\nOr\r\nEliza: Why are you riding your bike so frantically\r\nAqeela: because I'm mad and I'm trying to get home fast.\nDefinition:\nIn a hurried, excited, or disorganized manner."
    },
    {
      id: 295,
      word: "fly open",
      transcription: "flaɪ ˈoʊpən",
      translation: "розкритися",
      description: "Example:\nMy eyes suddenly fly open and my mouth widens and my back arches off the ground.\nConcealed doors and traps tend to fly open unexpectedly like windows on an Advent calendar .\nIn the taxi, the couple began open fly fishing!\nDefinition:\nOpened wide."
    },
    {
      id: 296,
      word: "figure out",
      transcription: "fɪɡjəraʊt",
      translation: "розібратися",
      description: "Example:\nBaby, you know I've figured out your spice cabinet!\nWhy does everything concerning the subject of love have to be so impossible to figure out?\nThough a stranger in a strange land, Maria is quick-witted , intelligent, and empathetic enough to figure out how to deal with the various characters she comes across.\nDefinition:\nSolve or discover the cause of a problem."
    },
    {
      id: 297,
      word: "excitedly",
      transcription: "ɪkˈsaɪtɪdli",
      translation: "схвильовано",
      description: "Example:\nFurther annoyances included his twitchy foot which he kept pounding excitedly against the floor next to my foot, and occasionally on top of it.\nshe shook his hand excitedly\nDefinition:\nIn a very enthusiastic and eager manner."
    },
    {
      id: 298,
      word: "brainy",
      transcription: "ˈbreɪni",
      translation: "мозковитий",
      description: "Example:\nHe was brainy , he attended all extra-curricular activities that involved intelligence and he wore his hair gelled.\nour project needs brainy women\ndefinition 2: Check out all the brainies on that dude's forehead...talk about a prime candidate for a facelift!\nDefinition:\nHaving or showing intelligence."
    },
    {
      id: 299,
      word: "brainwave",
      transcription: "ˈbreɪnweɪv",
      translation: "блискуча ідея",
      description: "Example:\nThen I had a brainwave - who said that bald isn't beautiful?\nIt's fun when you get a brainwave,especially if you get to use it.\nHow are you Daniel?\r\nBrainwaving.\r\nBoss?\r\nBraindead.\nDefinition:\nA sudden clever idea."
    },
    {
      id: 300,
      word: "brainless",
      transcription: "ˈbreɪnləs",
      translation: "безмозкий",
      description: "Example:\nThe blonde grinned and her friends kept nodding like brainless bobble-heads .\nThat was a brainless thing to do!\nSome of the more brainless critics of the free market system allege that it is about the law of the jungle.\nDefinition:\nStupid; foolish."
    },
    {
      id: 301,
      word: "bizarre",
      transcription: "bɪˈzɑːr",
      translation: "химерний",
      description: "Example:\nAs always, what strikes one about French farce is its mix of mathematical precision and bizarre detail.\nBy any bizarre twist of fate, would you go out with me?\nthe three-head-monkey is really bizarre\nDefinition:\nVery strange or unusual, especially so as to cause interest or amusement."
    },
    {
      id: 302,
      word: "wallow",
      transcription: "ˈwɒləʊ",
      translation: "купатися",
      description: "Example:\nLike most front-men, he had an ego that could swallow the battered planet, and didn't want any lip from the troops.\nThey hardly chew their food when first eaten, but swallow it into a special stomach where the food is partially digested.\nIn a swallow, the tongue presses the bolus into the pharynx.\nDefinition:\nrise up as if in waves"
    },
    {
      id: 303,
      word: "drawing room",
      transcription: "ˈdrɔ:ɪŋ ru:m",
      translation: "вітальня",
      description: "Example:\nAt midnight , with no sign of Sandy, we left some sandwiches in the drawing room and went to bed.\nAs well as four bedrooms , the house has a drawing room, dining room, kitchen and a study.\nThe rectangular building has a corridor running from the entrance hallway with double doors to the drawing room.\nDefinition:\nUsed to define any quantity of Cannibis"
    },
    {
      id: 304,
      word: "acquaintance",
      transcription: "əˈkweɪn.təns",
      translation: "знайомий",
      description: "Example:\nAs soon as the statement was issued to the press, however, anyone enjoying even the slightest acquaintance with the player recognised that the words were not his.\nI made acquaintance with this man's writing when I was eighteen, or maybe nineteen .\nTwo lovable rogues are discussing a mutual acquaintance who has just been released from prison.\nDefinition:\nslight knowledge of or friendship with someone:"
    },
    {
      id: 305,
      word: "cast",
      transcription: "kæst",
      translation: "знімальна група",
      description: "Example:\nIn forty-eight of the fifty states the Electoral College votes cast by each state towards the election of the President are by tradition delivered as a bloc vote .\nWith its blue-eyed, blonde haired leads, does the film cast a slight Aryan look?\nMychael found herself in a tall tower - one of many in the castle.\nDefinition:\nThe actors taking part in a play, film, or other production."
    },
    {
      id: 306,
      word: "adolescence",
      transcription: "ˌædəˈlesənts",
      translation: "підлітковий вік",
      description: "Example:\nAt eighteen years old, she was still fresh from adolescence and stinging from the abrupt end of an eight month relationship.\nHeadaches are common during childhood and become more common and increase in frequency during adolescence.\nThere's evidence to suggest that temper tantrums, other emotional outbursts , and grunts and groans aren't a natural part of adolescence, but are actually an accentuation of a young person's personality.\nDefinition:\nin the state that someone is in between puberty and adulthood"
    },
    {
      id: 307,
      word: "dismay",
      transcription: "dɪˈsmeɪ",
      translation: "тривога",
      description: "Example:\nI was going to get Sandy something, but when I got to the florist I got a case of 'Valentine's Dismay' How can they charge that much?\nHe was quite dismayed when I told him, as apparently his group had thought they were neighbourless .\nLast night , some parents said they were dismayed at the latest hike in fees which far outweighs yearly salary rises.\nDefinition:\nCause someone to feel consternation and distress."
    },
    {
      id: 308,
      word: "superficial",
      transcription: "ˌsuːpəˈfɪʃəl",
      translation: "поверхневий",
      description: "Example:\nAnyone with even the most superficial acquaintance with the history of the French revolution will know what that means, in nine cases out of ten.\nPlato describes him as a vain man being both arrogant and boastful , having a wide but superficial knowledge.\nDefinition:\nExisting or occurring at or on the surface."
    },
    {
      id: 309,
      word: "chat",
      transcription: "tʃæt",
      translation: "теревенити",
      description: "Example:\nIt was just a chat.\nMy partner and I had parked on the shoulder of the highway and began to chat.\nWill and his team sit and chat, or just listen, meeting needs and helping wherever they can.\nDefinition:\nto talk in a friendly and informal way:"
    },
    {
      id: 310,
      word: "tepid",
      transcription: "ˈtepɪd",
      translation: "тепленький",
      description: "Example:\nLack of energy and a dearth of hooks adds up to one of the most tepid releases Matthews and his crew have released.\nMuch to Susan's chagrin when she saw Ben's ample scrotum she knew tonight's menu included anal play with a side of tepid oysters.\nThere were no crumpets to be had, and the hot buttered muffins were tepid and rubbery.\nDefinition:\nmoderately warm"
    },
    {
      id: 311,
      word: "babysitter",
      transcription: "ˈbeɪbiˌsɪtər",
      translation: "няня",
      description: "Example:\nSo there have been films with killer babysitters, killer roommates, killer mothers-in-law , killer husbands, etc.\nThey spoke Norwegian and French respectively to the children; English to each other and Bulgarian with the home help and babysitter.\ndon't hire a babysitter who's under 16\nDefinition:\na person engaged to care for children when the parents are not home"
    },
    {
      id: 312,
      word: "turn over",
      transcription: "tə:n ˈəuvə",
      translation: "перевертати",
      description: "Example:\nI use a stick to gingerly push aside the stalks and turn over the debris, picking out the dull sheen of a slug here, the progress of a tiny worm there.\nBrown the meat on one side, then turn it over and brown the other side.\nAnts, beetles , and termites turn over soil and wood.\nDefinition:\nto make something change position so that the other side is facing towards the outside or the top"
    },
    {
      id: 313,
      word: "abruptly",
      transcription: "əˈbrʌptli",
      translation: "різко",
      description: "Example:\nAbruptly, he pushes forward on the joystick again and the glider drops.\nAn abrupt change in the weather.\n\n2. Surprisingly curt; brusque: an abruptly answer made in anger.\n\n3. Touching on one subject after another with sudden transitions: abrupt prose.\n\n4. Steeply inclined. See Synonyms at steep1.\n\n5. Botany Terminating suddenly rather than gradually; truncate: an abruptly leaf.\nI had a boringly respectable career as an actor, you know, but at the age of 30 I just stopped very, very abruptly and it was fine, and I haven't acted since.\nDefinition:\nSuddenly and unexpectedly."
    },
    {
      id: 314,
      word: "slam",
      transcription: "slæm",
      translation: "грюкнути",
      description: "Example:\nRay slammed the door shut.\nLooking to slam. Come on over, we're already slammed. We're slamming now, get over here. We slammed and were up all night partying last week-end.\nHe quit smoking rock, he just slams coke now\nDefinition:\nTo move against a hard surface with force and usually a loud noise, or to cause something to move this way."
    },
    {
      id: 315,
      word: "relief",
      transcription: "rɪˈliːf",
      translation: "полегшення",
      description: "Example:\nMuch of Northern Taiwan breathed a sigh of relief yesterday as heavy rains fell around the country yesterday evening.\nDr. Krishnaswamy said external application of herbs or applying betel leaf over the baby's stomach when it suffered from colic could bring some relief.\nGwen now giddy with relief almost forgot about Keily.\nDefinition:\nthe feeling that comes when something burdensome is removed or reduced:"
    },
    {
      id: 316,
      word: "patiently",
      transcription: "ˈpeɪʃəntli",
      translation: "терпляче",
      description: "Example:\nHe is not aggressive, he doesn't scrub with fury; he simply and patiently removes every fleck, all evidence, of imperfection .\nShe seemed not to see the nurse sitting and waiting patiently for her to finish.\nIn the first instance, a child is patiently attempting to trace letters in a book.\nDefinition:\nWaiting without becoming annoyed or anxious."
    },
    {
      id: 317,
      word: "count on",
      transcription: "̘.kaunt ɔn",
      translation: "розраховувати на",
      description: "Example:\nYou can count on me.\nCarol had to get two strikes and a good count on her fill ball in the 10th frame to win the tournament.\nMore than just reading skills are impaired, you can count on it.\nDefinition:\nto be confident that you can depend on smth:"
    },
    {
      id: 318,
      word: "turn up",
      transcription: "tɜːn ʌp",
      translation: "з'являтися",
      description: "Example:\nI turned the volume up.\nRichard had turned up on Christmas Eve with Tony.\nA sensitive ear for voicing is needed to project the songful melodies effectively wherever they turn up in the texture.\nToday very nearly featured a mercy mission to the local hospital, until the patient in question had the nerve to be discharged before Lisa and I could turn up with the grapes.\nDefinition:\nin the sense of increase; to arrive or appear; "
    },
    {
      id: 319,
      word: "turn into",
      transcription: "tɜːrn ˈɪntuː",
      translation: "перевтілюватися",
      description: "Example:\nA nice little puppy can turn into a hellhound over night and kill the mailman.\nOn the 5th February 1918 the convoy steamed towards the west coast of Scotland and began to turn into the North Channel.\nForecasters predict the winds will ease later today and the heavy rains will turn into squally showers.\nDefinition:\nBecome a particular kind of thing or person; be transformed into."
    },
    {
      id: 320,
      word: "turn around",
      transcription: "tɜːrn əˈraʊnd",
      translation: "повертатися",
      description: "Example:\nIn truth there was no cause for rejoicing , nor need to turn around, either.\nI hear the squeak of his boots and when I turn around, he is standing at attention .\nJuliano would turn around and there would be Petty, looking at him with a sly grin that said, ‘I got you again.’\nDefinition:\nto change position or direction so as to face the other way:"
    },
    {
      id: 321,
      word: "touch base",
      transcription: "tʌtʃ beɪs",
      translation: "переговорити",
      description: "Example:\nTouch base with your friend after the date as a courtesy .\nHey tom do you want to meet up behind the admin building and touch base.\nSo go ahead, call your best friend to make weekend plans or touch base with a client on the other side of the world and talk for as long as you like.\nDefinition:\nBriefly make or renew contact with someone."
    },
    {
      id: 322,
      word: "think over",
      transcription: "θɪŋk ˈoʊvər",
      translation: "обміркувати",
      description: "Example:\nAnd I think over the long haul, if he hews to the middle-ground course that he has taken over the last 14 days that we'll do pretty well.\nHe gave her a month's respite , to think over and accede.\nBut if we're wrong, we'll have a rethink over where we place the articles.\nDefinition:\nConsider something carefully."
    },
    {
      id: 323,
      word: "stand by",
      transcription: "stænd baɪ",
      translation: "підтримувати",
      description: "Example:\nI wouldn't break the law for a friend, but I would stand by her if she did.\nCabin crew, please stand by for take-off.\nWe can't stand by while millions of people starve.\nDefinition:\nSupport or remain loyal to someone, typically in a time of need."
    },
    {
      id: 324,
      word: "spring up",
      transcription: "sprɪŋ ʌp",
      translation: "виникнути",
      description: "Example:\nWe can define a bubble as activities that spring up on the back of loose monetary policy of the central bank .\nIn the towns, cities and tourist centres, the plastic bag problem has become a plague ; and attempts to cure it have begun to spring up.\nAcross the fields and hills, old stone cottages are crumbling into mossy graves while canary-yellow and pastel-pink Southfork-style houses spring up, with vast front lawns and inventive stone cladding.\nDefinition:\nsuddenly appear or begin to exist:"
    },
    {
      id: 325,
      word: "reluctantly",
      transcription: "rɪˈlʌktəntli",
      translation: "неохоче",
      description: "Example:\nThen folding the map away, he instructed her to start driving again and Andrea reluctantly acquiesced .\nWe had set out reluctantly on a Friday evening at the end of a hard working week through a wintry countryside glittering with frost and wreathed in freezing mist.\nAt the centre of the story is the feisty Elizabeth and the conceited Darcy, who initially cannot stand each other but reluctantly fall in love.\nDefinition:\nIn an unwilling and hesitant way."
    },
    {
      id: 326,
      word: "get along",
      transcription: "get əˈlɒŋ",
      translation: "ладнати",
      description: "Example:\nEven though he and I didn't get along, I definitely did those things in order to placate the family.\nHe was a bear to get along with sometimes, and temperamental as the very devil, but underneath it all he was really a good man and a great man.\nThe two of us mothers were not sure if my boy kid and her girl kid would get along and go sledding while we skied, but we risked it.\nDefinition:\nHave a harmonious or friendly relationship."
    },
    {
      id: 327,
      word: "spoil",
      transcription: "spɔɪl",
      translation: "псувати",
      description: "Example:\nMost of them appreciate it but unfortunately a small minority seem determined to spoil things for the rest.\nI think I'll spoil myself tonight.\nDefinition:\nto treat with great or excessive kindness, consideration, or generosity:"
    },
    {
      id: 328,
      word: "speaker",
      transcription: "ˈspiːkər",
      translation: "колонка",
      description: "Example:\nSound can be produced from the internal computer speaker or a sound cord.\nKarl Lagerfeld, dressed in knee-high crocodile boots and a leather choker, was one of the speakers.\nThe music was too loud and I'd been stupid enough to choose to sit right under the one of the wall-mounted speakers.\nDefinition:\na piece of electrical equipment, for example, part of a radio or set of equipment for playing CDs or tapes, through which sound comes out:"
    },
    {
      id: 329,
      word: "make a killing",
      transcription: "meɪk ə ˈkɪlɪŋ",
      translation: "зірвати куш",
      description: "Definition:\nnull"
    },
    {
      id: 330,
      word: "be on welfare",
      transcription: "biː ɒn ˈwelfeər",
      translation: "отримувати допомогу",
      description: "Definition:\nnull"
    },
    {
      id: 331,
      word: "get laid off",
      transcription: "get leɪd ɒf",
      translation: "потрапити під скорочення",
      description: "Example:\nI'm scared I'm gonna get laid off.\nAfter the company faced financial difficulties, several employees had to get laid off as part of the downsizing process.\nDespite her dedication to the job, Sarah unexpectedly found herself getting laid off due to corporate restructuring.\nDefinition:\nForcing someone and being forced to leave a job."
    },
    {
      id: 332,
      word: "get fired",
      transcription: "get faɪər",
      translation: "бути звільненим",
      description: "Example:\nIf you spend, borrow, set up a business, hire someone or get fired, these are actions that matter.\nDamn this food is fire.\r\nThat girl is looking fire.\r\nthis new game is fire.\nHoney, I haev terrible news. I've just been fired!\r\n\r\nDude, he just got the boot.\r\n\r\nMy friend just got terminated.\r\n\r\nWhen do you think he'll get canned?\nDefinition:\nGetting fired means that an employer terminates employment against the will of the worker."
    },
    {
      id: 333,
      word: "be behind schedule",
      transcription: "biː bɪˈhaɪnd ˈʃedjuːl",
      translation: "вибиватися з графіка",
      description: "Example:\nThe cancellation came after the project was millions of dollars over budget and months behind schedule.\nNicole wants me to go with her to see some chick flick on Saturday night. It's all one big schedule with her.\nThe five-oh came a'runnin' to pick up dem hoppers slangin' on the corners, but dey stopped me, and I had'a'had a little schedule  in my pocket I forgot about.\nDefinition:\nmoving slower or happening later than the planned time:"
    },
    {
      id: 334,
      word: "breach of contract",
      transcription: "briːtʃ əv ˈkɒntrækt",
      translation: "порушення контракту",
      description: "Example:\nIt is counterclaiming for $25,000 in damages for breach of contract.\nReeve and Lawrence counterclaimed for damages for breach of contract by failure to meet the temperature and flow rate criteria for the supply of cool water.\nHe counterclaimed for damages for misrepresentation and breach of contract of employment.\nDefinition:\nAn act of breaking the terms set out in a contract."
    },
    {
      id: 335,
      word: "binding agreement",
      transcription: "ˈbaɪndɪŋ əˈgriːmənt",
      translation: "обов'язкова для всіх сторін угода",
      description: "Example:\nThis seems to me to be inconsistent with a contention that a binding agreement for a joint venture survived.\nPerkel ended up calling the sales department instead, where a representative informed him that the license was not, in fact, a binding agreement.\nDefinition:\nBinding agreements, which are legal contracts, can be enforced under laws at both the federal and state levels."
    },
    {
      id: 336,
      word: "be on schedule",
      transcription: "biː ɒn ˈʃedjuːl",
      translation: "йти за планом",
      description: "Example:\nWhat's status of the project? Are you all still on schedule?\nMary: Hey Bob! Can you do happy hour on Wednesday? \r\nBob: Sorry. No can do. I have a bad case of schedulitis.\nWe need to speak to the rest of the family so we can schedulate the reunion.\nDefinition:\nAt the expected or desired time."
    },
    {
      id: 337,
      word: "end-user",
      transcription: " end ˈjuːzər",
      translation: "кінцевий споживач",
      description: "Example:\nA B2B site deals primarily with other businesses, not the general public, a B2C site sells directly to the end user.\nAs online marketers we are, of course, aware of the rise in use of software that blocks advertisements on an end-user 's desktop.\nManufacturers will be held responsible for the reclamation and recycling of old computers, with end-users incurring no extra cost.\nDefinition:\nThe person who actually uses a particular product."
    },
    {
      id: 338,
      word: "draw up",
      transcription: "drɔː ʌp",
      translation: "Складати",
      description: "Example:\nYou can draw up your own will - you can even download forms from the internet, or buy a form from a stationers .\nFinally, they worked alongside a contractor, plumber and electrician to draw up plans for the new facility, including a store and a creamery .\nYou can draw up your own will - you can even download forms from the internet, or buy a form from a stationers .\nDefinition:\nPrepare a draft of a legal document."
    },
    {
      id: 339,
      word: "disclose",
      transcription: "dɪsˈkloʊz",
      translation: "розкривати",
      description: "Example:\nHe's presumably fully conversant with the principals behind conflict of interests and the reasons why you disclose.\nThe curtain rose to disclose a stunning set\nThe auction house would not disclose the price at which the van Gogh had sold\nDefinition:\nMake secret or new information known."
    },
    {
      id: 340,
      word: "deadline",
      transcription: "ˈdedlaɪn",
      translation: "кінцевий термін",
      description: "Example:\nMany residents only found out about this planning application six days before the original deadline of January 12.\nshe handed the thesis in just before the deadline\nChrist, it's the nearly deadline already?!  Hey Pete, put down the controller my friend - it's time that we looked at these shuttle schematics.\nDefinition:\nThe latest time or date by which something should be completed."
    },
    {
      id: 341,
      word: "conduct",
      transcription: "kənˈdʌkt",
      translation: "керувати",
      description: "Example:\nWe will now conduct the ceremony for the adoption and proclamation of a written resolution by the representatives of the five great religions.\nhe had failed to advert to the consequences that his conduct was having\nThe memory cell includes an access transistor formed in a pillar of single crystal semiconductor material.\nDefinition:\nLead or guide someone to or around a particular place."
    },
    {
      id: 342,
      word: "boil over",
      transcription: "bɔɪl ˈoʊvər",
      translation: "вийти з-під контролю",
      description: "Example:\nThings boil over, the father moves on.\nThen cut into thin pieces; boil over low heat in water with 20g corn silk , and season with salt.\nBring to a boil over medium-high heat, skim off any surface scum, and add onion, garlic, and bay leaf.\nDefinition:\nReach a state of such intensity that it can no longer be controlled or contained."
    },
    {
      id: 343,
      word: "big shot",
      transcription: "bɪg ʃɑːt",
      translation: "важлива персона",
      description: "Example:\nAs the P.A.'s clerk, I was some sort of a big shot myself; in con jargon, I had a lot of ‘ juice ’.\nOften, the talk his editors wanted was from big shots, businessmen promoting themselves or wallowing in rancor.\nThe wise old heads would advise him to lay up, but he'd invariably go for the big shot.\nDefinition:\nAn important or influential person."
    },
    {
      id: 344,
      word: "attitude",
      transcription: "ˈætɪtjuːd",
      translation: "відношення",
      description: "Example:\nWomen normally adopt a deferential attitude toward men, especially to their husbands and fathers-in-law.\nI don't have an attitude problem, It's just that you can't handle my personality.\nStood in a graceful attitude.\nDefinition:\na feeling or opinion about something or someone, or a way of behaving that is caused by this:"
    },
    {
      id: 345,
      word: "manage",
      transcription: "ˈmænɪdʒ",
      translation: "керувати",
      description: "Example:\nI can't manage all this work on my own.\nSon: Ma! Get me some'a pizza!\r\nMother: Manage! Get'a your own'a pizza Luigi!\r\nSon: Fuggehdaboutit!\nsras: let her come to school bro i will manage\nDefinition:\nto be in charge of a business, organization, or undertaking; run; to succeed in doing or dealing with something, especially something difficult:"
    },
    {
      id: 346,
      word: "late",
      transcription: "leɪt",
      translation: "пізно",
      description: "Example:\nlately the rules have been enforced\nas late as yesterday she was fine\nfeeling better of late\nDefinition:\nin the recent past"
    },
    {
      id: 347,
      word: "flu",
      transcription: "fluː",
      translation: "грип",
      description: "Example:\nThe whole family has the flu.\nI had the flu last week.\nShe was off work for four days because of a bout with the flu.\nDefinition:\na common infectious illness that causes fever and headache:"
    },
    {
      id: 348,
      word: "treat",
      transcription: "triːt",
      translation: "ставитися",
      description: "Example:\nWestern medicine tends to treat the symptoms and not the cause.\nShe treated her houseguests with good food every night\nDon't worry about the expensive wine--I'm treating\nDefinition:\nto cure a person of a disease or heal an injury; to behave towards someone or something in a particular way:"
    },
    {
      id: 349,
      word: "treatment",
      transcription: "ˈtri:tmənt",
      translation: "догляд",
      description: "Example:\nSpecialists can diagnose the condition with a simple blood test, and treatment normally includes medication to thin the blood.\nThese improvements might be the net effect of two factors: starting treatment at earlier stages of disease, or better treatment for a given stage.\nMy only real quarrel is with the chapter on ‘Neurodevelopment and Pharmacological Treatment’ by the aforementioned editors of Pathological Gambling.\nDefinition:\nthe management of someone or something"
    },
    {
      id: 350,
      word: "whale",
      transcription: "weɪl",
      translation: "кит",
      description: "Example:\nShe was only plump, not fat , but in those girls' eyes, she was a whale.\nThe tusked narwhal, white beluga whales and elusive bowhead whale all live off the northern part of this island.\nDefinition:\na very large person; impressive in size or qualities"
    },
    {
      id: 351,
      word: "French",
      transcription: "frentʃ",
      translation: "Французька мова",
      description: "Example:\nI'm French but I work in Belgium.\nWhen you speak French you are speaking lovely or the love language.\nSo why are we supposed to hate The French?\nDefinition:\nrelating to France or its people or language:"
    },
    {
      id: 352,
      word: "borrow",
      transcription: "ˈbɒrəʊ",
      translation: "позичати",
      description: "Example:\nI was wondering if I could borrow your English notes.\nCan I see your borrow?\nDefinition:\nto take with the intention of returning it:"
    },
    {
      id: 353,
      word: "against",
      transcription: "əˈɡenst",
      translation: "проти",
      description: "Example:\nIt was fulfilling to see a club that has battled against adversity for so long finally get back to where they believe they rightly belong .\nCane toad toxin is very effective against virtually all Australian native species that attempt to eat toads, from small frog-eating reptiles to the Quoll (Australia's native cat ).\nThe sling on his left shoulder held his injured arm snugly against his body.\nDefinition:\nAbreast; opposite to; facing; towards; in this sense often preceded by over."
    },
    {
      id: 354,
      word: "estimate",
      transcription: "ˈestɪmeɪt",
      translation: "оцінювати",
      description: "Example:\nWe estimate the magma production, erosion and marine depositional rates of volcanic products.\nI estimate that there I a 10 to 90 chance that I will go to church this week.\nDefinition:\nIf you estimate a quantity or value, you make an approximate judgment or calculation of it."
    },
    {
      id: 355,
      word: "compete",
      transcription: "kəmˈpiːt",
      translation: "змагатися",
      description: "Example:\nhe could not compete with John in Marian's eyes and his suit came to nothing\nMy buddy will debate the rules and intimidate other people in order to win a game, he is so competional.\nAny competent lawyer can draw up a will.\nDefinition:\nAttempt to win something by superiority over others."
    },
    {
      id: 356,
      word: "lend",
      transcription: "lend",
      translation: "Надавати",
      description: "Example:\nThe bank will not lend money, and interest payments and receipts are forbidden.\nHe had spent more time around her, doing nice things for her and just offering her a lending ear to listen to her and a shoulder to cry on when she needed it.\nYo, can I copy your homework?\r\nNo I spent a lot of time on this\r\nLend/you absolute lend/ so lendy\nDefinition:\nto allow the use of money under an agreement to pay it back:"
    },
    {
      id: 357,
      word: "lend",
      transcription: "lend",
      translation: "позичати",
      description: "Example:\nThe bank will not lend money, and interest payments and receipts are forbidden.\nHe had spent more time around her, doing nice things for her and just offering her a lending ear to listen to her and a shoulder to cry on when she needed it.\nYo, can I copy your homework?\r\nNo I spent a lot of time on this\r\nLend/you absolute lend/ so lendy\nDefinition:\nto allow the use of money under an agreement to pay it back:"
    },
    {
      id: 358,
      word: "regret",
      transcription: "rɪˈgret",
      translation: "шкодувати",
      description: "Example:\nThe anger lasted for a long time, trying to provoke her into saying things she would regret.\nHe replied to the man in a soft, cracked voice, and suddenly felt grief and regret take him.\nThe only moral action is kill the terrorist without mercy or regret, and thus protect innocent lives against future acts of terrorism.\nDefinition:\nFeel sad about something is done."
    },
    {
      id: 359,
      word: "allegedly",
      transcription: "əˈledʒɪdli",
      translation: "як стверджують",
      description: "Example:\nThe former Major League Baseball pitcher has been arrested for allegedly robbing a jewelry store in Florida.\nArmed with a crayfishing spear, they allegedly demanded and took the catch from a group of professional fishermen who worked out of Cooktown, outside the strait .\nThe quote that is allegedly from George Washington's farewell address is also a complete forgery.\nDefinition:\naccording to what has been alleged"
    },
    {
      id: 360,
      word: "fierce",
      transcription: "fɪəs",
      translation: "сильний",
      description: "Example:\nOccasionally the rumble of a volcano or the roar of a fierce hurricane breaks up the usual sounds.\nAlthough the broken window would still need to be replaced , the inner pane protects the building's interior from the fierce winds.\nthey were clinging together in fierce mutual desire\nDefinition:\nA fierce animal or person is very aggressive or angry."
    },
    {
      id: 361,
      word: "breach",
      transcription: "briːtʃ",
      translation: "порушувати",
      description: "Example:\nThe contracts threaten severe punishment for any such breach.\nProminent amongst these was the fact that the Commission had found simply that the agreement was in breach of the article .\nThese exchanges are routine, and don't distract Krista from trying to breach an ideological gap with a car full of wrathful seniors.\nDefinition:\nAn act of breaking or failing to observe a law, agreement, or code of conduct."
    },
    {
      id: 362,
      word: "credential",
      transcription: "krɪˈdentʃəl",
      translation: "рекомендація",
      description: "Example:\nBut simply put, he is a huckster, the antithesis of the anti-politician, and someone with limited green credentials, to say the least.\nFor decades, bitter arguments about devolution have bubbled away under the surface of a party fiercely proud of its unionist credentials.\nFinally, drive the car over them until they attain the distressed patina of wear and tear that is essential to your shooting-party credentials.\nDefinition:\na document attesting to the truth of certain stated facts"
    },
    {
      id: 363,
      word: "annual",
      transcription: "ˈænjuəl",
      translation: "річний",
      description: "Example:\nthe 4th of July\nfat conroy came over and took an annual, then left.  Next day he took another one, it smelled funkayyyy.\nAttention all customers, attention all customers. The semi-annual sale begins today, and the next one is on December 18! Buy now and get extreme price cuts!\nDefinition:\na reference book that is published regularly once every year"
    },
    {
      id: 364,
      word: "gig",
      transcription: "gɪg",
      translation: "концерт",
      description: "Example:\nYou guys played one gig four years ago.\nThe comedian did her first gig at the Comedy Store in London.\nA quick glance at my ticket reminded me that I had a seat in the circle and that I wouldn't be having to stand up for this gig.\nDefinition:\na live performance by a musician or group playing popular or jazz music:"
    },
    {
      id: 365,
      word: "Constraints",
      transcription: "kənˈstreɪnt",
      translation: "Обмеження",
      description: "Definition:\n"
    },
    {
      id: 366,
      word: "mammal",
      transcription: "ˈmæməl",
      translation: "ссавець",
      description: "Definition:\n"
    },
    {
      id: 367,
      word: "honorary",
      transcription: "ˈɒnərəri",
      translation: "почесний",
      description: "Example:\nWith all the godsons and honorary nieces and nephews I have, it should be enough.\nHe was a lifelong member of St. Peter's Parish and a member of the Knights of Columbus as a third degree knight and fourth degree honorary knight.\nHe was also appointed honorary lecturer in clinical medicine.\nDefinition:\ngiven as an honor without the normal duties"
    },
    {
      id: 368,
      word: "perk",
      transcription: "pɜːk",
      translation: "зазнаватися",
      description: "Example:\nShe tossed her head, and perked away from him on her little high heels.\nSleeping with many beautiful women is one of the perks of being a rock star.\nhey, when we where tweakin tha other day eden knocked over our perks the shiest\nDefinition:\nto act, or carry oneself, in a jaunty manner; special benefits that are given to people who have a particular job or belong to a particular group:"
    },
    {
      id: 369,
      word: "money spinner",
      transcription: "ˈmʌni ˈspɪnər",
      translation: "прибуткова справа",
      description: "Example:\nThe films have been fantastic money spinners.\nI want to get a lap dance from that little stripper, I definitely love the spinners.\nI want to get that spinner in my bed and put her to work.\nDefinition:\nIf you say that something is a money spinner, you mean that it earns a lot of money for someone."
    },
    {
      id: 370,
      word: "working conditions",
      transcription: "ˈwɜːkɪŋ kənˈdɪʃənz",
      translation: "умови праці",
      description: "Example:\nOther outstanding issues include working conditions and workplace safety.\nNotwithstanding the difficult working conditions, a major inroad was made.\nIn May, workers walked off the job to protest unsafe working conditions.\nDefinition:\nThe circumstances affecting the way in which people work."
    },
    {
      id: 371,
      word: "handle",
      transcription: "ˈhændl̩",
      translation: "впоратися",
      description: "Example:\nHe can handle it all right.\nHe can handle it all right.\nHe can handle it all right.\nDefinition:\nManage a situation or problem."
    },
    {
      id: 372,
      word: "sort out",
      transcription: "sɔːt aʊt",
      translation: "розбирати",
      description: "Example:\nNot to worry, Miller will sort out private industry, those economy wreckers and get us down to 5 cents a gallon for gas.\nI may post more later if I can sort out my thoughts better.\nOn Friday night I was an emotional wreck and needed to sort out a lot of stuff in my head.\nDefinition:\norganizing things by separating them into categories:"
    },
    {
      id: 373,
      word: "subsidy",
      transcription: "ˈsʌbsɪdi",
      translation: "субсидія",
      description: "Example:\na subsidy for research in artificial intelligence\nBulgaria should have eliminated the state subsidy for the coal mining and begun to implement differentiation in transport and distribution pricing of natural gas.\nBecause if you can deduct interest on a loan , invest the money, and earn tax-free profits, you essentially get a government subsidy for investing.\nDefinition:\na grant paid by a government to an enterprise that benefits the public:"
    },
    {
      id: 374,
      word: "submit",
      transcription: "səbˈmɪt",
      translation: "подавати",
      description: "Example:\nCompanies are required to submit monthly financial statements to the board.\nCompetitors for the painting competition must submit their entries by Friday.\nDefinition:\nTo give or offer something for a decision to be made by others."
    },
    {
      id: 375,
      word: "delegate",
      transcription: "delɪgeɪt",
      translation: "делегувати",
      description: "Example:\nWe can delegate the authority to train and bring up our children to someone else but never the responsibility.\nAnd when I delegate responsibility, I delegate the authority to go along with it.\nOther delegates instanced names of people who would be eligible for membership of the IFA under the new rules, but who would have opposite views on several issues to those held by farming members.\nDefinition:\nto give a particular job, duty, right, etc. to someone else so that they do it for you:"
    },
    {
      id: 376,
      word: "mediator",
      transcription: "ˈmiːdieɪtər",
      translation: "посередник",
      description: "Example:\nShe has agreed to act as mediator and meet with the board to try to resolve the dispute.\nSecond, Edwards developed a very refined understanding of Christ's office as the Mediator between God and man.\nBy acting as a facilitator, guide, or mediator, the chair may avoid discord among the trustees and also prevent future difficulties by keeping the board focused on its responsibilities.\nDefinition:\nA person who tries to end a disagreement by helping the two sides to talk about and agree on a solution."
    },
    {
      id: 377,
      word: "point out",
      transcription: "pɔɪnt aʊt",
      translation: "вказувати",
      description: "Example:\nI should point out that the game attracts mainly gamers from the continent.\nIt took my mum to point out that Botox is now fully integrated into polite society.\nJurors continued along the track, with Mr Latham pausing to point out a site where a car would have been able to make a three-point turn .\nDefinition:\nDirect someone's gaze or attention toward, especially by extending one's finger."
    },
    {
      id: 378,
      word: "people person",
      transcription: "ˈpiːpl̩ ˈpɜːrsən",
      translation: "душа компанії",
      description: "Example:\nBut when it comes right down to it, I'm just really not a people person .\nI'm not much of a people person , and not much of a talker.\nI'm also a people person and like managing events,’ she said.\nDefinition:\nA person who enjoys or is particularly good at interacting with others."
    },
    {
      id: 379,
      word: "move out",
      transcription: "muːv aʊt",
      translation: "з'їжджати",
      description: "Example:\nHer landlord has given her a week to move out.\nInstead, he had sent Afan on to rally the forces left in Nottingham to move out and meet Arthur in battle once more.\nMy friend did not move out of the way fast enough for the horn blowing couple and was actually ‘nudged’ by the front bumper of the car.\nDefinition:\nLeave or cause to leave one's place of residence or work."
    },
    {
      id: 380,
      word: "make time",
      transcription: "meɪk taɪm",
      translation: "виділити час",
      description: "Example:\neveryone should make time to see this film\nIndustry had already understood before the First World War how to make time-consuming bleaching a thing of the past by inventing laundry blue , a powder based on indigo.\nChildren were expected to perform lung function and complete diaries daily and to make time for home visits every 4 weeks.\nDefinition:\nFind an occasion when time is available to do something."
    },
    {
      id: 381,
      word: "implement",
      transcription: "ˈɪmplɪment",
      translation: "виконувати",
      description: "Example:\nThe computer programs implement basic mathematical principles such as basic geometry and fractional math.\nThe government promised to implement a new system to control financial loan institutions.\nThe determination of policy is not your business - your job is to implement it.\nDefinition:\nPut a decision, plan, agreement into effect."
    },
    {
      id: 382,
      word: "help out",
      transcription: "help aʊt",
      translation: "виручити",
      description: "Example:\n‘If big corporations want to help out, they can put some deposits in our banks and run some checking accounts through us,’ he says.\nThey are so generous with their time and talent and they are always more than willing to help out with causes such as this.\nAll the money goes to charity and what is not used to help out the less well-off at Christmas is distributed to Waterford charities, so all the money stays local.\nDefinition:\nMake it easier or possible for someone to do something by offering them one's services or resources."
    },
    {
      id: 383,
      word: "drawer",
      transcription: "ˈdrɔ:ə",
      translation: "шухляда",
      description: "Example:\nHey Suzie, you`re a good Drawer. I`m gonna go watch Treehouse now!\nI keep all my underwear in the top drawer of my dresser, and my pants in the drawer below it.\nJenny: Hey Jake, put the silverware in the DRAW-ER\r\nDerek: Do you mean Droor?\r\nJenny: No Derek, you fool, I said drawer because that's where you put silverware. A droor is just a figment of your imagination.\nDefinition:\nan artist skilled at drawing"
    },
    {
      id: 384,
      word: "from now on",
      transcription: "frɒm naʊ ɒn",
      translation: "відтепер",
      description: "Example:\nFrom now on we'll be shouting loud and clear on your behalf and demanding to know who these people are.\nParents whose teenage children want to enjoy a popular night out will find buying tickets to the event easier from now on.\nFrom now on motor vehicles will be treated the same as other plant and machinery and both categories will be allowed over a 5 year period.\nDefinition:\nThe Nazi Organization of Women."
    },
    {
      id: 385,
      word: "remotely",
      transcription: "rɪˈməʊt.li",
      translation: "віддалено",
      description: "Example:\nThe big reveal in the last episode was anticlimactic: oh boy, a minor character we don't remotely care about is a traitor!\nIs it even remotely possible that there will be a grand macro change without significant micro alteration here?\nAt no point in my life so far have I or anyone in my family ever been rich, or even remotely comfortable financially.\nDefinition:\nto a remote degree"
    },
    {
      id: 386,
      word: "rule out",
      transcription: "ruːl aʊt",
      translation: "виключати",
      description: "Example:\nTo diagnose or rule out sepsis, doctors draw blood, and sometimes examine cerebrospinal fluid and other body fluids, to look for bacteria or other pathogens.\nBriefing newsmen in Asaba, the governor exclaimed, ‘We should rule out political motives.’\nThe first concern is to rule out treatable forms of dementia such as encephalitis or chronic meningitis.\nDefinition:\nexclude something as a possibility:"
    },
    {
      id: 387,
      word: "lose control",
      transcription: "luːz kənˈtrəʊl",
      translation: "втрачати контроль",
      description: "Example:\nBut ideas turn around, they are as slippery as eels, and it's easy to lose control of them.\nPolice said on Sunday that the frosty road surface may have caused him to lose control of the car.\nBut you know, the manufacturing jobs disappear, you lose control over your space.\nDefinition:\na lack of the ability to provide conscious limitation of impulses and behavior as a result of overwhelming emotion."
    },
    {
      id: 388,
      word: "fit in",
      transcription: "fɪt ɪn",
      translation: "пристосовуватися",
      description: "Example:\nShe doesn’t fit in with the other children.\nShe was great with children and fitted in well.\nDefinition:\nto feel comfortable with a new situation or group of  people:"
    },
    {
      id: 389,
      word: "move up",
      transcription: "muːv ʌp",
      translation: "просуватися",
      description: "Example:\nOh man, my parents bought me a new car!\r\nLook at you, moving up in the world.\nThe whole family had to move upstairs after their belongings had been made safe.\nFive years ago, he decided to move uptown to Harlem where a number of black designers and clothiers have also opened boutiques, either for the first time or as an extension of their line.\nDefinition:\nto get a more important job in a company or organization:"
    },
    {
      id: 390,
      word: "get promoted",
      transcription: "get prəˈməʊt",
      translation: "домагатися просування по службі",
      description: "Example:\nYou may even get promoted due to your hard work.\nWith this effect, you can get promoted.\nDefinition:\nyou are given a more important job or rank in the organization that you work for:"
    },
    {
      id: 391,
      word: "committed",
      transcription: "kəˈmɪtɪd",
      translation: "відданий ідеї",
      description: "Example:\nThat is the project to which America is committed.\nWhen I married my husband I committed to him for better, for worse, for richer, for poorer, in sickness and in health, until death do us part\nCommitted was released in January and it soon was cancelled.\nDefinition:\nin a long-term emotional relationship; willing to work hard and give your time and energy to something; believing strongly in something:"
    },
    {
      id: 392,
      word: "force",
      transcription: "fɔ:s",
      translation: "змушувати",
      description: "Example:\nPolice in Bradford are helping to show the way to other forces by proving literally that crime does not pay.\na public force is necessary to give security to the rights of citizens\nThe film is really just a series of slickly filmed action sequences dangling off a thin plot and held together by the force of Jackson's charisma.\nDefinition:\n(of a law) having legal validity"
    },
    {
      id: 393,
      word: "eager for",
      transcription: "ˈiːgər fɔːr",
      translation: "пристрасно бажаючий",
      description: "Example:\nThey crowded around the spokesperson, eager for any news.\new that girl is s eager why could she have frinds?\nPlayer 1: Jesus Christ Coach Eager really isn't going to end practice until everyone of us pukes is he?\r\nPlayer 2: He's so drunk I don't think he even knows where he is right now, damn he is a real legend, can't wait until the wild bayou party after tomorrow's game!\nDefinition:\nwanting very much to do or have something, especially something interesting or enjoyable:"
    },
    {
      id: 394,
      word: "make plans",
      transcription: "meɪk plæn",
      translation: "планувати",
      description: `Example:
Those already engaged and soon-to-be-married may either make plans together or go it alone, one last time.
I was going to go out last Friday night, but instead I stayed home and made plans.\r
\r
I scheduled half an hour for myself to make plans. Unfortunately, I finished after 5 minutes and watched TV instead.\r

Don't worry man - we'll make a plan.
Definition:
To "make plans" means to plan what you're going to do with someone on a certain day and time.`
    },
    {
      id: 395,
      word: "burning ambition",
      transcription: "ˈbɜːnɪŋ æmˈbɪʃən",
      translation: "заповітне бажання",
      description: "Example:\nDespite dire personal straits, the young Einstein had a burning ambition.\nFriend: Dude your cousin has so much ambition.\n\nMe: I know, I can't stand her.\nJonathan, ambition is the willingness to kill the things you love and eat them to stay alive. Haven't you ever read my throw pillow?\nDefinition:\nA very strong need to do something."
    },
    {
      id: 396,
      word: "run into",
      transcription: "rʌn ˈɪntuː",
      translation: "зіткнутися",
      description: "Example:\nI run into these super sensitive people all the time.\nWe had run into pretty light resistance, and we had pushed out a couple of thousand yards.\nI started cooking tea just before it started and had to run into the kitchen and turn over the rissoles and run back into the lounge room so I wouldn't miss any of the show.\nDefinition:\nCollide with."
    },
    {
      id: 397,
      word: "put off",
      transcription: "pʊt ɒf",
      translation: "відкладати",
      description: "Example:\nJohn: Sorry, but I've just missed my flight and our meeting starts at 3pm.\r\n\r\nJane: Don't worry John, we can put off this meeting for tomorrow.\nTossing in elements of blues, rock, glam-rock, soul and metal, it's a wildly extravagant affair that is likely to put off as many people as it delights.\nIt's a big let-down for people who have had to put up with the inconvenience, the noise and the roadworks and what if it's put off again until the spring?\nDefinition:\nDelay doing something."
    },
    {
      id: 398,
      word: "pick up",
      transcription: "pɪk ʌp",
      translation: "навчитися",
      description: "Example:\nShe picked up Spanish when she was living in Mexico.\nIf you have a look in any chemist , Boots, Super drug or superstore you can pick up travel sized toiletries.\nIt's more important to go to places and explore them a bit, pick up the atmosphere, look at what's on sale at the market .\nDefinition:\n1.Lift something up. 2.If you pick up something such as a skill or an idea, you acquire it without effort over a period of time."
    },
    {
      id: 399,
      word: "goal-oriented",
      transcription: "ɡoʊl ɔːrientɪd",
      translation: "цілеспрямований",
      description: "Example:\nHis playing is at once affectively specific and goal oriented.\nThat kind of direct, clear-headed , goal-oriented vision was needed then, just as it is needed today.\nI'm going orienteering today.\nDefinition:\nConcerned with or focused on achieving a particular aim or result."
    },
    {
      id: 400,
      word: "go-getter",
      transcription: "ˈgəʊˌgetər",
      translation: "підприємливий",
      description: "Example:\nWe only recruit go-getters who will be actively involved in the company's development.\nI'm a go getter i work part time student and take care of home. I stay getting money ,always focused and working hard.\nThat guy from Extreme Makeover Home Edition is a go-getter!\nDefinition:\nsomeone who is very energetic, determined to be successful, and able to deal with new or difficult situations easily:"
    },
    {
      id: 401,
      word: "tend",
      transcription: "tend",
      translation: "має схильність",
      description: "Example:\nShe tends to be nervous before her lectures\nThat's a pretty tend watch.\r\nShe's a bit tend.\n1. I need to tend.\r\n2. I'm tending at the moment.\r\n3. I have to tend to my needs.\r\n4. I'm going to tend with my baby.\nDefinition:\nhave a tendency or disposition to do or be something; be inclined"
    },
    {
      id: 402,
      word: "tutor",
      transcription: "ˈtjuːtər",
      translation: "репетитор",
      description: "Example:\n‘Well, today I have poinsettias or fir cones for you,’ said the tutor.\nAfter Oxford she got a job as a tutorial fellow at Bedford College at the University of London, but she did not enjoy it.\nThe tutor facilitates emergence of specific learning outcomes established by the instructor.\nDefinition:\nA university or college teacher."
    },
    {
      id: 403,
      word: "Bachelor",
      transcription: "ˈbætʃələr",
      translation: "бакалавр",
      description: "Example:\nAll interviewers held bachelor's degrees and most were in postgraduate study in the social sciences.\nA lovestruck South African and a Rochdale bachelor have married after a whirlwind romance over the internet.\nThe Bachelor's Button is an old-fashioned flower, a roadside attraction with familiar blue blossoms, also known as the cornflower .\nDefinition:\nA person who holds an undergraduate degree from a university or college."
    },
    {
      id: 404,
      word: "Bachelor",
      transcription: "ˈbætʃələr",
      translation: "холостяк",
      description: "Example:\nAll interviewers held bachelor's degrees and most were in postgraduate study in the social sciences.\nA lovestruck South African and a Rochdale bachelor have married after a whirlwind romance over the internet.\nThe Bachelor's Button is an old-fashioned flower, a roadside attraction with familiar blue blossoms, also known as the cornflower .\nDefinition:\nA person who holds an undergraduate degree from a university or college."
    },
    {
      id: 405,
      word: "self-belief",
      transcription: "selfbəˈliːf",
      translation: "впевненість в собі",
      description: "Example:\nSo our message to all you go-getters is this: By starting out you have already displayed the biggest quality needed for success - namely, self-belief.\nOnly after Fernandes' equaliser were Rangers infused with a sense of self-belief which underpinned a prolonged spell of dominant play.\nFor Hinton is a fourth dan in aikido , a Japanese martial art which puts emphasis on self-belief and inner focus.\nDefinition:\nConfidence in your own abilities or judgment."
    },
    {
      id: 406,
      word: "wishful thinking",
      transcription: "ˈwɪʃful ˈθɪŋkɪŋ",
      translation: "прийняття бажаного за дійсне",
      description: "Example:\nFor despite the artist's romantic wishful thinking, his rustic Bretons were no simple peasants.\nWishful thinking is a fallacy that posits a belief because it or its consequence is desired to be true.\nThis may sound like wishful thinking but how else will we create hope from the despair of untold child death, wanton neglect of girls and women, and a rich elite feasting on the misery of millions in poverty?\nDefinition:\nBasically daydreaming. Wishing or imagining something would happen that isn't exactly realistic."
    },
    {
      id: 407,
      word: "interrupt",
      transcription: "ˌɪntəˈrʌpt",
      translation: "переривати",
      description: "Example:\nI do not want to interrupt the debate, but there is a bit of feedback coming through the microphones.\nHe was clearly a little hesitant about sharing his history with anyone for that matter, and she shouldn't interrupt the flow of his words lest it should ebb.\nThis caused quite a commotion as he didn't take kindly to my interruption and asked who was I to question him and disturb his presentation.\nDefinition:\nStop the continuous progress."
    },
    {
      id: 408,
      word: "make it",
      transcription: "meɪk ɪt",
      translation: "досягти своєї мети",
      description: "Example:\nMake it pink champagne, girlfriend - because you're worth it.\nWhat happens to stop the flow of words, and what can make it start again?\nthat word didn't make it into the dictionary\nDefinition:\n1) To reach a goal."
    },
    {
      id: 409,
      word: "self-restraint",
      transcription: "ˌselfrɪˈstreɪnt",
      translation: "самоконтроль",
      description: "Example:\nThough the Council does not operate free of legal limits, the most important limit on the Council is self-restraint.\nIf only I could resist an eighth piece of cake. The cake is a restraint for example, of your happiness.\nDefinition:\nIf you show self-restraint, you do not do something even though you would like to do it, because you think it would be better not to."
    },
    {
      id: 410,
      word: "runner up",
      transcription: "ˈrʌnər ʌp",
      translation: "займає друге місце",
      description: "Example:\nA game of darts will take place in The Wood Cabin every Thursday night until Christmas with a first prize of a turkey and a bottle of whiskey for the runner up.\nIt is the highest grossing R-rated film ever, outdistancing the runner up by 15%.\nDear John, I know things did not go so well between us, but you should know it was you and not me. By the way, I'm engaged to someone else. He is a wonderful man named....\nDefinition:\nThe person who comes in second. The first person to lose to the winner. The person who is made fun of just less than the person who comes in last. "
    },
    {
      id: 411,
      word: "take after",
      transcription: "teɪk ˈɑːftər",
      translation: "бути схожим",
      description: "Example:\nPeter's very tall - he takes after his father.\nDefinition:\nResemble a parent or ancestor."
    },
    {
      id: 412,
      word: "struggle",
      transcription: "ˈstrʌgl̩",
      translation: "пробиватися",
      description: "Example:\nIf you struggle on a hilly course, practice running up more hills in training.\nDylan uncontrollably Struggles after Parker makes a ridiculous comment and needs to take it easy.\ngetting through the crowd was a real struggle\nDefinition:\nMake forceful or violent efforts to get free of restraint or constriction."
    },
    {
      id: 413,
      word: "stand out",
      transcription: "stænd aʊt",
      translation: "виділятися",
      description: "Example:\nShe stood out as one of the prettiest girls in the school.\nThese are the items that will make it stand out from the crowd and give it the advantage over other similar properties.\nSo what if it doesn't stand out from the crowd , that's kind of how I like to be anyway.\nDefinition:\nto be easily noticeable:"
    },
    {
      id: 414,
      word: "spread out",
      transcription: "spred aʊt",
      translation: "розширювати",
      description: "Example:\nThat was Thomas, I realised, looking over the plump, red-faced infant spread out uncomfortably all over my chair.\nBut as the disease spread out of control, authorities switched to vaccinations as the main form of defense , he added.\nAdd the rice and blanch the grains for 5 minutes, then drain and spread out on a tray.\nDefinition:\nMove apart so as to cover a wider area."
    },
    {
      id: 415,
      word: "soaring",
      transcription: "ˈsɔːrɪŋ",
      translation: "ширяючий",
      description: "Example:\nWell... naturally, it is the soaring eagle that attracts her attention, not the plucked chicken.\nHe felt disconnected from his body, soaring into a haze of delirium.\nI followed the majestic flight of an eagle reveling in his freedom, soaring through the skies as if they were his to roam at will.\nDefinition:\nMaintaining height in the air without flapping its wings."
    },
    {
      id: 416,
      word: "shake off",
      transcription: "ʃeɪk ɑːf",
      translation: "позбавлятися",
      description: "Example:\nLast year's second-placed rider achieved that target on the summit but was unable to shake off the Dutchman on the 15 km descent and was pipped in a sprint for the line.\nIt may take him a couple of games to shake off the rust .\nIverson and McKie will return early, but they'll have to shake off the rust .\nDefinition:\nSuccessfully deal with or recover from."
    },
    {
      id: 417,
      word: "self-esteem",
      transcription: "ˌselfɪˈstiːm",
      translation: "самоповага",
      description: "Example:\nYou can get back your pride and your dignity and your self-esteem.\nWhos that?\r\nShes been in our school for 4 years, since year 7\r\nHmmm, idk her\r\nProbably coz she has no self-esteem she never talks\n\nEwww, lpok at that girl'\r\nIk shes got crooked teeth\r\nYeah! And a crooked smile too\r\n*both laughing*\nBoy- ur not so pretty\r\n\r\nGirl-u just ruined my self-esteem\r\n\r\nBoy- how can i ruin your self-esteem? its called SELF-esteem for a reason\nDefinition:\nConfidence in one's own worth or abilities; self-respect."
    },
    {
      id: 418,
      word: "self-assured",
      transcription: "ˌself əˈʃʊrd",
      translation: "самовпевнений",
      description: "Example:\n\nDefinition:\nShow confidence in what you say and do because you are sure of your own abilities."
    },
    {
      id: 419,
      word: "self-appraisal",
      transcription: " self əˈpreɪzəl",
      translation: "самооцінка",
      description: "Example:\nEven though I lied like the best of them on my Employee Self Appraisal I still did not get a raise.\nIm gonna drill some open hole appraisal wells tonight.\nGet your fine self over hear!\nDefinition:\nAn employee's own judgment about the quality of their work, or the process of judging your own work"
    },
    {
      id: 420,
      word: "assertive",
      transcription: "əˈsɜːtɪv",
      translation: "самовпевнений",
      description: "Example:\n\nDefinition:\naggressively self-assured"
    },
    {
      id: 421,
      word: "surrounding",
      transcription: "səˈraʊndɪŋ",
      translation: "середовище",
      description: "Example:\nI saw a single coot and lots of wood pigeons perched in the dead trees surrounding the lagoon .\nWe drove by White Castle Burgers, I said Let's get some White Castle & they didn't stop... SURROUNDED!!\n(2 Black men at a concert) \r\n\r\nI thought you said we were going to see Busta Rhymes, this is LeAnn Rimes! \r\n\r\nOh my bad. Lets get the hell out of here, these white folks got us *SURROUNDED!*\nDefinition:\nAll round a particular person."
    },
    {
      id: 422,
      word: "concious",
      transcription: "ˈkɒŋkɔːs",
      translation: "сознательный",
      description: "Example:\nI really had made a concious effort to speak more and stuff, so yeah , I am still a little miffed.\nHey i think tawd is sleeping. No he cant be because his eyes are open. he must be concious snoring.\nPerson One: Dude, your floss is from Hy-Vee?  That's lame.\r\nPerson Two: Cut it out!  You're making me all floss-concious!\nDefinition:\naware of and responding to one's surroundings."
    },
    {
      id: 423,
      word: "ice skate",
      transcription: "aɪs skeɪt",
      translation: "кататися на ковзанах",
      description: "Example:\nOn January 15, in Trafalgar Square there will be 500 singers and dancers (all in costume naturally), ice skaters, balalaikas , hot borsch, blini, and pirozhki.\nProtesters had hoped the new rink would open at the same time for all the ice skaters and ice hockey players who train there.\nTwo female ice skaters practicing on the ice are crowded off of it by the arrival of two male ice hockey teams.\nDefinition:\nA term for smoking and/or being high on crystal meth (ie. Ice) that's designed to confuse cops and sober white people."
    },
    {
      id: 424,
      word: "hazardous",
      transcription: "ˈhæzədəs",
      translation: "небезпечний",
      description: "Example:\nAs I have said before rearing a family when you spend all your life on floating water weeds is a hazardous business.\nIt is an enclosed box from which hazardous gases cannot escape .\nPlastic eyeshields, used over a taped eyelid , are a less hazardous alternative for people who smoke.\nDefinition:\ninvolving risk or danger"
    },
    {
      id: 425,
      word: "adrenaline junkie",
      transcription: "əˈdrenəlɪn ˈdʒʌŋki",
      translation: "любитель гострих відчуттів",
      description: "Example:\nIf you're brave or stupid and an adrenaline junkie, then the 88 mph, headfirst slide down the icy canal on a luge should suit you down to the ground\nAdrenaline junkies can jump right into competition with little or no vehicle know-how .\na bit of an adrenaline junkie, he appears to have no regard for his own safety\nDefinition:\nA person with a compulsive desire for excitement and adventure."
    },
    {
      id: 426,
      word: "jeopardize",
      transcription: "ˈdʒepədaɪz",
      translation: "наражати на небезпеку",
      description: "Example:\nNot only did Max lose his third place, he even jeopardized his participation in the second race.\nIf the outcome of a sporting event is jeopardized or tainted by the cloud of suspicion, sport immediately loses all its appeal.\ndo you seriously believe that I would jeopardize my career by such acts?\nDefinition:\npose a threat to; present a danger to:"
    },
    {
      id: 427,
      word: "by chance",
      transcription: "baɪ tʃɑːns",
      translation: "випадково",
      description: "Example:\nLike other fallen communities, it is now governed by chance and human imperfection .\nThe probability of this convergence happening by chance tends to zero as the number of experimental procedures increases.\nThe problem was that many people came in on that day by chance, taking advantage of the sale even if they weren't regular customers.\nDefinition:\nA phrase used to inquire about something. Similar to 'I was wondering'"
    },
    {
      id: 428,
      word: "endurance",
      transcription: "ɪnˈdʊrəns",
      translation: "витривалість",
      description: "Example:\nParticipation in a marathon is a test of human endurance.\nWe practice yoga to increase our endurance.\nEndurance helps us hold poses for a long time.\nDefinition:\nThe ability to do something difficult for a long time."
    },
    {
      id: 429,
      word: "widen",
      transcription: "ˈwaɪdən",
      translation: "розширюватися",
      description: "Example:\nThe idea was to widen the debate and open the whole process up to more public scrutiny.\nthe house was demolished to allow for road widening\nShe grunted, her eyes widening as his knee pushed into her stomach roughly and violently.\nDefinition:\nShift borders of something."
    },
    {
      id: 430,
      word: "lifebuoy",
      transcription: "ˈlaɪfbuːi",
      translation: "рятувальний круг",
      description: "Example:\nA brand new lifebuoy now sits on a post adjacent to Lake McKay at the Australian Defence College in Weston, Canberra.\nDefinition:\nA buoyant support such as a lifebelt for keeping a person afloat in water."
    },
    {
      id: 431,
      word: "life jacket",
      transcription: "laɪf ˈdʒækɪt",
      translation: "рятівний жилет",
      description: "Example:\nWhen the ship began to sink, the franchisor left its charge afloat in turbulent waters, without a life jacket .\nWhen I came to I was back in the boat, shivering in my wet life jacket and coughing up water, a lump forming on my pounding head.\nIf he was 12 years old, and we were boating today in Illinois, he would be required to wear a life jacket while idling through a harbor.\nDefinition:\nA sleeveless buoyant or inflatable jacket for keeping a person afloat in water."
    },
    {
      id: 432,
      word: "lengthen",
      transcription: "ˈleŋkθən",
      translation: "подовжуватися",
      description: "Example:\nThe popularity of the Pilates workout is its potential to change the body shape, stretch and lengthen the muscles, improve the posture and strengthen the conditioning.\nSpring is here too, traditionally the time when house owners look to spruce up their homes as the days lengthen and the light improves.\nI walked downstairs slowly, listening to the lengthening drumbeat slow and pivot.\nDefinition:\nMake or become longer."
    },
    {
      id: 433,
      word: "heighten",
      transcription: "ˈhaɪtən",
      translation: "підвищуватися",
      description: "Example:\nAtop the stairstep stucco fence, cedar lattice was added to heighten the enclosure.\nHealth bosses said the shortage has been heightened by practices going private, claiming demand and lack of cash was affecting their ability to treat patients.\nErianne always set his senses on heightened alarm, even now when she was an emotional whirlwind .\nDefinition:\nMake something higher."
    },
    {
      id: 434,
      word: "hazard",
      transcription: "ˈhæzərd",
      translation: "Небезпека",
      description: "Example:\nThe busy traffic entrance was a hazard to pedestrians.\nI wouldn't like to hazard a guess.\nThe policy hazarded the islands and put the lives of the inhabitants at risk.\nDefinition:\nsomething that is dangerous and likely to cause damage:"
    },
    {
      id: 435,
      word: "harness",
      transcription: "ˈhɑːrnɪs",
      translation: "ремінь безпеки",
      description: "Example:\nShe secured the harness tightly around her waist before embarking on the rock climbing adventure.\nThe horse galloped freely, its colorful harness glinting in the sunlight.\nI liked when Freddy Fazbear went har har har har in the living tombstone's song\nDefinition:\na piece of equipment with straps and belts, used to control or hold in place a person, animal, or object:\nto control something, usually in order to use its power:"
    },
    {
      id: 436,
      word: "goggles",
      transcription: "ˈgɒgl̩z",
      translation: "захисні окуляри",
      description: "Example:\nToday's moonshiners are big time criminals who use night-vision goggles, radio scanners and walkie-talkies and illegal immigrant workers to stay ahead.\nFrom the endless rows of hand tools to the overalls and safety goggles, the atmosphere is industrious to say the least.\nFor higher risk sports - such as basketball, racquetball and handball - Boldt recommends sports goggles with polycarbonate lenses.\nDefinition:\n(plural) tight-fitting spectacles worn to protect the eyes"
    },
    {
      id: 437,
      word: "deepen",
      transcription: "ˈdiːpən",
      translation: "заглиблюватися",
      description: "Example:\nIt is the pragmatic, common sense solution, known in cemetery parlance as ‘lift and deepen’.\nNewrbidge primary schools have issued an urgent cry for help as the schools crisis in the town deepens.\nIn a deepening darkness, they start singing, strange words in a complicated rhythm, repeating a sequence of five phrases.\nDefinition:\nMake or become deep or deeper."
    },
    {
      id: 438,
      word: "mountain trail",
      transcription: "'mauntɪn treɪl",
      translation: "гірська стежка",
      description: "Example:\nWhen you go to Jeju Island, make sure you ride the mountain trail.\nMany interesting mountain trails beckon mountaineering enthusiasts to the Zanskar valley.\nTobias Wolff is a short story writer, a memoirist , a novelist, a father, a husband, a jazz aficionado, a hiker upon remote mountain trails, a winner of literary awards, a neophyte pianist, and the mentor of many young writers.\nDefinition:\nA trail through mountainous country."
    },
    {
      id: 439,
      word: "firefighter",
      transcription: "ˈfaɪəˌfaɪtər",
      translation: "пожежник",
      description: "Example:\nFirefighters were called to a house in Summertown.\nFirefighters rescued a driver trapped in the wreckage of his car.\nFirefighters battled to reach the pair but were unable to save them.\nDefinition:\na person whose job is to extinguish fires:"
    },
    {
      id: 440,
      word: "battle",
      transcription: "ˈbætl̩",
      translation: "битва",
      description: "Example:\nWhat happened today is just one battle of many.\nIt was fulfilling to see a club that has battled against adversity for so long finally get back to where they believe they rightly belong .\nOn the morning of the battle she begged me to allow her to carry the American flag at the head of the regiment.\nDefinition:\na fight between organized armed forces:"
    },
    {
      id: 441,
      word: "adventurous",
      transcription: "ədˈventʃərəs",
      translation: "авантюрний",
      description: "Example:\nadventurous pioneers\nUnadventurous boy: “What cereal did you get?”\r\nAdventurous girl: “I’ve got Cocoa Puffs on the bottom and Lucky Charms on top”\r\nUnadventurous boy: “OMG that’s so adventurous, I could never be that adventurous”\n\nUnadventurous man: “Dude, it’s a cul-de-sac, we can’t get through this way”\r\nAdventurous man: “So, let’s take a look down there anyway, you never know”\nThe two girls were very adventurous last night when they went to the hotel room with the two guys from Connecticut.\nDefinition:\nwilling to undertake or seeking out new and daring enterprises"
    },
    {
      id: 442,
      word: "cautious",
      transcription: "ˈkɔːʃəs",
      translation: "обережний",
      description: "Example:\nA prision inmate should be cautious when picking up a bar of soap\nAttention can be drawn to the proximity of a ginger with the exclamation 'I have a cautionary tale to tell', which will alert your friends to the incoming, whilst causing no unnecessary alarm to your cautious intruder.\nDefinition:\npeople who are fearful and cautious"
    },
    {
      id: 443,
      word: "loosen",
      transcription: "ˈluːsən",
      translation: "послаблюватися",
      description: "Example:\nOn shore, the rice was dried in the sun, and then parched in a kettle to loosen the hull.\nAftershocks and heavy rains continue to trigger mudslides on mountain slopes where the quake has uprooted forests, loosened topsoil or created barrier lakes.\nThe great auks, Purcell reports, were ‘hunted for their feathers… and to loosen their plumage the birds were boiled in large cauldrons over fires fed by oil from auks killed before them.’\nDefinition:\nMake something less tied, fastened, or fixed in place less tight or firm."
    },
    {
      id: 444,
      word: "plummet",
      transcription: "ˈplʌmɪt",
      translation: "швидко падати",
      description: "Example:\nOther residents expressed fears that the village's character would be ruined and house values would plummet .\nWhen I tipped my head back, I saw the hawk buckle its wings and plummet behind the trees.\nSo did populations of sooty shearwaters, a seabird that eats young fish and large plankton, which plummeted 90 percent.\nDefinition:\n(of a heavy weight) to fall or drop swiftly:"
    },
    {
      id: 445,
      word: "triumph",
      transcription: "ˈtraɪəmpf",
      translation: "тріумф",
      description: "Example:\nThe signing of the agreement was a personal triumph for the prime minister.\nIt was the Republican Party's third election triumph in a row.\nThe game ended in triumph for the home team.\nDefinition:\na very great success, achievement, or victory:"
    },
    {
      id: 446,
      word: "lower",
      transcription: "ˈləʊər",
      translation: "зменшувати",
      description: "Example:\nI'll join if they lower the entrance fee.\nThey lowered the coffin into the grave.\n(Two bros looking for tickets) All these small time scalpers out here only have nosebleeds, but no lowers., I know bro, we might have to watch the Lakers game at the bar instead.\nDefinition:\ncause to drop or sink"
    },
    {
      id: 447,
      word: "safety",
      transcription: "ˈseɪfti",
      translation: "безпека",
      description: "Example:\nA surfer who braved 20 ft waves in a vain attempt to help rescue a mother and her children from seas off Scarborough said yesterday there was no safety equipment in the area.\nConsequently, a reliable pillar of our public safety infrastructure is gradually being undermined.\nThe area has been cordoned off and people living in the vicinity of the house have been evacuated to safety.\nDefinition:\nSafety is the state of being safe from harm or danger."
    },
    {
      id: 448,
      word: "embezzle",
      transcription: "ɪmˈbezl",
      translation: "привласнювати",
      description: "Example:\nOne former director embezzled $34 million in company funds.\nIn a 460-page indictment they were accused of several counts of gross embezzlement, a punishable offence which could attract sentences of up to 10 years prison.\nThe legislation will simplify the law on larceny, fraudulent conversion, forgery and embezzlement.\nDefinition:\nIf someone embezzles money that their organization or company has placed in their care, they take it and use it illegally for their own purposes."
    },
    {
      id: 449,
      word: "plunge",
      transcription: "plʌndʒ",
      translation: "пірнати",
      description: "Example:\nBut it suffered a spectacular fall from grace when about £2bn of its funds ran into severe trouble as equity markets plunged.\nAn amateur flyer had an amazing escape when his microlight aircraft hit a power cable and plunged into a field.\nPlans for the 40,000 square-foot zone include a beachside wave pool, a wild water river, two splash flumes, a lazy river ride and spa and plunge pools.\nDefinition:\nto move or make someone or something move suddenly forward and/or downward"
    },
    {
      id: 450,
      word: "tighten",
      transcription: "ˈtaɪtən",
      translation: "стискати",
      description: "Example:\nHis stomach tightens in a knot as he stumbles down the hall towards his bedroom.\nThe Germans had tightened their hold on the whole country and it became more difficult to arrange transport for the Allied soldiers.\nHe tightened the knot on his tie and brushed an imagined piece of lint off his uniform jacket.\nDefinition:\nIf you tighten your grip on something, or if your grip tightens, you hold the thing more firmly or securely."
    },
    {
      id: 451,
      word: "venture",
      transcription: "ˈventʃər",
      translation: "ризикувати",
      description: "Example:\nHis final conclusion was that he would have to venture to new planets, unfortunately, with or without Bonnie.\nWhether you interpret such behavior as capriciousness or hard-core adventure, enduring it is a price you must occasionally pay.\nI was looking for the advertising costs so I can put in an advert for my new venture!\nDefinition:\nUndertake a risky or daring journey or course of action."
    },
    {
      id: 452,
      word: "sustainable",
      transcription: "səˈsteɪnəbl̩",
      translation: "стійкий",
      description: "Example:\nMost are pessimistic that a sustainable deal will be reached and expect the dispute to escalate.\nOne project in particular planted him firmly on the path to sustainable design.\nI seek leave to table the list of 101 projects funded by the Sustainable Farming Fund.\nDefinition:\nAble to be maintained at a certain rate or level."
    },
    {
      id: 453,
      word: "stab",
      transcription: "stæb",
      translation: "спроба",
      description: "Example:\nSeveral tennis stars have had a stab at acting.\nThe elephant went on to its knees and tried to roll on top of Fay, repeatedly trying to stab him with her tusks.\nCheri felt a sudden stab of guilt.\nDefinition:\nAn attempt to do something."
    },
    {
      id: 454,
      word: "shorten",
      transcription: "ˈʃɔːrtən",
      translation: "скорочуватися",
      description: "Example:\nDo you think Setta needs to shorten his stride when approaching the ball on field goals?\nWeather effects like sand storms or heavy rain and snowfall shorten your units' line of sight and cut their air supply.\nNo drug can get the boss off your back, shorten your hours, get you more money or make a boring partner suddenly interesting.\nDefinition:\nMake or become shorter."
    },
    {
      id: 455,
      word: "shallow",
      transcription: "ˈʃæləʊ",
      translation: "мілкий",
      description: "Example:\nThe spray dribbled back into the shallow pool, and I started off home again, wiping the water off my forehead.\nJoe is a very shallow guy. During his day at school he decided that Kevin was weird because his hair is really long. Later that day, Joe told Mark he ought to display the brand he is wearing. He also decided Mark was cooler than Kevin because Mark has a Mustang and plays football.\nJon likes Jan because Jan dresses flashy.\nDefinition:\nOf little depth."
    },
    {
      id: 456,
      word: "mouthguard",
      transcription: "maʊθgɑːrd",
      translation: "капа",
      description: "Example:\nThe UI dentistry professor adds that children who participate in organized sports can lessen the likelihood of injuring their teeth by wearing a mouthguard .\nThe UI dentistry professor adds that children who participate in organized sports can lessen the likelihood of injuring their teeth by wearing a mouthguard .\nThen once you check them and their mouthguard before the fight, then once the fight's on, I suppose the main things you're looking for are factors which will produce immediate or long-term injury.\nDefinition:\nA plastic shield held in the mouth by an athlete to protect the teeth and gums."
    },
    {
      id: 457,
      word: "misfortune",
      transcription: "mɪsˈfɔːrtʃuːn",
      translation: "нещастя",
      description: "Example:\nWe feel deep sympathy for such children and lament their continuing misfortune .\nHe’s an awful misfortune of a lad.\nI got tired of waiting for my food so I lit a cigarette and, by sheer misfortunation, the waiter arrived a few seconds later.\nDefinition:\nAn unfortunate condition or event."
    },
    {
      id: 458,
      word: "Wear out",
      transcription: "weər aʊt",
      translation: "зношувати",
      description: "Example:\nMy socks have worn out.\nI’ve worn out my socks.\nMoving parts in engines wear out much more quickly than stationary parts.\nDefinition:\nUse or be used until no longer in good condition or working order."
    },
    {
      id: 459,
      word: "rafting",
      transcription: "'rɑːftɪŋ",
      translation: "сплав на човні",
      description: "Example:\nThe camp offered bicycle tours, river rafting, fishing, and hiking.\nWe went white-water rafting on the Colorado River.\nSays white-water rafting is nothing compared to taking that lot out in a rowboat.\nDefinition:\nthe use of a rubber raft to travel with the current of a river, especially as a sport:"
    },
    {
      id: 460,
      word: "petty theft",
      transcription: "ˈpeti θeft",
      translation: "дрібна крадіжка",
      description: "Example:\nThere is lots of petty theft and my neighbour next door was burgled.\nIn the last two months, they are reported to have carried out at least 13 punishment shootings in Belfast and South Armagh - often involving youths being kneecapped for joyriding, petty theft, drug taking and other offences.\nDefinition:\nthe act of stealing a large amount of inexpensive things"
    },
    {
      id: 461,
      word: "for a dare",
      transcription: "-fɔːmər -ən- deər",
      translation: "на спір",
      description: "Definition:\nnull"
    },
    {
      id: 462,
      word: "creditors",
      transcription: "ˈkredɪtərs",
      translation: "кредитори",
      description: "Example:\nAlso, the effort shows that the government is serious about forcing creditors to take a haircut on their loans and bondholdings if need be.\nAfter all, the creditors should also pay the costs of their reckless credit decisions.\nThat's because the man that gulled him has a very, very long line of creditors.\nDefinition:\nsomeone who money is owed to:"
    },
    {
      id: 463,
      word: "cashflow",
      transcription: "ˈkæʃ ˌfloʊ",
      translation: "грошовий потік",
      description: "Example:\nThe Group remains in a negative cashflow position as it used its available cash to finance capital expenditure and retire debt.\nAlthough I'm very well off myself, I do unfortunately have a temporary cashflow problem at the moment.\nHowever, many suppliers required payment upfront , which caused cashflow problems.\nDefinition:\nthe amount of money moving into and out of a business:"
    },
    {
      id: 464,
      word: "go bankrupt",
      transcription: "gəʊ ˈbæŋkrʌpt",
      translation: "збанкрутувати",
      description: "Example:\nShe fears major supermarkets will bankrupt smaller traders if the market is deregulated .\nHow many doctors are made redundant or sacked, have to change career completely, or go bankrupt?\nThe resale value of physical capital is collateral that secures the value of loans (or that reverts to bondholders , if a firm should go bankrupt).\nDefinition:\nBecome declared in law as unable to pay their debts."
    },
    {
      id: 465,
      word: "supply and demand",
      transcription: "səˈplaɪ ænd dɪˈmɑːnd",
      translation: "пропозиція та попит",
      description: "Example:\nOil prices were under further pressure yesterday due to concerns about supply and demand.\nThe laws of supply and demand take over and the price tag on vintage posters skyrockets.\nThis fact of the trading institution alters the equilibrium outcome relative to both the certain case and the case of supply and demand risk in spot markets.\nDefinition:\nsimple marketing idea based on the concept that the higher the demand and lower the supply, the higher the price. It can also be proved by the concept that the lower the demand and higher the supply, the lower the price. Is has nothing to with Linux is free and the demand supply or irrelevent since it already costs $0.00 to get and and $0.00 buy."
    },
    {
      id: 466,
      word: "make a loss",
      transcription: "meɪk ə lɒs",
      translation: "нести збитки",
      description: "Example:\nThey make a loss on the deal.\nDefinition:\nto lose money:"
    },
    {
      id: 467,
      word: "make a profit",
      transcription: "meɪk ə ˈprɒfɪt",
      translation: "отримувати прибуток",
      description: "Example:\nEvery new participant is in truth gambling on the scheme continuing long enough for him to recover his money and, he hopes, make a profit.\nhow the deuce are we to make a profit?\nIf anything comes out of this, it's the sheer lunacy of expecting to run a cheap , universal postal service in the age of electronic mail and demanding it make a profit.\nDefinition:\nMoney that is earned in trade or business after paying the costs of producing and selling goods and services:"
    },
    {
      id: 468,
      word: "back up",
      transcription: "bæk ʌp",
      translation: "підкріплювати",
      description: "Example:\nHonestly, that's exactly what happened - Claire'll back me up.\n1/Police officer shouts via radio: Shot fired, shot fired. Officer down. Unit 26 to base, we got a situation here. We need back up immediately! - Roger, just hold on. Back up are on the way.\n\n2/Before installing Smart Windows Care, we strongly recommend you to back up you data first to prevent yourself from losing important data.\nShe's backing-up to you dog! Get in\r\n\r\nLet's get on the dancefloor dog. We can back-up on those hotties over there\nDefinition:\n1/Used in military or police force: Reinforcements, support, help.\n2/Computer using: create your secured data in case the computer goes down suddenly, mainly to prevent data loss."
    },
    {
      id: 469,
      word: "interest rate",
      transcription: "ˈɪntrəst reɪt",
      translation: "процентна ставка",
      description: "Example:\nan interest rate of 5%\nIn finance news, interest rates aren't likely to rise before the end of the year, according to ANZ bank's chief economist.\nAlthough these models imply the possibility of negative interest rates, the chance is very low with well chosen parameters.\nDefinition:\nThe proportion of a loan that is charged as interest to the borrower, typically expressed as an annual percentage of the loan outstanding."
    },
    {
      id: 470,
      word: "hard up",
      transcription: "hɑːrd ʌp",
      translation: "у скрутному становищі",
      description: "Example:\nWe're a bit hard up at the moment so we're not thinking about holidays.\nHe blew into his harmonica with the microphone pressed hard up to its air outlets.\nStanding against the front wall of the house, under the eaves and hard up against a projection to avoid the worst of the wind, I watched the surface of the water dimple , just a little at first, and then more and more.\nDefinition:\nto be short of money:"
    },
    {
      id: 471,
      word: "get by",
      transcription: "get baɪ",
      translation: "зводити кінці з кінцями",
      description: "Example:\nI can’t get by on such a small salary.\nHow can he get by on so little money?\nWhen we were students we got by on very little money.\nDefinition:\nManage with difficulty to live or accomplish something."
    },
    {
      id: 472,
      word: "exorbitant",
      transcription: "ɪɡˈzɔːrbɪtənt",
      translation: "безмірний",
      description: "Example:\nHe had the cheek to tell workers their demand, which will mean a rise of as little as 30p an hour, was ‘exorbitant’.\nThe people could not give to their father and brother because of the exorbitant spending habits that they have practiced in order to fit into a worldly society.\nThe price of the eggs was very exorbitant compared to other stores.\nDefinition:\nGoing beyond what is reasonable, just, proper, usual."
    },
    {
      id: 473,
      word: "counterfeit",
      transcription: "ˈkaʊntərfɪt",
      translation: "фальшивка",
      description: "Example:\nThe games are hard to counterfeit because players must connect to a server, which can detect and reject software pirates.\nthey counterfeited dollar bills\nOh Becky look at that counterfeit over there, should we tell her her Lois is fake?\nDefinition:\nMade in exact imitation of something valuable or important with the intention to deceive or defraud."
    },
    {
      id: 474,
      word: "broke",
      transcription: "brəʊk",
      translation: "бідний",
      description: "Example:\nWhat do you mean, I've got enough money? I'm as broke as you are. \nI can't afford to go on holiday this year - I'm (flat) broke.\nMany small businesses went broke during the recession.\nDefinition:\nhaving completely run out of money:"
    },
    {
      id: 475,
      word: "break even",
      transcription: "breɪk ˈiːvn",
      translation: "покривати витрати",
      description: "Example:\nBatchelor said he was confident of City attendances of 5,440 next season to break even, particularly as season ticket sales had got off to a flying start .\nA lot of its activities either break even or lose money in order to attract visitor interest here.\nThe golf course is a good public amenity but I would query whether it could be run in a way that at least allows it to break even.\nDefinition:\nReach a point in a business venture when the profits are equal to the costs."
    },
    {
      id: 476,
      word: "bailout",
      transcription: "ˈbeɪlaʊt",
      translation: "фінансова допомога",
      description: "Example:\nThe pension agency is a safety net, not a bailout for underfunded pensions.\nSome critics complain that any such bailout would aggravate the market's decline by encouraging investors to dump even more losers.\nHe repeatedly roiled the international currency markets with offhand comments about the value of the dollar and the inadvisability of bailouts of countries like Turkey, Brazil and Argentina.\nDefinition:\na situation in which a company is given money to solve its financial problems:"
    },
    {
      id: 477,
      word: "curse",
      transcription: "kɜːrs",
      translation: "лаятися",
      description: "Example:\nHe uttered a crude four-letter curse that would rival any sailor's colorful language, then tried to roll over again.\nA few curse the memory of them as clunky, unstable, slow, unreliable and inherently unsafe.\nForget anything you may have read about the supposed advantages of Atkins, the dangers of dairy or, for that matter, the curse of cholesterol.\nDefinition:\nAn offensive word or phrase used to express anger or annoyance."
    },
    {
      id: 478,
      word: "curse",
      transcription: "kɜːrs",
      translation: "проклинати",
      description: "Example:\nHe uttered a crude four-letter curse that would rival any sailor's colorful language, then tried to roll over again.\nA few curse the memory of them as clunky, unstable, slow, unreliable and inherently unsafe.\nForget anything you may have read about the supposed advantages of Atkins, the dangers of dairy or, for that matter, the curse of cholesterol.\nDefinition:\nAn offensive word or phrase used to express anger or annoyance."
    },
    {
      id: 479,
      word: "prosperous",
      transcription: "ˈprɒspərəs",
      translation: "процвітаючий",
      description: "Example:\nAlthough it had once been a prosperous nation, it began to spiral downward after Samuel Doe's bloody coup in 1980.\nThe rest of the country might perceive areas like the Lake District to be prosperous.\nLong before Europeans arrived, it has been suggested, Australia was a prosperous land, with a high material standard of living.\nDefinition:\nSuccessful in material terms."
    },
    {
      id: 480,
      word: "starch",
      transcription: "stɑ:tʃ",
      translation: "крохмаль",
      description: "Example:\nJust so you know, slim suits look fine, but tight suits lean toward the tacky side. starching your shirt\nAvoid fatty and fried foods and stick to starchy foods like rice , potatoes and pasta.\nBy contrast to leaves, potato tubers represent a non-photosynthetic plant tissue that uses a large amount of imported sucrose to synthesize starch as the major carbon store.\nDefinition:\na complex carbohydrate found chiefly in seeds, fruits, tubers, roots and stem pith of plants, notably in corn, potatoes, wheat, and rice; an important foodstuff and used otherwise especially in adhesives and as fillers and stiffeners for paper and textiles"
    },
    {
      id: 481,
      word: "ink",
      transcription: "ɪŋk",
      translation: "чорнило",
      description: "Example:\nI have frequently been squeezed into the kerb by car drivers who think that two wheels plus four, will fit.\nThis has brought us into contact with literally thousands who think as we do.\nBut for now she wished only to remain to the scheduled plan and not think about the future with or without him.\nDefinition:\na liquid used for printing or writing or drawing"
    },
    {
      id: 482,
      word: "bars",
      transcription: "bɑː r ",
      translation: "бруси",
      description: "Example:\nI grabbed the bars again, and craned my stiff neck to look out as far as I could.\nA toothed rack rail is laid in the middle of the track on the slopes and the pinions attached to the engine engage with the teeth of the rack bars and enable the engine to pull itself and its load up.\nFortunately for us, it rained heavily in the evening so the bars closed quite early for the night and we managed to get some sleep.\nDefinition:\ngymnastic apparatus consisting of two parallel wooden rods supported on uprights"
    },
    {
      id: 483,
      word: "loan",
      transcription: "ləʊn",
      translation: "Позика",
      description: "Example:\nThe interest rate that the borrower is charged for the loan is the rate the last lender to supply money has agreed to lend at.\nIn most cases of loan default, the axe always falls on the branch manager and middle-level officers.\nTo avoid heavy losses, the banks had their captive securities firms package the loans and sell them as securities to the proverbial widows and orphans.\nDefinition:\nA thing that is borrowed, especially a sum of money that is expected to be paid back."
    },
    {
      id: 484,
      word: "scholarship",
      transcription: "ˈskɒləʃɪp",
      translation: "стипендія",
      description: "Example:\nAs an amateur , Uhalt turned down football scholarship offers to pursue professional baseball.\nKnowing the bartender as well as he did meant Paul was on full scholarship for his drinks for the night\nDefinition:\na grant or payment made to support a student's education:"
    },
    {
      id: 485,
      word: "absence",
      transcription: "ˈæbsənts",
      translation: "відсутність",
      description: "Example:\nIn love you have patience, kindness, the absence of jealousy, pride and boastfulness .\nIn the absence of brook trout, up to one of two nonnative trouts (wild brown or rainbow) would be substituted as an intolerant species.\nThe X-ray scope used to identify individual prey inside snakes also produced an image of the outline of a skink that indicated the presence or absence of a tail.\nDefinition:\nthe occurrence of an abrupt, transient loss or impairment of consciousness (which is not subsequently remembered), sometimes with light twitching, fluttering eyelids, etc.; common in petit mal epilepsy"
    },
    {
      id: 486,
      word: "bribe",
      transcription: "braɪb",
      translation: "хабар",
      description: "Example:\nI, being an observant person, had noticed that I had not been asked for a bribe lately.\nCorporations are shelling out huge bribes to politicians in the form of 'campaign financing,' however, calling a bribe by any other name is still a bribe.\nDefinition:\na sum of money or other inducement offered or given to someone:"
    },
    {
      id: 487,
      word: "stingy",
      transcription: "ˈstɪndʒi",
      translation: "скупий",
      description: "Example:\nMy dad usually was stingy with money, and had never given me more than twenty dollars for shopping before in my life.\nMeanwhile, on the same news day, we got word that while CEOs were being stingy with wages, they were going on a wild spending binge in another area: mergers.\nThis area is quite stingy with information that really should be conveyed to anyone new with the game.\nDefinition:\nunwilling to spend money:"
    },
    {
      id: 488,
      word: "swear",
      transcription: "sweər",
      translation: "лаятися",
      description: "Example:\nHe forced them to swear an oath of loyalty to him.\nBefore God, I swear I am innocent.\nWhen the cab driver started to swear at him, he walked away.\nDefinition:\nif someone swears, they use language that is considered to be rude or offensive, usually because they are angry; to make a solemn statement or promise undertaking to do something:"
    },
    {
      id: 489,
      word: "pensions",
      transcription: "ˈpentʃən",
      translation: "пенсія",
      description: "Definition:\n"
    },
    {
      id: 490,
      word: "alimony",
      transcription: "ˈælɪməni",
      translation: "аліменти",
      description: "Example:\nThe alimony award granted to his wife jeopardized Hall's ownership of his property, threatening his status as an independent producer.\nHowever, by doing so she loses the right to maintenance or alimony which a divorced woman can claim legally.\nIt appears that the rules for alimony and maintenance support are the same as between heterosexual married couples, according to Byrne.\nDefinition:\ncourt-ordered support paid by one spouse to another after they are separated"
    },
    {
      id: 491,
      word: "helical",
      transcription: "ˈhiːlɪkəl",
      translation: "спіральний",
      description: "Definition:\n"
    },
    {
      id: 492,
      word: "radiate",
      transcription: "ˈreɪdieɪt",
      translation: "випромінювати",
      description: "Example:\nWashington, D.C., residents' mail is sometimes mistakenly irradiated along with government mail.\nRow covers trap the warmth that radiates up from the earth much like the way that a cloud cover holds temperatures and prevents frost from forming.\nFor the Sun, there is no ambiguity: no such settling could explain the enormous radiated flux of light.\nDefinition:\nspread into new habitats and produce variety or variegate"
    },
    {
      id: 493,
      word: "inversely",
      transcription: "ˈɪnˈvə:slɪ",
      translation: "назад",
      description: "Definition:\n"
    },
    {
      id: 494,
      word: "bottom line",
      transcription: "ˈbɒtəm laɪn",
      translation: "підсумковий рядок",
      description: "Example:\nThe bottom line is that employers expect you to have some sense of what you want to do in terms of career goals.\nThe bottom line to this week's two-step is that Zoellick and Lamy have a long road to walk before they get back to Doha.\nSadly the bottom line is that she spends a lot of money with us and by virtue of that we have to accept her obnoxious visits.\nDefinition:\nMeans:\n\nThe final result or statement\r\nThe main or essential point\r\nThe final outcome of a process, discussion, etc\r\nThe most important or fundamental aspect of a situation"
    },
    {
      id: 495,
      word: "spending spree",
      transcription: "ˈspen.dɪŋ spriː",
      translation: "розтринькування",
      description: "Example:\nIt doesn't take a reckless person or a wild spending spree to create a debt crisis.\nUnfortunately, the thieves had had a little spending spree at Comet, running up a bill of £1000 on my Amex.\nMost of us know people who misuse their credit cards through holiday spending sprees or random acts of profligacy.\nDefinition:\nA series of high-value purchases made in a short time."
    },
    {
      id: 496,
      word: "contractor",
      transcription: "kənˈtræktər",
      translation: "підрядник",
      description: "Example:\nThe oil company began as a contractor for larger companies, servicing pipes and building scaffolding , before expanding into exploration.\nWhat is expected to happen, is that contractors will install the intelligent lamp posts in areas.\n1 - Look at this hammer - it's contractor grade.\r\n\r\n2 - Just install some contractor grade cabinets; we don't have to live in it.\nDefinition:\na person or company that supplies goods or does work for other people:"
    },
    {
      id: 497,
      word: "withdraw",
      transcription: "wɪðˈdrɔː",
      translation: "вилучати",
      description: "Example:\nTaking out a loan, do not have to withdraw money from turnover.\nIt is possible to withdraw money from an account an unlimited number of times within the limit provided by the bank.\nDefinition:\nto take money out of an account:"
    },
    {
      id: 498,
      word: "well off",
      transcription: "wel ɒf",
      translation: "заможний",
      description: "Example:\nA very well off and prosperous merchant , to be sure, but my ancestors had to work for the respect my father has now.\nI'm not really rich, said William as he paid for everyone's movie tickets, I'm just well-off.\nHer family was very well off.\nDefinition:\nto be rich and wealthy:"
    },
    {
      id: 499,
      word: "assets and liabilities",
      transcription: "ˈæsɛts ænd ˌlaɪəˈbɪlɪtiz",
      translation: "активи та пасиви",
      description: "Definition:\nnull"
    },
    {
      id: 500,
      word: "publicity stunt",
      transcription: "pʌbˈlɪsɪti stʌnt",
      translation: "рекламний трюк",
      description: "Definition:\nnull"
    },
    {
      id: 501,
      word: "shoestring budget",
      transcription: "ˈʃu:strɪŋ ˈbʌdʒɪt",
      translation: "обмежений бюджет",
      description: "Example:\n\nDefinition:\nComes from the word budget which is to manage your money, and the word minimize, which usually means you are in the act of making smaller."
    },
    {
      id: 502,
      word: "get ripped off",
      transcription: "gɛt rɪpt ɒf",
      translation: "бути пограбованим",
      description: "Example:\nHome insurance (buildings and contents cover) and mortgage payment protection insurance (accident, sickness and unemployment cover) from mortgage lenders are rip-offs , too.\nWe got ripped off buying our new car.\nDefinition:\nto cheat someone by charging too much money, or to steal something:"
    },
    {
      id: 503,
      word: "repay",
      transcription: "rɪˈpeɪ",
      translation: "погашати",
      description: "Example:\nHe promises to repay the robbed travellers, and undertakes to obtain Sir John a place in the King's army during the impending civil war.\nEntities having cash credit accounts or bill accounts can now make repayments of their credit facilities in cash instead of a cheque or draft.\nProceeds are earmarked for vessels and containers, and to repay loans.\nDefinition:\nPay back a loan, debt, or sum of money."
    },
    {
      id: 504,
      word: "inherit",
      transcription: "ɪnˈherɪt",
      translation: "успадковувати",
      description: "Example:\nFor example, a child may inherit certain traits from his parents such as height.\nThe custom is that the eldest brother inherits the largest share of the property and is responsible for taking care of the parents and ancestors.\nThat poll is an inheritance poll, you need to find one where the teams are reevaluated weekly if you want me to take it seriously.\nDefinition:\nto receive money, property, or a title as an heir at the death of the previous holder:"
    },
    {
      id: 505,
      word: "deposit",
      transcription: "dɪˈpɒzɪt",
      translation: "робити вклад",
      description: "Example:\nSome financiers ask for a deposit one to three months in advance.\nBettors deposit money in advance with the OTB and then call when they want to bet on a horse race.\nShe tensed as strong arms dragged her roughly from the vehicle, and deposited her on the freezing floor.\nDefinition:\nA sum of money placed or kept."
    },
    {
      id: 506,
      word: "funding",
      transcription: "ˈfʌndɪŋ",
      translation: "фінансування",
      description: "Example:\nIn the United States a coalition of groups of patients has argued for public funding for such research.\nDefinition:\nmoney given by a government or organization for an event or activity:"
    },
    {
      id: 507,
      word: "squander",
      transcription: "ˈskwɑːndər",
      translation: "марнувати",
      description: "Example:\nClearly, a failure of vision at this moment would squander that opportunity.\nHe thinks they have squandered unbelievable and unimaginable opportunities.\nIt'd be such a shame to squander three seasons of blinding TV…\nDefinition:\nWaste something, especially money or time in a reckless and foolish manner."
    },
    {
      id: 508,
      word: "splash out",
      transcription: "splæʃ aʊt",
      translation: "гульнути",
      description: "Example:\nIt also forces a lot of tight fisted bosses to splash out on suitable safety equipment and review their safety procedures for fear of being sued.\nSplash out by hiring a long-tail taxi boat for a personal tour of Bangkok's fascinating canals.\nAnd I was able to splash out on a whole new outfit of expensive camera equipment.\nDefinition:\nSpend money freely."
    },
    {
      id: 509,
      word: "persistent",
      transcription: "pəˈsɪstənt",
      translation: "наполегливий",
      description: "Example:\nA polar vortex is a persistent, large-scale weather pattern, likened to a jet stream on Earth in the upper atmosphere.\nMatt H., If I were to look up persistent in the dictionary I would find your name!\nI hope that dude's persistence pays off and Miss McDonald goes out with him.\nDefinition:\nContinuing firmly or obstinately in an opinion."
    },
    {
      id: 510,
      word: "dishonest",
      transcription: "dɪˈsɒnɪst",
      translation: "нечесний",
      description: "Example:\nWhat they are doing is not considered dishonest.\nHis dishonest behavior came under severe censure.\nHe's been dishonest in his dealings with us.\nDefinition:\nintended to mislead or cheat:"
    },
    {
      id: 511,
      word: "sophisticated",
      transcription: "səˈfɪstɪkeɪtɪd",
      translation: "витончений",
      description: "Example:\na sophisticated electronic control system\nAs chemistry and chemical theories became more sophisticated, scientists were able to better identify and produce various materials.\nAlien abductions, for example, was a mad belief Britons were far too sophisticated to embrace.\nDefinition:\nInvolving a great deal of worldly experience and knowledge."
    },
    {
      id: 512,
      word: "thoughtful",
      transcription: "ˈθɔːtf(ə)l",
      translation: "замислений",
      description: "Example:\nPeople think a strong man can't be sensitive, but I'm thoughtful and caring.\nLook at that jar with a brain in it. It sure is thoughtful.\nAnia: you must've have been nervous replying because you thought thought the word hi\r\nBlake: LOL\nDefinition:\ncarefully considering things:"
    },
    {
      id: 513,
      word: "impolite",
      transcription: "ˌɪmpəlˈaɪt",
      translation: "неввічливий",
      description: "Example:\nHe went out of his way to be just as impolite and insolent as he could be.\nThe voice was tired and bored, but not impolite.\nWestern influence has made Chinese people feel that it is impolite to ask a person's age.\nDefinition:\nNot having or showing good manners."
    },
    {
      id: 514,
      word: "bug",
      transcription: "bʌg",
      translation: "дратувати",
      description: "Example:\nI only did it to bug my parents.\nJeffrey borrows a bug sprayer from his father's hardware store and convinces Dorothy to let him in to spray the kitchen.\nHe fell in love with Bening on screen, then auditioned her for the role of his lover in the film Bugsy.\nDefinition:\n1. An error in a computer program or system.\n2. If someone or something bugs you, they worry or annoy you."
    },
    {
      id: 515,
      word: "get to",
      transcription: "get tuː",
      translation: "братися за щось",
      description: "Example:\nYou’re getting to be just like your mother.\nI did get to walk on the beach at night and it was as beautiful as I was expecting it to be.\nthe fun part is trying to work out how to get to the airport\nDefinition:\nto begin to do or be"
    },
    {
      id: 516,
      word: "go against",
      transcription: "gəʊ əˈgentst",
      translation: "заперечувати",
      description: "Example:\nThe plaintiff began proceedings against the Chief Constable claiming damages for wrongful arrest and false imprisonment.\nLooking at his credentials, few would probably argue if Lambie was tagged a miracle worker , but considering his tendency to go against the grain it is unsurprising that the man himself would.\nThey're quite formal and arch so they go against my grain.\nDefinition:\nOppose or resist."
    },
    {
      id: 517,
      word: "go about",
      transcription: "gəʊ əˈbaʊt",
      translation: "зайнятися",
      description: "Example:\nHow can we go about solving this problem?\nHe quickly began thinking of how to go about teaching his first dance lesson ever.\nDecent people should be able to conduct their business and go about their work without being in danger .\nDefinition:\nTo begin to do something or deal with something."
    },
    {
      id: 518,
      word: "excitable",
      transcription: "ɪkˈsaɪtəbl̩",
      translation: "збудливий",
      description: "Example:\nHe is a very excitable young man who absolutely loves what he does.\nNever come between an excitable cow/heifer and her calf and never ever turn your back on a nervous animal in a small space.\nA man is sometimes very excitable and prone to anger for trivial reasons.\nDefinition:\nResponding rather too readily to something new or stimulating; too easily excited."
    },
    {
      id: 519,
      word: "deceitful",
      transcription: "dɪˈsiːtfəl",
      translation: "підступний",
      description: "Example:\nPeople have been known to be deceitful about many things on the Internet.\nShe'd obviously met a bad bunch, for McCabe is immoral, deceitful and sly .\nThose raised in urban Western understanding of the psychology of the animal kingdom tend to view the fox as a cunning, sly , deceitful animal.\nDefinition:\nGuilty of or involving deceit; deceiving or misleading others."
    },
    {
      id: 520,
      word: "coward",
      transcription: "ˈkaʊərd",
      translation: "Боягуз",
      description: "Example:\nLoman is a rather unpleasant figure throughout much of the play, a boastful blowhard, a bully, a coward.\nTyler Joseph is such a coward! He is also a pieceof shof but lots of love\nNo man abandons his family w/o warning during times of suffering, that is what you call a coward.\nDefinition:\nA person who lacks the courage to do or endure dangerous or unpleasant things."
    },
    {
      id: 521,
      word: "belligerent",
      transcription: "bəˈlɪdʒərənt",
      translation: "войовничий",
      description: "Example:\nIt is based upon the customary international laws of belligerent occupation, including the Hague Regulations.\nEven between belligerent states, such treaties will not necessarily be suspended; a fortiori, if the conflict is not international, treaty rules will in general continue to apply.\nIt is widely recognized that access by belligerent groups to the gains from drug production and trafficking contributes to the intensity and prolongation of military conflict.\nDefinition:\nEngaged in a war or conflict, as recognized by international law."
    },
    {
      id: 522,
      word: "bearing",
      transcription: "ˈberɪŋ",
      translation: "поведінка",
      description: "Example:\nShe has the bearing of a First Lady.\nThese last are well worth waiting for; the flower spikes can be up to nine feet tall, bearing stately heads of rich purple, thistle-like flowers above the toothed , grey green foliage.\nIt was a point worth bearing in mind, and so was the way in which the local communities kept the high road cleared of snow in their vicinities .\nDefinition:\nThe way one behaves or conducts oneself."
    },
    {
      id: 523,
      word: "affect",
      transcription: "əˈfekt",
      translation: "впливати",
      description: "Example:\nThese flow-rate differences affect the glaciers' surface topography.\nThis edema affects many organs, including the brain , kidneys, liver, and lungs.\nIf the growth is large, then it may have caused more damage and this sometimes leads to some loss of hearing in the affected ear .\nDefinition:\nHave an effect on; make a difference to."
    },
    {
      id: 524,
      word: "act up",
      transcription: "ækt ʌp",
      translation: "бешкетувати",
      description: "Example:\nHe ruffled some feathers by suggesting ‘if blogging is to go mainstream, bloggers will have to sharpen their act up considerably’.\n‘Impact upon his body’ can mean an auto accident, a fall, a punch , a blow, or a gunshot.\nIt allows us to entertain the idea of rebellion, diffusing that feeling without having to act upon it.\nDefinition:\nMisbehave."
    },
    {
      id: 525,
      word: "trait",
      transcription: "treɪt",
      translation: "риса характеру",
      description: "Example:\nPatience is one of his best traits.\nHis sense of humor is one of his better traits.\nArrogance is a very unattractive personality trait.\nDefinition:\na characteristic feature of a personality:"
    },
    {
      id: 526,
      word: "pastime",
      transcription: "ˈpɑːstaɪm",
      translation: "приємне проведення часу",
      description: "Example:\nThe sociable, friendly atmosphere of most campsites means that the pastime is ideal for those looking to make new friends, or for something more.\nhis main pastime is gambling\n1776, Adam Smith, The Wealth of Nations: Hunting and fishing, the most important employments of mankind in the rude state of society, become in its advanced state their most agreeable amusements, and they pursue for pleasure what they once followed from necessity. In the advanced state of society, therefore, they are all very poor people who follow as a trade what other people pursue as a pastime.\nDefinition:\nAn activity that someone does regularly for enjoyment rather than work; a hobby."
    },
    {
      id: 527,
      word: "dissapointed",
      transcription: "ˌdɪsəˈpɔɪntɪd",
      translation: "розчарований",
      description: "Example:\nYou: Ugh i'm so dissapointed.\r\nMe: IT'S DISAPPOINTED......\nYou're a dissapointment\nMcDonald's workers took boxes and shoved them in their cars. Everyone one got mad and felt dissapointment.\nDefinition:\nThe wrong way to spell disappointed."
    },
    {
      id: 528,
      word: "posh",
      transcription: "pɒʃ",
      translation: "розкішний",
      description: "Example:\nLuckily, the hotel was so posh that the concierge was happy to get a member of staff to drive me home.\nThere is the odd posh word on the menu but most dishes are properly explained and do exactly what they say on the label.\nA posh stationers in London's Covent Garden has unveiled an ‘interactive shop window’ which lets window shoppers see what's on offer before going into the store.\nDefinition:\nElegant or stylishly luxurious."
    },
    {
      id: 529,
      word: "put off",
      transcription: "pʊt ɒf",
      translation: "відкладати",
      description: "Example:\nJohn: Sorry, but I've just missed my flight and our meeting starts at 3pm.\r\n\r\nJane: Don't worry John, we can put off this meeting for tomorrow.\nTossing in elements of blues, rock, glam-rock, soul and metal, it's a wildly extravagant affair that is likely to put off as many people as it delights.\nIt's a big let-down for people who have had to put up with the inconvenience, the noise and the roadworks and what if it's put off again until the spring?\nDefinition:\nDelay doing something."
    },
    {
      id: 530,
      word: "picky",
      transcription: "ˈpɪki",
      translation: "прискіпливий",
      description: "Example:\nNot only was I a picky eater but it just didn't seem to appeal to me.\nIf your child's a picky eater, pay attention to the foods he or she especially likes and adapt the menu as these preferences change.\nThis apparently made it good enough for my picky eaters, and they polished off the whole bowl in minutes.\nDefinition:\nexacting especially about details"
    },
    {
      id: 531,
      word: "cause a scene",
      transcription: "kɔːz ə siːn",
      translation: "влаштувати сцену",
      description: "Example:\nshe'd rather die than cause a scene\nI did it 'cause I felt like doing it.\nPerson one why did you do that?\r\nPerson two just cause\nDefinition:\nTo attract attention(in a bad way)in public."
    },
    {
      id: 532,
      word: "lifehack",
      transcription: "ˈlaɪfˌhæk",
      translation: "лайфхак",
      description: "Example:\nCheck out these 7 lifehacks using only paper clips!\n5 Minute Craft Lifehacks are so stupid, I did one of the pop-socket ones and my phone case melted.\n5 Minute Craft Lifehacks are so stupid, I did one of the pop-socket ones and my phone case melted.\nDefinition:\nany procedure or action that solves a problem:"
    },
    {
      id: 533,
      word: "overreact",
      transcription: "ˌəʊvəriˈækt",
      translation: "надто гостро реагувати",
      description: "Example:\nBut there have been counterclaims that Mr Hughes has overreacted and has aggravated villagers.\nDon't overreact to the bad news--take it easy\nDefinition:\nIf you say that someone overreacts to something, you mean that they have and show more of an emotion than is necessary or appropriate."
    },
    {
      id: 534,
      word: "obsessive",
      transcription: "əbˈsesɪv",
      translation: "одержимий",
      description: "Example:\nobsessive gambling\nThere may also be inappropriate use of toys, obsessive spinning of objects or attachment to inanimate objects.\nHe is shy, obsessive, self-critical to the point of parody, and liable to spontaneously combust when confronted by anyone who fails to meet his standards.\nDefinition:\ncharacterized by or constituting an obsession"
    },
    {
      id: 535,
      word: "anti-social",
      transcription: "ˌæntiˈsəʊʃəl",
      translation: "асоціальний",
      description: "Example:\nHe said the public need to distinguish between a one-off caper and persistent anti-social behaviour.\nLitter on our streets, anti-social behaviour, dereliction - we all know what is wrong with our town.\nNow, being the anti-social person I have never been to a social event besides a dance .\nDefinition:\nSomeone who doesn't feel comfortable around other people. They would rather do something more productive with thier time rather then hanging out with people they don't really like."
    },
    {
      id: 536,
      word: "paranoid",
      transcription: "ˈpærənɔɪd",
      translation: "параноїдальний",
      description: "Example:\nI am now so paranoid at not paying a fine I will avoid the place.\nThey are dishonest, misleading, factually incorrect , selective with data and paranoid.\nParks should be fun places to go but I'm always paranoid when taking children there.\nDefinition:\nIf you say that someone is paranoid, you mean that they are extremely suspicious and afraid of other people."
    },
    {
      id: 537,
      word: "weigh up",
      transcription: "weɪ ʌp",
      translation: "оцінювати",
      description: "Example:\nSome want to question, to weigh up the alternatives, to perhaps seek a second opinion.\nSome want to question, to weigh up the alternatives, to perhaps seek a second opinion.\nHence they are not easy to weigh up their adversarial effects which are not known by the agency of action and at the time of the action.\nDefinition:\nto think carefully about the advantages or disadvantages of a situation before making a decision:"
    },
    {
      id: 538,
      word: "unburden",
      transcription: "ʌnˈbɜːrdən",
      translation: "висловити",
      description: "Example:\nI just felt the need to unburden myself, that's all.\nI just felt the need to unburden myself, that's all.\nHe clearly wanted to unburden himself about the way Labour governs the country and Parliament's ‘shameful’ inability to control the executive.\nDefinition:\nRelieve or make free one's mind, oneself, etc of a worry, trouble, etc, by revelation or confession."
    },
    {
      id: 539,
      word: "spiteful",
      transcription: "ˈspaɪtfl",
      translation: "злісний",
      description: "Example:\nThe early exchanges were spiteful , nasty and never fully controlled by referee Lucilio Batista.\nYou are beginning to discover that some people can be jealous and spiteful and envious .\nThis takes Kerry several steps past merely being a sore loser, and into spiteful malevolence .\nDefinition:\nShowing or caused by malice."
    },
    {
      id: 540,
      word: "shrewd",
      transcription: "ʃruːd",
      translation: "кмітливий",
      description: "Example:\nShe differed from all the other models I had met in that she didn't take drugs and possessed a talent for shrewd observation .\nAll of us, that is, have a child-reader within asking shrewd and impertinent questions.\nMrs. Drollmere had been a lively woman with a shrewd and witty sense of humour.\nDefinition:\nHaving or showing sharp powers of judgment; astute."
    },
    {
      id: 541,
      word: "moody",
      transcription: "ˈmuːdi",
      translation: "примхливий",
      description: "Example:\nThe pills he is taking seem to make him more and more moody.\nThe sky overhead was overcast with great gray clouds, and the atmosphere was actually kind of moody.\nDefinition:\nif someone is moody, their moods change suddenly and they become angry or unhappy easily:"
    },
    {
      id: 542,
      word: "misbehave",
      transcription: "ˌmɪsbɪˈheɪv",
      translation: "погано поводитися",
      description: "Example:\nIn most cases, when the children misbehave they are abused and the real problem is never addressed with love and affection.\nThey had all eaten poisonous mushrooms for supper, except the boy, who was denied supper as a punishment, because he had misbehaved.\nI should mention before I go through with this final act of attrition that if I misbehaved so egregiously over the past year, it must certainly reflect negatively on you both as parents.\nDefinition:\nFail to conduct oneself in a way that is acceptable to others; behave badly."
    },
    {
      id: 543,
      word: "jittery",
      transcription: "ˈdʒɪtəri",
      translation: "полохливий",
      description: "Example:\nYou're jittery, and shaky, and always seem slightly nervous about something.\nIn the jittery start both sides were guilty of handling errors but Keighley had the best of the early play.\nDefinition:\nNervous or unable to relax."
    },
    {
      id: 544,
      word: "scream",
      transcription: "skriːm",
      translation: "кричати",
      description: "Example:\nEthan looked kind of nervous, I had the sudden urge to jump up and scream boo just to see what he'd do.\nThe scream carried a vain hope that someone would do something to intervene.\nBehind that sound, hidden in it, was the thin , faint sound of a woman's distant scream, coming from inside the building.\nDefinition:\nCry something in a high-pitched, frenzied way."
    },
    {
      id: 545,
      word: "deceitful",
      transcription: "dɪˈsiːtfəl",
      translation: "оманливий",
      description: "Example:\nPeople have been known to be deceitful about many things on the Internet.\nShe'd obviously met a bad bunch, for McCabe is immoral, deceitful and sly .\nThose raised in urban Western understanding of the psychology of the animal kingdom tend to view the fox as a cunning, sly , deceitful animal.\nDefinition:\nGuilty of or involving deceit; deceiving or misleading others."
    },
    {
      id: 546,
      word: "due to",
      transcription: "dju: tu:",
      translation: "по причині",
      description: "Example:\nI had randomly approached him and had a little conversation with him due to a dare Riley had challenged me to.\nMr Murphy said they agreed it was a nuisance and were due to return to take further measurements.\nAnd work is now due to start on the ambitious project to meet the timescale for claiming the award.\nDefinition:\nWhen the thing you're doing Is done or something is coming"
    },
    {
      id: 547,
      word: "throw up",
      transcription: "θrəʊ ʌp",
      translation: "вирвати",
      description: "Example:\nSuddenly there is laughter, cheering and pointing and I strain to see what has happened - the first soldier to throw up is using his airsickness bag .\nThat is why it is important to throw up pioneering ideas so the government will be able to see this as a force for change and a chance to seize a lead for Britain.\nOccasionally it will throw up a great line but the change will take it away to messy confusion.\nDefinition:\nVomit."
    },
    {
      id: 548,
      word: "get drunk",
      transcription: "get drʌŋk",
      translation: "напиватися",
      description: "Example:\nFaced with such an event, most of us just swallow our feelings, or go out and get drunk or whatever.\nThe urge was there all right, to buy the cheapest illegal liquor and get drunk in the afternoon.\nThat's a lot of pressure to be putting on kids who basically just want to get drunk, hang out, and cruise chicks.\nDefinition:\nto intoxicate oneself with alcohol:"
    },
    {
      id: 549,
      word: "withdrawal symptoms",
      transcription: "wɪðˈdrɔːəl ˈsɪmptəms",
      translation: "ломка",
      description: "Example:\nSome chronic users become addicted and exhibit severe withdrawal symptoms that require detoxification.\nIt blocks the effects of nicotine but does not precipitate withdrawal symptoms.\nBut a vaccine against nicotine could help reduce withdrawal symptoms and cravings by interrupting the addictive process in the brain.\nDefinition:\nthe unpleasant physical and mental effects that result when you stop doing or taking something, especially a drug, that has become a habit"
    },
    {
      id: 550,
      word: "craving",
      transcription: "ˈkreɪvɪŋ",
      translation: "пристрасне бажання",
      description: "Example:\nAnother motive, the sordid one, is the craving for gossip, particularly the naughty kind.\nMaybe I've been renting too many teen movies , but I'm craving my slice of the American pie.\nWhile it will satisfy a chicken craving, the food is a pale imitation of fiery Jamaican fare and not as straightforward as your average rotisserie.\nDefinition:\nA powerful desire for something."
    },
    {
      id: 551,
      word: "burp",
      transcription: "bɜːp",
      translation: "відрижка",
      description: "Example:\nThe baby gave a contented burp.\nwhen I burp it smells like garlic.\nTracy : -burps-\r\nNathalie : Ewl ! Tracy !\r\nTracy : Oops, sorry. It's just that I burp around people who I'm close with, like you.\r\n\nDefinition:\nto allow air from the stomach to come out through the mouth in a noisy way"
    },
    {
      id: 552,
      word: "get hooked",
      transcription: "get hʊkt",
      translation: "підсісти",
      description: "Example:\nOne of the questions that has troubled me is why people get hooked on unhealthy food.\nGuy:Ayo have you heard of the guy named habebe\n\nOther Guy:Ha ha!! You watch him too! Get hooked on habebe bro!\nWe went on a date last night and I am totally hooked\nDefinition:\nEnjoying something so much that you are unable to stop having it, watching it, doing it, etc.:"
    },
    {
      id: 553,
      word: "junkie",
      transcription: "ˈdʒʌŋki",
      translation: "наркоман",
      description: "Example:\nI've broken away from that whole junkie crowd\nRush Limbaugh is a junkie. \nDefinition:\nsomeone who cannot stop taking illegal drugs"
    },
    {
      id: 554,
      word: "hangover",
      transcription: "ˈhæŋoʊvər",
      translation: "Похмілля",
      description: "Example:\nA hangover should be the least of men's worries after a night on the booze , according to new research.\n*Individual with hangover holds head firmly in hands to prevent cranial overexpansion, and chews on entire contents of Tylenol bottle while kneeling before the porcelain god* \r\n“Why god? Why? It seemed like such a good idea last night. I promise I’ll never drink again…so long as I live.”\r\n*Washes Tylenol down with a bottle of Pepto-Bismol between dry heaves* \r\n\r\nWaking up drunk just isn't the same as going to sleep drunk!\nDefinition:\nA severe headache or other after effects caused by drinking an excess of alcohol."
    },
    {
      id: 555,
      word: "gain weight",
      transcription: "geɪn weɪt",
      translation: "повнішати",
      description: "Example:\nYou're born with balance, but bad habits like depriving yourself of the foods you need or ignoring high stress levels can upset that balance and cause you to gain weight.\nPeople who stop smoking can gain weight simply because smoking suppresses the appetite and increases the metabolism.\nSo sedentary people often gain weight gradually.\nDefinition:\nAn increase in body weight."
    },
    {
      id: 556,
      word: "fidget",
      transcription: "ˈfɪdʒət",
      translation: "занепокоєння",
      description: "Example:\nhe's got the fidgets\nThe child is always fidgeting in his seat\nMy fingers fidgeted with the white, cloth napkin in my lap.\nDefinition:\nA state of mental or physical restlessness or unease."
    },
    {
      id: 557,
      word: "disrupt",
      transcription: "dɪsˈrʌpt",
      translation: "порушувати",
      description: "Example:\nDell Inc. disrupted the traditional way of selling computers by switching to the internet.\nI just played Disrupt and I felt like a real hacker.\nWe are creating a 3D World, where Data and Digital combine to Disrupt current business models. Only when that happens, you actually see Disruption at work.\nDefinition:\nto change the traditional way that an industry operates, especially in a new and effective way:"
    },
    {
      id: 558,
      word: "compulsive gambler",
      transcription: "kəmˈpʌlsɪv ˈgæmblər",
      translation: "ігроман",
      description: "Example:\nStevens was a compulsive gambler.\nBut some people fear they could be the breeding ground for the compulsive gamblers of the future.\nI have no tolerance for compulsive gamblers, this stemming from a personal experience with one.\nDefinition:\nA person who gambles."
    },
    {
      id: 559,
      word: "chickenpox",
      transcription: "ˈtʃɪkɪnpɑːks",
      translation: "вітрянка",
      description: "Example:\nMeasles, mumps, rubella and chickenpox can all be far more serious if you contract them as an adult.\nHe was emphatic that chickenpox was not a milder version of smallpox and that the two were distinct maladies .\nVery rarely, an adult with chickenpox develops brain inflammation called encephalitis .\nDefinition:\nAn infectious disease causing a mild fever and a rash of itchy inflamed pimples which turn to blisters and then loose scabs. It is caused by the herpes zoster virus and mainly affects children."
    },
    {
      id: 560,
      word: "barefoot",
      transcription: "ˈberfʊt",
      translation: "босоніж",
      description: "Example:\nSometimes in summer she would sit on the kitchen step, barefoot, running her toes absent-mindedly in the dust, losing herself in a book.\nSometimes in summer she would sit on the kitchen step, barefoot, running her toes absent-mindedly in the dust, losing herself in a book.\nYou had to go barefoot in the temple, and with food offerings on the floor the place was swarming with ants .\nDefinition:\nWearing nothing on the feet."
    },
    {
      id: 561,
      word: "alcohol abuse",
      transcription: "'ælkəhɑːl əˈbjuːz",
      translation: "зловживання алкоголем",
      description: "Example:\nDawn's father was put into rehab for alcohol abuse\nManchester's war on binge drinking has been held up as a model for other cities as a new report reveals the true cost of alcohol abuse.\nThe group aims to prevent drug and alcohol abuse, educate people and provide information about the laws on drugs.\nDefinition:\nThe habitual excessive use of alcohol."
    },
    {
      id: 562,
      word: "worth",
      transcription: "wɜːθ",
      translation: "цінність",
      description: "Example:\nemil has worth\nA: Are you coming to the show tonight?\r\nB: maybe...is it worth?\r\nA: of course it's worth!!\r\nB: alright I'll be there\nMan, that dude is so not worth\nDefinition:\nFrench couturier (born in England) regarded as the founder of Parisian haute couture; noted for introducing the bustle (1825-1895)"
    },
    {
      id: 563,
      word: "kidney",
      transcription: "ˈkɪdnɪ",
      translation: "нирка",
      description: "Example:\nThis edema affects many organs, including the brain , kidneys, liver, and lungs.\na steak and kidney pudding\nThe cancer can then progress by metastasizing into the liver, kidney, pancreas, lung, stomach and intestine .\nDefinition:\neither of two bean-shaped excretory organs that filter wastes (especially urea) from the blood and excrete them and water in urine"
    },
    {
      id: 564,
      word: "wound",
      transcription: "wuːnd",
      translation: "рана",
      description: "Example:\nI don't want to reopen that wound with any sort of false hope.\nHe had a deep wound in his arm and had lost a lot of blood.\nDefinition:\nan injury to living tissue caused by a cut, blow, or other impact, typically one in which the skin is cut or broken:"
    },
    {
      id: 565,
      word: "cone",
      transcription: "koʊn",
      translation: "шишка",
      description: "Example:\nWe saw a statue shaped like a giant cone in the city park.\nThe children were learning about shapes, including cones and spheres.\nThe artist used cones and other geometric shapes in his sculptures.\nDefinition:\na shape with a flat, round bottom and sides that go up to a point:"
    },
    {
      id: 566,
      word: "look forward",
      transcription: "lʊk ˈfɔːwəd",
      translation: "чекати з нетерпінням",
      description: "Example:\nWe look forward to a very rewarding relationship with them.\nAs a member of a contemplative religious order spending time in silence is nothing strange to me, and is something I look forward to.\nBut Liverpool fought like tigers and erupted in joy at the final whistle, with an all-English semi-final to look forward to.\nDefinition:\nAwait eagerly."
    },
    {
      id: 567,
      word: "walnut",
      transcription: "ˈwɔ:lnʌt",
      translation: "волоський горіх",
      description: "Example:\nI like to eat walnuts\nShe is such a walnut.\nGuy 1: How was last night?\r\nGuy 2: So good bro, Handy Mandy gave me the walnut of a lifetime\nDefinition:\nany of various trees of the genus Juglans"
    },
    {
      id: 568,
      word: "roast",
      transcription: "rəʊst",
      translation: "запікати",
      description: "Example:\nThe menu includes roast beef, vegetable curry, smoked salmon, Japanese noodles in cold soup, and fried noodles and small hamburgers for children.\nI roasted the vegetables with some olive oil.\nHis former students roasted the professor at his 60th birthday\nDefinition:\nto cook food in an oven or over a fire:"
    },
    {
      id: 569,
      word: "necessary",
      transcription: "ˈnesəseri",
      translation: "необхідно",
      description: "Example:\nIf necessary, your child's doctor may prescribe medicines.\nPeople started to realize the basic game center could move to life support instead of death support and it was now necessary to work for only 6 hours per year instead of the current 2,000, to support war mongers.\nMike: Hey, how was the Red Sox- Angels game last night?\n\nJohn: The game was if necessaried; the Angels already swept.\n\nMike: Ahh, that sucks.\nDefinition:\nNeeded to be done or present"
    },
    {
      id: 570,
      word: "pity",
      transcription: "ˈpɪti",
      translation: "Жаль",
      description: "Example:\nthe blind are too often objects of pity\nI pity him so i walked over to him and talked to him \nMe:I made out with a fat chick.\r\nMr.T:I pity the fool\r\nMe: points at self\r\nMr.T:Nods head\nDefinition:\na feeling of sympathy and sorrow for the misfortunes of others"
    },
    {
      id: 571,
      word: "dread",
      transcription: "dred",
      translation: "боятися",
      description: "Example:\nthe dread presence of the headmaster\npolio is no longer the dreaded disease it once was\na dreadful storm\nDefinition:\ncausing fear or dread or terror"
    },
    {
      id: 572,
      word: "obesity",
      transcription: "əʊˈbiːsɪti",
      translation: "ожиріння",
      description: "Example:\nIntrauterine life is a critical period for the development of obesity later in life.\nmichael moore is obese\nUsage: That trucker is one motherf-cker that is f-ckin riddled by obesity, f-ck.\nDefinition:\nThe state of being grossly fat or overweight."
    },
    {
      id: 573,
      word: "object to",
      transcription: "əbˈdʒɛkt tuː",
      translation: "заперечувати",
      description: "Example:\nA lot of people will object to the book.\nI swear, if she didn't give it up soon I was going to brain her with the nearest object to hand.\nWe wish to object to the disgusting sight we have to put up with whenever we look out of our window.\nDefinition:\nto say something to express one's opposition to or disagreement with something:"
    },
    {
      id: 574,
      word: "let down",
      transcription: "let daun",
      translation: "розчаровувати, підводити",
      description: "Example:\nhe was let down by an erratic serve\nOut of the corner of my eye, I caught sight of Fiona in her violet dress, hair let down nicely .\nThis will mean no more steps at the entrance, wider corridors , wider doors and a toilet downstairs.\nDefinition:\nA very bad decision by a certain person that makes others very disappionted"
    },
    {
      id: 575,
      word: "Feast",
      transcription: "fiːst",
      translation: "свято",
      description: "Example:\nIt looks like some kind of wedding feast.\nThe king invited them to a feast in the palace.\nMay you have a feastful Thanksgiving!\n\nI hope your party is a feastful one.\nDefinition:\na special meal with very good food or a large meal for many people:"
    },
    {
      id: 576,
      word: "pig out",
      transcription: "pɪg aʊt",
      translation: "об'їдатися",
      description: "Example:\nlovesick people pig out on chocolate\nYou crave steak because you need protein, scarf up sardines for the salt, and pig out on potatoes because they are energy-dense.\nJodrey loved to go to Baja Fresh and pig out until his buddies had to carry him out.\nDefinition:\nEat a large amount of food."
    },
    {
      id: 577,
      word: "presumed",
      transcription: "prɪˈzjuːm",
      translation: "передбачувано",
      description: "Example:\nThose stories, I never enjoyed them as much as she presumed - it was too ideal to be a reality.\nPoor Hinewai, still an invalid, asthmatic and bronchitic , her son, the mischief boy, first missing, presumed dead, then years afterwards reported alive and now - here he was in front of her again, but once more turning away…\nThis must represent the child's presumed will and may be revoked at any time without detriment to the child.\nDefinition:\nA word in which only goats may use"
    },
    {
      id: 578,
      word: "pet peeve",
      transcription: "pet piːv",
      translation: "джерело роздратування",
      description: "Example:\n\nDefinition:\nSomething that a particular person finds especially annoying."
    },
    {
      id: 579,
      word: "Nervous breakdown",
      transcription: "ˈnɜːvəs ˈbreɪkdaʊn",
      translation: "нервовий зрив",
      description: "Example:\nThe next year he again failed the exam and, according to some historians, had a nervous breakdown.\nThe situation was so disconcerting to Wade that he suffered a nervous breakdown and went on disability .\nThis is the basic physics, but Einstein said it nearly gave him a nervous breakdown.\nDefinition:\na period of mental illness in which somebody becomes very depressed, anxious and tired, and cannot deal with normal life"
    },
    {
      id: 580,
      word: "comfort food",
      transcription: "ˈkʌmfət fuːd",
      translation: "їжа для підняття настрою",
      description: "Example:\nI would serve comfort foods using local produce, seafood, etc. trying to use organic ingredients.\nThere's very little on the menu that will have you rushing home to experiment, but there are plenty of old reliables and comfort food.\nA bowl of shiny red apples suggests comfort food and good down-home cooking .\nDefinition:\nIf you call something comfort food, you mean it is enjoyable to eat and makes you feel happier, although it may not be very good for your health."
    },
    {
      id: 581,
      word: "complain about",
      transcription: "kəmˈpleɪn əˈbaʊt",
      translation: "скаржитися",
      description: "Example:\nHis attention to detail was second to none and not once did anyone complain about his ability to tell it as it was.\nNot once did he complain about me blocking his view even though I kept moving to look up.\nMost call-centre vehicles do have phone numbers displayed, to complain about rash driving.\nDefinition:\nTo say that something is wrong or not satisfactory."
    },
    {
      id: 582,
      word: "relapse",
      transcription: "rɪˈlæps",
      translation: "знову захворіти",
      description: "Example:\nThe fully recovered individuals show symptoms of neither alcohol dependence nor alcohol abuse and either abstain or drink at levels below those known to increase relapse risk.\nIn withdrawal , stronger neurological activity creates the desire to relapse, or return to an addictive habit.\nDefinition:\nIf you say that someone relapses into a way of behaving that is undesirable, you mean that they start to behave in that way again."
    },
    {
      id: 583,
      word: "overdo",
      transcription: "ˌəʊvəˈduː",
      translation: "перестаратися",
      description: "Example:\ni tend to overdo things often, i tried contacting my therapist about it but she said its natural\nHe shouldn't overdo it, though: The flatter the backswing, the easier it is to hook the ball.\nBut North Yorkshire coroner Geoff Fell recorded an open verdict, saying he was not convinced the overdose had anything to do with toothache .\nDefinition:\nDo, use, or carry to excess."
    },
    {
      id: 584,
      word: "work out",
      transcription: "wɜːk aʊt",
      translation: "тренуватися",
      description: "Example:\nAnalyze competitors' activity; work out your opposition ways of action.\nI try to work out twice a week.\nMake sure you drink plenty of water if you are working out.\nDefinition:\nengage in vigorous physical exercise; if you work out a solution to a problem or mystery, you manage to find the solution by thinking or talking about it:"
    },
    {
      id: 585,
      word: "get high",
      transcription: "get haɪ",
      translation: "поринути у стан наркотичного сп'яніння",
      description: "Example:\nI can't get high on my wedding day.\nperson 1: where do you go to school?\r\nperson 2: hey man i go to GET high\nNate: hey g-dogg, let's go get high on some get high\r\nG-dogg: swell\nDefinition:\nTo achieve a state of mental euphoria, as from substance intoxication (most often in reference to marijuana)."
    },
    {
      id: 586,
      word: "lean meat",
      transcription: "liːn miːt",
      translation: "пісне м'ясо",
      description: "Example:\nBut no, it was plain wholesome gravy and with a clean plate in front of her, Ann's verdict was ‘delicious’ for a pudding full of lean meat.\nIt was definitely home-made, full of lean meat, plenty of kidney and rich gravy.\nChoose lean meats, poultry without skin, liquid plant oils instead of hydrogenated oils or butter, and skim-milk dairy foods.\nDefinition:\nLean meats are meats with a relatively low fat content."
    },
    {
      id: 587,
      word: "sweet tooth",
      transcription: "swiːt tuːθ",
      translation: "пристрасть до солодкого",
      description: "Example:\nThe restaurant does not use sugar, but only its substitutes like jaggery, honey, dates or palm jaggery to tickle the sweet tooth .\nThey're also packed with protein and low in carbs and fat, so you can build muscle, stay lean , and satisfy your sweet tooth at the same time.\nFor the average consumer, it seems like a win-win situation, satisfying the sweet tooth and virtually calorie-free.\nDefinition:\nA great liking for sweet-tasting foods."
    },
    {
      id: 588,
      word: "sleepwalker",
      transcription: "ˈsliːpwɔːkər",
      translation: "лунатик",
      description: "Example:\nMankind, divided and confused, still hesitates , vacillates like a sleepwalker on the edge of an abyss.\nlook at there eyes\nSpoon sleepwalker\nDefinition:\nA person who sleepwalks."
    },
    {
      id: 589,
      word: "side effect",
      transcription: "saɪd ɪˈfekt",
      translation: "побічний ефект",
      description: "Example:\nShe thinks the only lasting side effect from the treatment may be some memory loss.\nMost patients experience temporary side effects which usually end within three days.\nBut apparently they must list the reported side effects to any of the active ingredients in the medicine.\nDefinition:\nA secondary, typically undesirable effect of a drug or medical treatment."
    },
    {
      id: 590,
      word: "pig out",
      transcription: "pɪg aʊt",
      translation: "об'їдатися",
      description: "Example:\nlovesick people pig out on chocolate\nYou crave steak because you need protein, scarf up sardines for the salt, and pig out on potatoes because they are energy-dense.\nJodrey loved to go to Baja Fresh and pig out until his buddies had to carry him out.\nDefinition:\nEat a large amount of food."
    },
    {
      id: 591,
      word: "pick at",
      transcription: "pɪk ət",
      translation: "чіплятися",
      description: "Example:\nI guess if you wanted to pick at him, you could say he still takes it upon himself to do too many things.\nI guess if you wanted to pick at him, you could say he still takes it upon himself to do too many things.\nGood defense, majority of the time, makes a quarterback throw a pick.\nDefinition:\nMake criticisms of in a niggling or petty manner."
    },
    {
      id: 592,
      word: "numb",
      transcription: "nʌm",
      translation: "оніміти",
      description: "Example:\nWhat everyone wants to know is when we'll be able to get to work without hat hair and a numb face.\nim jus so numb\nSince I drank so much alchohol that night, I ran into a truck and didn't feel a thing!\nDefinition:\nDeprive of feeling or responsiveness."
    },
    {
      id: 593,
      word: "cancer",
      transcription: "ˈkæntsər",
      translation: "Рак",
      description: "Example:\nCancer is one of the twelve signs of the zodiac.\nNinety per cent of lung cancers are caused by smoking.\nDefinition:\nthe fourth sign of the zodiac; a serious disease that is caused when cells in the body grow in a way that is uncontrolled and not normal:"
    },
    {
      id: 594,
      word: "substitute",
      transcription: "ˈsʌbstɪtju:t",
      translation: "замінити",
      description: "Example:\nIn the absence of brook trout, up to one of two nonnative trouts (wild brown or rainbow) would be substituted as an intolerant species.\nThe young teacher had to substitute for the sick colleague\nMuch of the trade sought to replace imports with local substitutes of acceptable quality but lower cost.\nDefinition:\nact as a substitute"
    },
    {
      id: 595,
      word: "alter",
      transcription: "ˈɒltər",
      translation: "змінюватися",
      description: "Example:\nHis mother protests that she does not want to alter this house.\ndebbie was the alterator who was making my dress smaller.\nDefinition:\nto change in character or composition, typically in a comparatively small but significant way:"
    },
    {
      id: 596,
      word: "sour",
      transcription: "saʊr",
      translation: "кислий",
      description: "Example:\nCucumbers go well with buttermilk , dill, mint, salmon, tarragon, scallions, onions, tomatoes, sour cream and yogurt.\nThese plums are a bit sour.\nAdd extra sugar if the rhubarb is too sour.\nDefinition:\nHaving an acid taste like lemon or vinegar."
    },
    {
      id: 597,
      word: "horseradish",
      transcription: "ˈhɔːsˌrædɪʃ",
      translation: "хрін",
      description: "Definition:\n"
    },
    {
      id: 598,
      word: "mustard",
      transcription: "ˈmʌstəd",
      translation: "гірчиця",
      description: "Example:\nThe spices and seasonings that we like to use include cumin, coriander, turmeric, black pepper, mustard seeds, fennel seeds, cinnamon , cardamom and cloves.\nMUSTARD!!..SUICIDE\r\nlisten to GnarKill's MUSTARD MAN song\nSmoke was rising from the barbecue and the special mustard for the frying sausage was really hot and spicy.\nDefinition:\nA hot-tasting yellow or brown paste made from the crushed seeds of certain plants, typically eaten with meat or used as a cooking ingredient."
    },
    {
      id: 599,
      word: "craze",
      transcription: "kreɪz",
      translation: "манія",
      description: "Example:\nThe craze for watching football matches triggers a paranoid outburst.\nThe thread that runs through all of them is not just the crazed demand for a dowry by the victim's husband and his family, but the lack of support she got from her own parents as she suffered torture in silence.\nHe certainly seems to have mellowed, despite his slightly crazed Noddy Holder corkscrew curls and permanent top hat.\nDefinition:\nMake wildly insane or out of control."
    },
    {
      id: 600,
      word: "craze",
      transcription: "kreɪz",
      translation: "зводити з розуму",
      description: "Example:\nThe craze for watching football matches triggers a paranoid outburst.\nThe thread that runs through all of them is not just the crazed demand for a dowry by the victim's husband and his family, but the lack of support she got from her own parents as she suffered torture in silence.\nHe certainly seems to have mellowed, despite his slightly crazed Noddy Holder corkscrew curls and permanent top hat.\nDefinition:\nMake wildly insane or out of control."
    },
    {
      id: 601,
      word: "rabies",
      transcription: "ˈreɪbiːz",
      translation: "сказ",
      description: "Example:\nan example for Rabies Dogs of the Dead\nif a skunk has rabies, it will lose its fur and you can see that it's tail is just a rod like thing.\nDamn, stay away from that skunk, it has rabies.\nDefinition:\nan acute viral disease of the nervous system of warm-blooded animals (usually transmitted by the bite of a rabid animal); rabies is fatal if the virus reaches the brain"
    },
    {
      id: 602,
      word: "tout",
      transcription: "taʊt",
      translation: "закликати",
      description: "Example:\nVarious studies have been published touting the benefits of pre-kindergarten programs.\nDefinition:\nto advertise or praise something, often to encourage its use or sale:"
    },
    {
      id: 603,
      word: "medieval",
      transcription: "ˌmediˈiːvəl",
      translation: "середньовічний",
      description: "Example:\nThey're using a computer system that seems positively medieval by today's standards.\na medieval attitude toward dating\nIf you don't hand over the bling-bling, I'm gonna have to medieval on you, biznatch!\r\n\nDefinition:\nRelating to the Middle Ages.\ninformal: old-fashioned; primitive"
    },
    {
      id: 604,
      word: "spin",
      transcription: "spɪn",
      translation: "плести (небилицю)",
      description: "Example:\nHe spun some tale about needing to take time off work because his mother was ill.\nThe earth spins on its axis.\nSo much spin has come out of the Republican campaign, they must be dizzy by now.\nDefinition:\nround quickly;\nto tell a story, either to deceive someone or for entertainment."
    },
    {
      id: 605,
      word: "reenactment",
      transcription: "ˌriːɪˈnæktmənt",
      translation: "відтворення реальних подій минулого",
      description: "Example:\nThe vibrant subculture of battle reenactment is too often thought of as merely a hobby or as activity unworthy of sustained analytical attention.\nWe setup a reenactment to figure out a way to tweak this thang\nDefinition:\nperforming a role in an event that occurred at an earlier time"
    },
    {
      id: 606,
      word: "legendary",
      transcription: "ˈledʒəndərɪ",
      translation: "легендарний",
      description: "Example:\nElizabeth, vain and proud about her legendary beauty, was convinced she'd found the secret of youth.\nAnother manifestation of the black market in Belfast is the legendary and ever-popular delivery services.\nlegendary exploits of Jesse James\nDefinition:\nVery famous and admired or spoken about."
    },
    {
      id: 607,
      word: "malicious lie",
      transcription: "məˈlɪʃəs laɪ",
      translation: "зловмисна брехня",
      description: "Example:\nI will not breathe further life into a malicious lie by discussing it.\nWITH:\r\n1#: hey\r\n2#: hi\r\n1#: have u downloaded 'pwnage free website maker'?\r\n2#: no thats got malicious code in it!\r\nWITHOUT:\r\n1#: hey\r\n2#: hi\r\n1# have u downloaded 'pwnage free website maker'?\r\n2#: no thats got a virus!\nDefinition:\nIt is a lie that was uttered with malice, that is, the utterer knew it was false or would cause damage or harm."
    },
    {
      id: 608,
      word: "villain",
      transcription: "ˈvɪlən",
      translation: "злодій",
      description: "Example:\nThe real villain in this depiction is the devil.\nA crime of such selfishness, vindictiveness and plain no-goodedness that I hesitate to lay it before you in all its red toothed , black cloaked and villainous evil.\nGreat action, good characters, good acting, good villains, a good story: I came out of the cinema grinning with delight.\nDefinition:\nA character whose evil actions or motives are important to the plot."
    },
    {
      id: 609,
      word: "epic",
      transcription: "ˈepɪk",
      translation: "епічний",
      description: "Example:\nThe downward-curving bill of the bird, the small head, and the swollen knees are all accurate depictions of a wader.\nIn the second decade Patinir established a formula for the painting of calm seas, while interest in depicting stormy seas came later.\nLee said showing the 1962 war epic was a disgusting and offensive way to mark the emotional trip.\nDefinition:\nconstituting or having to do with or suggestive of a literary epic"
    },
    {
      id: 610,
      word: "prone",
      transcription: "proʊn",
      translation: "схильний",
      description: "Example:\nI don't wish to blame my children for everything, but they are a major liability when you're prone to blushing.\n E.g to be prone to an illness \nDefinition:\nLikely or liable to suffer from, do, or experience something unpleasant or regrettable."
    },
    {
      id: 611,
      word: "perk up",
      transcription: "pɜːrk ʌp",
      translation: "підбадьоритися",
      description: "Example:\nA cup of coffee will perk you up.\nHe soon perked up when his friends arrived.\nDefinition:\nto improve or become more exciting."
    },
    {
      id: 612,
      word: "overly",
      transcription: "ˈoʊvərli",
      translation: "надмірно",
      description: "Example:\nA woman knew a good thing when she saw it - and that was a man with good career prospects who wasn't overly interested in drink , gambling or sex.\nAll the men in the film are bullies, from the brutish pimp who looks like Hans Blofeld's overly plump brother to the swarthy , sweaty son who is supposed to woo the wench into a date with the acid bottle.\nMorbid thoughts plagued her overly active imaginative mind and sent chills down her spine.\nDefinition:\nExcessively."
    },
    {
      id: 613,
      word: "myth",
      transcription: "mɪθ",
      translation: "міф",
      description: "Example:\nA popular myth is that tonsils and adenoids filter bacteria out of what we swallow and breathe like a kitchen strainer .\nThen the movie literally stops and begins anew, retelling a mythic tale about a wild beast and the hunter who must kill it or be devoured by it.\nBecause of this, it is crucial that research continues in this area so that racial myths, stereotypes and prejudice within New Zealand can be exposed and understood.\nDefinition:\nA traditional story, especially one concerning the early history of a people or explaining a natural or social phenomenon, and typically involving supernatural beings or events."
    },
    {
      id: 614,
      word: "fiction",
      transcription: "ˈfɪkʃən",
      translation: "вигадка",
      description: `Example:
It may well turn out that all of Parmalat's financials are true fiction - more a case of Parma sham than Parma ham.
I decided to try writing fiction
As Mark Twain once said, " Why shouldn't truth be stranger than fiction?
Definition:
A belief or statement which is false, but is often held to be true because it is expedient to do so.`
    },
    {
      id: 615,
      word: "depict",
      transcription: "dɪˈpɪkt",
      translation: "зображати",
      description: "Example:\nThe patch - painted to depict a North American Indian mythical half-eagle, half-hawk thunderbird - is hallowed ground.\nIn the second decade Patinir established a formula for the painting of calm seas, while interest in depicting stormy seas came later.\nThe patch - painted to depict a North American Indian mythical half-eagle, half-hawk thunderbird - is hallowed ground.\nDefinition:\nRepresent by a drawing, painting, or other art form."
    },
    {
      id: 616,
      word: "convey",
      transcription: "kənˈveɪ",
      translation: "передавати",
      description: "Example:\nOur guide genially points out details while indicating that there is far more here than he can convey to visitors - that some mysteries have to remain unexplained.\nWarrants convey on the holder the right, but not the obligation, to buy or sell a share at an agreed price in the future.\nThose are the authentic prescribed vignettes, but, like Scrabble's alphabetic squares, there is an infinity of ways in which to range and rearrange them, and the message that they convey.\nDefinition:\nCommunicate a message or information."
    },
    {
      id: 617,
      word: "blank",
      transcription: "blæŋk",
      translation: "порожній",
      description: "Example:\nDousing her face and neck, she gazed for a fleeting moment into the water, her thoughts momentarily blank.\nDave had a blank look on his face.\nFill in the blanks with the missing words.\nDefinition:\nUnrelieved by decorative or other features; bare, empty, or plain."
    },
    {
      id: 618,
      word: "narrow",
      transcription: "ˈnærəʊ",
      translation: "вузький",
      description: "Example:\nAll of the collection's pictures were displayed in long and narrow rooms on the second.\n'woaah look at this guy on the floor.. eeeez well narrowed'\nThe selection was narrowed\nDefinition:\nLimited in extent, amount, or scope."
    },
    {
      id: 619,
      word: "pleasant",
      transcription: "ˈplezənt",
      translation: "приємний",
      description: "Example:\nWe had a pleasant evening.\n\nIt's a pleasant day today.\nShe is a pleasant person.\nDefinition:\ngiving a sense of happy satisfaction or enjoyment:"
    },
    {
      id: 620,
      word: "pile",
      transcription: "paɪl",
      translation: "купа",
      description: "Definition:\n"
    },
    {
      id: 621,
      word: "distinction",
      transcription: "dɪˈstɪŋkʃən",
      translation: "відмінність",
      description: "Example:\nit is necessary to make a distinction between love and infatuation\nJessica: Let's go to the fair Marco, it'll be bangin'!\r\nMarco: The fair's back in town? This is going to be well distinction.\nEach state in the United States has their own distinctives.\n\nEvery president of the United States has possessed their own individual distinctives in relation to domestic and foreign policy.\nDefinition:\na discrimination between things as different and distinct on the basis of their characteristics or attributes"
    },
    {
      id: 622,
      word: "old wives' tales",
      transcription: "əʊld waɪvz teɪl",
      translation: "вигадки",
      description: "Example:\nOkay, superstitions are like old wives' tales invented to explain somebody's misfortune.\nBobby's Grandma: Put on your coat or you'll catch pneumonia\r\nLittle Bobby: Nah ah Grandma. That's an old wives tale. Pneumonia is caused by bacteria.\nDon't swallow gum or it will stay in your stomach for seven years.\r\nMom that's an old wives tale\nDefinition:\nA widely held traditional belief that is now thought to be unscientific or incorrect."
    },
    {
      id: 623,
      word: "gullible",
      transcription: "ˈgʌləbl̩",
      translation: "довірливий",
      description: "Example:\nMovie adaptations of comic books are always a let-down and trailers these days are front-loaded with all the best bits to lure gullible moviegoers to the multiplexes.\nThe result is that amiable but gullible Arthur finds himself fleeced by friends and strangers alike.\nI know my sister isn't gullible or dumb, so this fact only served to prove to me how shallow she is.\nDefinition:\nnaive and easily deceived or tricked"
    },
    {
      id: 624,
      word: "aloof",
      transcription: "əˈluːf",
      translation: "відчужений",
      description: "Example:\nIt is as if we, temperamental and capricious , have been having a stormy affair with aloof, indifferent El Niño.\nOutwardly tough, aloof and cynical , she does a good deal of nail-chewing and fiddling with a cigarette as she decides whether Jack can be trusted.\nThus you appear somewhat unsociable and aloof.\nDefinition:\nNot friendly or willing to take part in things."
    },
    {
      id: 625,
      word: "rough draft",
      transcription: "rʌf drɑːft",
      translation: "чернетка",
      description: "Example:\nWoodward's book is just the first, very rough draft of that key time in America's history.\nEach story comes off as a rough draft in need of polish.\nAs a working artist, when I look back on my early work I look at a rough draft of myself.\nDefinition:\na piece of text, a formal suggestion, or a drawing in its original state, often containing the main ideas and intentions but not the developed form:\n\n"
    },
    {
      id: 626,
      word: "twist",
      transcription: "twɪst",
      translation: "перекручувати",
      description: "Example:\nPack into molds or crocks, or roll like a jelly roll in a piece of plastic wrap and place a twist tie on both ends.\nI paced restlessly around my small cell, stomach twisting with anxiety, and hunger.\nSprinkle, as you go, with generous pinches of flaky sea salt and vigorous twists of freshly ground black pepper.\nDefinition:\nDistort or misrepresent the meaning of words."
    },
    {
      id: 627,
      word: "pure innocence",
      transcription: "pjʊər ˈɪnəsənts",
      translation: "втілення невинності",
      description: "Example:\nYou know, Castle, sometimes I forget that you have such a capacity for pure innocence in your life.\nI used to think a Boston pancake was a pancake from Boston... R.I.P innocent me.\nI lost my innocence while doing random word on the urbandictionary\nDefinition:\nTrue freedom from guilt or sin through being unacquainted with evil."
    },
    {
      id: 628,
      word: "white lie",
      transcription: "waɪt laɪ",
      translation: "невинна брехня",
      description: "Example:\nWe think it's trivial, even necessary; this is the famous white lie .\nBut his big dreams land him in hot water when a great white lie turns him into an unlikely hero.\nMeagan knew better than to lie, but a little white lie never hurt anybody.\nDefinition:\nA harmless or trivial lie, especially one told to avoid hurting someone's feelings."
    },
    {
      id: 629,
      word: "tall tale",
      transcription: "tɔːl ˈteɪl",
      translation: "вигадка",
      description: "Example:\ncousins and uncles filled the tedium of winter nights with many a tall tale\nThis has it all, a peculiar confection of tall tales and reality blended together in a strange and moving way.\ncousins and uncles filled the tedium of winter nights with many a tall tale\nDefinition:\nA long and complicated story that is difficult to believe because most of the events it describes seem unlikely or impossible."
    },
    {
      id: 630,
      word: "surreal",
      transcription: "səˈrɪəl",
      translation: "нереальний",
      description: "Example:\nIts leader is a surreal portrait of art-school eccentricity, a social maverick up to his neck in the shifting sands of taboo and faux pas.\nGiraffes and wildebeest were recently sighted attempting to gain entry to a prototype cylindrical toaster left to dry on the roof of Prof. Marleson's New York apartment.\nMomma, why can't I eat Kraft Mac N' Cheese for breakfast?\r\nShut your mouf, D'Quayshius and eat yo surreal.\nDefinition:\nHaving the qualities of surrealism; bizarre."
    },
    {
      id: 631,
      word: "step up",
      transcription: "step ʌp",
      translation: "посилювати",
      description: "Definition:\nnull"
    },
    {
      id: 632,
      word: "single-minded",
      transcription: "ˌsɪŋgl̩ˈmaɪndɪd",
      translation: "цілеспрямований",
      description: "Example:\nWith single-minded purpose, he hitch-hikes slowly down the African continent.\nAnd the correspondence is evidence that he was not alone in thinking along those lines, even if he did pursue the idea more single-mindedly than others did.\nAlthough he supports his mother financially, he presents him as stingy and ungrateful, single-mindedly devoted to his own success.\nDefinition:\nConcentrating on only one aim."
    },
    {
      id: 633,
      word: "self-sufficient",
      transcription: "ˌselfsəˈfɪʃənt",
      translation: "самостійний",
      description: "Example:\nShe had grown used to not having her father around, and was so self-sufficient and intelligent and beautiful.\nYou are a smart, darling, self-sufficient, loving woman who wants a smart, darling loving man.\nSeeds and tools can be given, which allow families to grow food and become self-sufficient .\nDefinition:\nNeeding no outside help in satisfying one's basic needs, especially with regard to the production of food."
    },
    {
      id: 634,
      word: "punch line",
      transcription: "pʌntʃ laɪn",
      translation: "розв'язка",
      description: "Example:\nAnd explaining how to construe a sentence spoils its effect, just as explaining the punch line of a joke does.\nAnd explaining how to construe a sentence spoils its effect, just as explaining the punch line of a joke does.\nFor all I know the entire scene might have been a put-on with a hired actor, but I enjoyed the punch line.\nDefinition:\nThe final phrase or sentence of a joke or story, providing the humour or some other crucial element."
    },
    {
      id: 635,
      word: "pun",
      transcription: "pʌn",
      translation: "каламбур",
      description: "Example:\nAnyway, I'll try again tonight to come up with some devastatingly clever pun that befits my rapier wit.\nTurns out they didn't realise Justine is blonde because the band is quite punky and heavy metal.\nIn the bar, punters were downing real ale or orange juice, and staring resentfully at the three people who'd had the cheek to light up a cigarette.\nDefinition:\nA joke exploiting the different possible meanings of a word or the fact that there are words which sound alike but have different meanings."
    },
    {
      id: 636,
      word: "novel",
      transcription: "ˈnɒvəl",
      translation: "роман",
      description: "Example:\nI remember reading this novel before.\nThe stunning cover of this mysterious novel provides a clue to its structure.\nIn a writer with apparently two more novels in the pipeline it's a sure sign he is not yet master of his art.\nDefinition:\na long printed story about imaginary characters and events:"
    },
    {
      id: 637,
      word: "noble",
      transcription: "ˈnəʊbl̩",
      translation: "дворянин",
      description: "Example:\nIt was a noble effort to achieve a peaceful settlement to the conflict.\nare in nobl ? i am one of the owners\nare in nobl ? i am one of the owners\nDefinition:\nhaving high moral principles:"
    },
    {
      id: 638,
      word: "youth",
      transcription: "juːθ",
      translation: "молодість",
      description: "Example:\nMost people cluster on the peaks of mountains and build their houses on stilts, hoping to keep their youth as long as possible.\nDefinition:\nyoung people:"
    },
    {
      id: 639,
      word: "Physician",
      transcription: "fɪˈzɪʃən",
      translation: "лікар",
      description: "Example:\nThe physician spent four years in undergrad, four years in medical school, 3-7 years in residency, and then 1-2 years in fellowship before practicing.\nPerson:OMG my friend just got shot!!, call 911!\n\nEMT's: don't worry kiddo, we will stabilize you and take to to a physician so he/she can do he/she's majic!\nDad, I was at Jimmy's house and his dad came in and smashed the PlayStation to smithereens. His teeth were showing and he was screaming curse words.\n\nIt's ok son, Jimmy's dad is a physician. That's how they express themselves.\nDefinition:\na licensed medical practitioner"
    },
    {
      id: 640,
      word: "lore",
      transcription: "lɔːr",
      translation: "знання",
      description: "Example:\nIt was a thin pearl-colored gown that went down to my ankles and cut off somewhere above my heart .\nThis bus station is being seen as the mother of all solutions to the grievances of bus commuters in Bangalore.\nIf not, cover some boxes with sacking, or a throw or a neutral colored cloth and build up from there.\nDefinition:\nknowledge gained through tradition or anecdote"
    },
    {
      id: 641,
      word: "fall down",
      transcription: "fɔːl daʊn",
      translation: "терпіти невдачу",
      description: "Example:\nHe’s falling down on his job.\nThe force caused a small avalanche of dirt to fall down, nearly landing the girl.\nHe also showed His crucifixion scars on his hands and side to Thomas, this made him fall down and confess him as his own Lord and God.\nDefinition:\nto prove unsuccessful; fail.\n\n"
    },
    {
      id: 642,
      word: "make up for",
      transcription: "meɪk ʌp fɔːr",
      translation: "компенсувати",
      description: "Example:\nAsiatic lilies make up for having little or no scent with the beauty of their huge upturned flowers in luminous colours.\nIs it to make up for the things we went without, or is it our guilt about the fact that we are too busy enjoying ourselves to devote time to them?\nGirl 1: Hey\r\nGirl 2: You look so pretty with all of that make up on!!!\r\n\r\nGuy: *throws up*\nDefinition:\nTo make up for a bad experience or the loss of something means to make the situation better or make the person involved happier."
    },
    {
      id: 643,
      word: "get in trouble",
      transcription: "ɡet ɪn ˈtrʌbl",
      translation: "потрапити в неприємності",
      description: "Example:\nShe was sweet and nice to mostly everyone she meet, she didn't deserve to get in trouble cause of his stupid idea.\nI was caught laughing and getting in trouble.\nDefinition:\nto perform an action which is illegal, prohibited, forbidden or proscribed and to become subject to punishment for such action:"
    },
    {
      id: 644,
      word: "get clogged up",
      transcription: "get klɒgd ʌp",
      translation: "засмітитися",
      description: "Example:\nIt'll just get clogged up again next week.\nIf you do not do it as well, then under the film gets clogged up with hairs, dust particles, and this can lead to a bad result.\n\nDefinition:\nto be blocked or filled with something:"
    },
    {
      id: 645,
      word: "panic attack",
      transcription: "ˈpænɪk əˈtæk",
      translation: "панічна атака",
      description: "Example:\nOn Tuesday night, he was said to have suffered a panic attack as the idea of leaving became too much.\nThe last thing you want is a hysterical claustrophobe, suffering from a panic attack!\nThe technique is used to help patients suffering from backache , headaches and panic attacks, plus a range of chronic diseases.\nDefinition:\nArguably the most extreme manifestation of acute anxiety, a panic attack is an episode of sudden apprehension and intense fear, combined with physiological symptoms that closely resemble a heart attack."
    },
    {
      id: 646,
      word: "get stitches",
      transcription: "get stɪtʃ",
      translation: "накласти шви",
      description: "Example:\nI had to go to the hospital and get stitches.\nSnitch: Sir, It was Tommy that sold me the drugs\r\nTommy: You better watch yourself punk, snitches get stitches\nI thought Franklin rode for the hood and all, but now he ratted us to the Feds. He's gonna get taught the meaning of hood respect. As the old saying goes, Snitches get Stitches!\nDefinition:\nWhen a doctor stitches the wound."
    },
    {
      id: 647,
      word: "helpful",
      transcription: "ˈhelpfəl",
      translation: "готовий допомогти",
      description: "Example:\n I gave him some helpful advice.\nShe thanked him for his helpful advice.\nVitamin D may also be helpful.\nDefinition:\ngiving or ready to give help:"
    },
    {
      id: 648,
      word: "in a bind",
      transcription: "ɪn ə baɪnd",
      translation: "в глухому куті",
      description: "Example:\nI was in a bind. If I went, I knew I'd be frustrated by the lack of real communication. And if I didn't go, I'd be criticized.\nAre you in a bind and need some fast cash to tide you over?\nThis left the Labour party in a bind, as they were suddenly a minority government.\nDefinition:\nTo be in a very difficult situation, because you have problems that cannot be solved easily or without causing more problems."
    },
    {
      id: 649,
      word: "fluke",
      transcription: "fluːk",
      translation: "везіння",
      description: "Example:\nIs it therefore logical to think blind, unintelligent , mindless nature could have stumbled on Einstein and us by sheer fluke?\n1.That game was a total fluke. Nine times out of ten we would have beaten that team.\r\n\r\n2. Did you hear the new Fluke CD? It's very good.\nHe returns to the course tomorrow in a bid to prove that his latest effort was no fluke.\nDefinition:\nAn unlikely chance occurrence, especially a surprising piece of luck."
    },
    {
      id: 650,
      word: "fender-bender",
      transcription: "ˈfendər ˌbendər",
      translation: "дрібна аварія",
      description: "Example:\nTwo days after the Clarks bought the midsize sedan , Lori Clark had a fender bender.\nJeff: Man it looks like you have a boner but somethin's awfully wrong wit dat meat\r\n\r\nJohn: Yeah, I had a bit of a Fender-Bender with Miss Norris over there\nDefinition:\nA minor collision between motor vehicles."
    },
    {
      id: 651,
      word: "fall off",
      transcription: "ˈfɑːl ˈɒf",
      translation: "погіршуватися",
      description: "Example:\nIf there has been a fall-off in business, and I can accept that, it is not necessarily, or solely, because of the smoking ban.\nThe patch is very sticky , and shouldn't fall off.\nThat explains why deciduous forest means a forest in which the leaves fall off the trees when the winter comes.\nDefinition:\nA decline or drop."
    },
    {
      id: 652,
      word: "excess",
      transcription: "ekˈses",
      translation: "надлишковий",
      description: "Example:\nSmiley says her first letters to the Times were edited heavily, with excess verbiage getting the knife.\nAn excess of enthusiasm is not always a good thing.\nThey both eat to excess.\nDefinition:\nExceeding a prescribed or desirable amount."
    },
    {
      id: 653,
      word: "dead weight",
      transcription: "ded weɪt",
      translation: "тягар",
      description: "Example:\nthe past was just so much dead weight, excess baggage\nHe wears a splint to support his right ankle and enable him to walk, and his right arm is a dead weight.\nthe net was a dead weight on his shoulders\nDefinition:\nA heavy or oppressive burden."
    },
    {
      id: 654,
      word: "bummer",
      transcription: "ˈbʌmər",
      translation: "облом",
      description: "Example:\nNow I need a wetsuit and a surfboard… bummer I didn't bring over at least one board from my quiver in NZ with me.\nHaving cracked, bubbly, sore skin on my hands was always a bit of a bummer , especially as a teenager.\nbaby doesn't have to be a travel bummer\nDefinition:\nA disappointing or unpleasant situation or experience."
    },
    {
      id: 655,
      word: "basket case",
      transcription: "ˈbæskɪt ˌkeɪs",
      translation: "недотепа",
      description: "Example:\nThe idea that sub-Saharan Africa is an amorphous whole - one huge basket case - is a damaging misconception.\nCountries in permanent crisis, with the population at subsistence level, more or less chaotic, but without total civil strife, are known colloquially as ‘basket cases’.\nAs a result, sudden meltdowns - such as the Asian financial crisis - can turn flourishing countries into basket cases overnight.\nDefinition:\nA person or thing regarded as useless or unable to cope."
    },
    {
      id: 656,
      word: "calamity",
      transcription: "kəˈlæməti",
      translation: "катастрофа",
      description: "Example:\nHe's fascinated by tales of Wild Bill and Calamity Jane, and covets Hopkins's Colt 45.\nWe don't mistake it as a sign from God of an impending calamity.\nThe areas that were most damaged by the calamity is certainly back on its feet.\nDefinition:\nAn event causing great and often sudden damage or distress; a disaster."
    },
    {
      id: 657,
      word: "alarm clock",
      transcription: "əˈlɑːm klɒk",
      translation: "будильник",
      description: "Example:\nShe awoke the next day, as her alarm clock let out a monotonous but loud beep.\nI've set the alarm for 7.30.\nDidn't you hear your alarm clock going off this morning?\nDefinition:\na clock with a device that can be made to sound at the time set in advance, used to wake someone up:"
    },
    {
      id: 658,
      word: "iron",
      transcription: "aɪən",
      translation: "праска",
      description: "Example:\nYou iron your shirt.\nI'll have to go back to the house - I think I've left the iron on.\nIt takes about five minutes to iron a shirt properly.\nDefinition:\nif you iron clothes, you remove the creases from them using an iron:"
    },
    {
      id: 659,
      word: "wickedness",
      transcription: "uncountable",
      translation: "злість",
      description: "Example:\nBut there was more to the crime than the wickedness of two cruel women.\nThere is not a word in the English dictionary to really describe this pre-meditated act of evil and wickedness.\nDefinition:\nestrangement from god"
    },
    {
      id: 660,
      word: "Fall over",
      transcription: "fɔːl ˈəʊvər",
      translation: "спіткнутися",
      description: "Example:\nIt would be a mercy to end its existence, but he left it there, just tethering at the edge of death, wishing for it but not enough to fall over.\nIf I lose my balance, if I fall over, into the mud, in this much pain, barely able to move, I may not get up.\nOne of the oldest known herbs, garlic, is grown like an onion until the tops yellow and fall over.\nDefinition:\nThe best joke ever created"
    },
    {
      id: 661,
      word: "self-sufficient",
      transcription: "ˌselfsəˈfɪʃənt",
      translation: "самодостатній",
      description: "Example:\nShe had grown used to not having her father around, and was so self-sufficient and intelligent and beautiful.\nYou are a smart, darling, self-sufficient, loving woman who wants a smart, darling loving man.\nSeeds and tools can be given, which allow families to grow food and become self-sufficient .\nDefinition:\nNeeding no outside help in satisfying one's basic needs, especially with regard to the production of food."
    },
    {
      id: 662,
      word: "self-sufficient",
      transcription: "ˌselfsəˈfɪʃənt",
      translation: "самовпевнений",
      description: "Example:\nShe had grown used to not having her father around, and was so self-sufficient and intelligent and beautiful.\nYou are a smart, darling, self-sufficient, loving woman who wants a smart, darling loving man.\nSeeds and tools can be given, which allow families to grow food and become self-sufficient .\nDefinition:\nNeeding no outside help in satisfying one's basic needs, especially with regard to the production of food."
    },
    {
      id: 663,
      word: "boon",
      transcription: "buːn",
      translation: "дар",
      description: "Example:\nIt is also a boon to those farmers who are, in effect, protected from competition.\nWhether disgruntled fiancées fed up at playing the waiting game will draw parallels between their menfolk and the baboons, skunks and pigs remains uncertain.\nGorillas practice infanticide and chimpanzees hunt and torture baboons.\nDefinition:\nA thing that is helpful or beneficial."
    },
    {
      id: 664,
      word: "stain",
      transcription: "steɪn",
      translation: "пляма",
      description: "Example:\nOne of his hands traced up along the side of my tearstained cheek and through my hair.\nthe wine left a dark stain\nThere also will be worse staining of the teeth and some risk of tooth loss from caries because of the sugar in chewing tobacco.\nDefinition:\nRemove stains by soaking in a mild solution of bleach."
    },
    {
      id: 665,
      word: "pile up",
      transcription: "paɪl ʌp",
      translation: "Складати",
      description: "Example:\nWith no collection system, mountains of empty plastic bottles pile up in sand dunes behind its white sand beaches.\nAnd the bizarre events and coincidences pile up more and more as the story proceeds.\nAnd it's years since I've heard anyone pile up as many pithy one-liners.\nDefinition:\nGather or be gathered in a pile; accumulate."
    },
    {
      id: 666,
      word: "jinx",
      transcription: "dʒɪŋks",
      translation: "наврочити",
      description: "Example:\nWon't say anything more about future updates because I'm afraid I'll jinx the rewrite .\nAre you suffering from depression, substance abuse, obesity, stress, impotence, domestic problems or even a jinx ?\nWhen he was a schoolboy in Glasgow his father would take him to matches and tease Alex for being a jinx when Rangers lost.\nDefinition:\nBring bad luck to; cast an evil spell on."
    },
    {
      id: 667,
      word: "drawback",
      transcription: "ˈdrɔ:bæk",
      translation: "нестача",
      description: "Example:\nThe only drawback was the huge noise these animals created, it scared the life out of the baby.\nOf course, there are other drawbacks to being tall, like having to stoop to wash the dishes, rinse her hands in the bathroom basin or write at a desk.\nWe have tried to overcome this drawback by taking biopsy samples from the anterior as well as posterior walls in both the antrum and the corpus .\nDefinition:\nthe quality of being a hindrance:"
    },
    {
      id: 668,
      word: "backward",
      transcription: "ˈbækwəd",
      translation: "у зворотньому напрямку",
      description: "Example:\nA partner helps secure the board while the nailer bends backward pushing the groove hard onto the tongue with one hand and driving the nail in with the other.\nAt a stroke, Carlile put the doubts back in Harrington's mind when he swept him over backwards with a salto, a throw borrowed from the freestyle wrestling.\nYou know we bend over backwards in work to be helpful and polite to people.\nDefinition:\nin a manner or order or direction the reverse of normal"
    },
    {
      id: 669,
      word: "steep hill",
      transcription: "stiːp hɪl",
      translation: "крутий пагорб",
      description: "Example:\nNablus, in the north of the West Bank, is surrounded by steep hillsides forming a basin , containing the main town area.\nthey were climbing a steep hill in low gear\nScary Street runs up a steep hill to a T junction onto a busy road.\nDefinition:\nSteep a word to describe something or a situation that is unbelievably bad or unfortunate for your self or another person."
    },
    {
      id: 670,
      word: "smash",
      transcription: "smæʃ",
      translation: "трощити",
      description: "Example:\nBut they couldn't move, literally, held captive by a security lockdown after a U.S. airliner smashed into a residential area in Queens nearby.\nMr Allen spent six weeks in intensive care after the accident when scaffolding being carried in a truck smashed through the windscreen of his Fosseway Coaches bus.\nthe band smashed up their equipment in an approximation of rock star behaviour\nDefinition:\nhit hard"
    },
    {
      id: 671,
      word: "grab",
      transcription: "græb",
      translation: "хапати",
      description: "Example:\nhe made a grab for the ball before it landed\ngrab me a beer, would ya??\r\ngrab a chair and join us\nyo i wanna get stoned, let's go grab from the hippie down the street\nDefinition:\nthe act of catching an object with the hands"
    },
    {
      id: 672,
      word: "catch fire",
      transcription: "kætʃ faɪər",
      translation: "загорітися",
      description: "Example:\nSlavedriver, your table has turned, catch a fire, you're gonna get burned\nOpen flames, cigarettes, matches, lighters , pilot lights, or electric sparks can cause the chemicals in the paint strippers to suddenly catch fire.\nIt is thought an electrical fault caused the humidifier to catch fire.\nDefinition:\nTo start burning."
    },
    {
      id: 673,
      word: "lose the plot",
      transcription: "luːz ðiː plɒt",
      translation: "втратити хід думок",
      description: "Example:\nA gifted raconteur , he was born to talk, to entertain, to lose the plot, to start again, to regale you with tales from one of the fullest lives a human being could ever live.\nFeminist Frequency is complaining about lack of diversity in female character designs in OverWatcth, a game that went out of its way to have the most diversity in female character designs. Way to lose the plot, Feminist Frequency!\nI can't believe Stuart did that - he must be losing the plot.\nDefinition:\nto no longer be able to act normally or understand what is happening:"
    },
    {
      id: 674,
      word: "weary",
      transcription: "ˈwɪəri",
      translation: "виснажений",
      description: "Example:\nThe patient wearies easily.\nDon’t weary the patient.\nChildren weary me with their constant questions and demands.\nDefinition:\nсause to become tired:"
    },
    {
      id: 675,
      word: "upshot",
      transcription: "ˈʌpʃɑːt",
      translation: "результат",
      description: "Example:\nSounds great in theory, but the practical upshot of this can be unsettling to the public.\nHis firing was a direct result of his refusal to follow the employment policies.\nIt's too early to predict the outcome of the meeting.\nDefinition:\nThe final or eventual outcome or conclusion of a discussion, action, or series of events."
    },
    {
      id: 676,
      word: "setback",
      transcription: "ˈsetbæk",
      translation: "рецидив",
      description: "Example:\nSo, barring a major surprise like another terrorist attack or some unforeseeable setback in Iraq, the President's numbers will probably move up again soon.\nHere he has met some setbacks, but with characteristic determination he is going to try again.\na setback to the state could present a peril to the regime\nDefinition:\nA reversal or check in progress."
    },
    {
      id: 677,
      word: "run over",
      transcription: "rʌn ˈoʊvər",
      translation: "задавити",
      description: "Example:\nI would be dead if I were ever run over by a bus.\nParades run over several weekends, so as not to clash with other parades in neighbouring areas.\nTests were run over telephones and intercoms to determine optimum degrees of loudness for giving instructions and commands.\nDefinition:\nKnock down a person with a moving vehicle."
    },
    {
      id: 678,
      word: "mishap",
      transcription: "ˈmɪshæp",
      translation: "нещастя",
      description: "Example:\nToday's game will be so tight that a single mishap could prove decisive .\nThe two drivers were involved in a mishap on the track that cost him the lead and put him out of the race.\nYou look the same age to me.\r\nI'M FIVE YEARS OLDER AND IN COLLEGE!!!\r\nSAILING MISHAP!!!!\nDefinition:\nAn unlucky accident."
    },
    {
      id: 679,
      word: "jolt",
      transcription: "dʒoʊlt",
      translation: "тряска",
      description: "Example:\nthe door closed with a jolt\nI woke up with a jolt as I thought I heard my bedroom door being pushed open.\nHis self-confidence took a sudden jolt with the news that he had not been selected.\nDefinition:\nAn abrupt rough or violent movement."
    },
    {
      id: 680,
      word: "ill-fated",
      transcription: "ˌɪlˈfeɪtɪd",
      translation: "злощасний",
      description: "Example:\nMeanwhile, his ill-fated final voyage was a sign that England was not yet ready for the big leagues.\nThis was the trouble about the ill-fated gas-gathering pipeline scheme.\nComparing these periods, we can draw on lessons from the past for avoiding ill-fated choices.\nDefinition:\nDestined to fail or have bad luck."
    },
    {
      id: 681,
      word: "Easter",
      transcription: "ˈiːstər",
      translation: "Великдень",
      description: "Example:\nI get two weeks off school at Easter.\nWe're going to my parents for Easter.\nDid you have a nice Easter?\nDefinition:\nthe Christian period of celebration around Easter Sunday:"
    },
    {
      id: 682,
      word: "endure",
      transcription: "ɪnˈdjʊər",
      translation: "витримувати",
      description: "Example:\nAn image that will no doubt endure and remain very fond in the hearts of many people who come up here.\nFerrari endured a 16-year drought before regaining their title touch.\nThe awesome stupidity of the common herd endures and multiplies, in part, because of the bogus trend stories that daily newspapers feed it.\nDefinition:\nSuffer something painful or difficult patiently."
    },
    {
      id: 683,
      word: "fall down",
      transcription: "fɔːl daʊn",
      translation: "терпіти невдачу",
      description: "Example:\nHe’s falling down on his job.\nThe force caused a small avalanche of dirt to fall down, nearly landing the girl.\nHe also showed His crucifixion scars on his hands and side to Thomas, this made him fall down and confess him as his own Lord and God.\nDefinition:\nto prove unsuccessful; fail.\n\n"
    },
    {
      id: 684,
      word: "conventional",
      transcription: "kənˈventʃənəl",
      translation: "стандартний",
      description: "Example:\nWithin lies a modern labyrinth arranged around the physical remains of ancient Roman town houses, together with more conventional exhibition spaces.\nThere is more acoustic instrumentation on this album, but that's not to say that the songs are any more conventional or, indeed, describable .\nShe meets Robert, a dentist, whose life appears conventional, but is in fact a fellow lost soul.\nDefinition:\nIn accordance with what is generally believed."
    },
    {
      id: 685,
      word: "fall off",
      transcription: "ˈfɑːl ˈɒf",
      translation: "погіршуватися",
      description: "Example:\nIf there has been a fall-off in business, and I can accept that, it is not necessarily, or solely, because of the smoking ban.\nThe patch is very sticky , and shouldn't fall off.\nThat explains why deciduous forest means a forest in which the leaves fall off the trees when the winter comes.\nDefinition:\nA decline or drop."
    },
    {
      id: 686,
      word: "accessorize",
      transcription: "əkˈsesəraɪz",
      translation: "прикрашати аксесуарами",
      description: "Example:\nAccessorize the table with an umbrella to keep lounging lunchers from getting sunburned.\nUsually, a woman also accessorizes with a bracelet , ring and necklace to go along with a brooch.\nDebenhams has fringed wraps from £30 and Accessorize has evening stoles and sequined scarves from £15.\nDefinition:\nTo accessorize something such as a set of furniture or clothing means to add other things to it in order to make it look more attractive."
    },
    {
      id: 687,
      word: "face mask",
      transcription: "feɪs mɑːsk",
      translation: "маска для обличчя",
      description: "Example:\nThis Honey Bio face mask contains seven secret herbs to cleanse and heal the skin.\nGovernment: Wear a Face mask to protect yourself!\r\nRandom Karen: NO! mAsKs iNfRinGE mY rIgHtS!\r\nIntellectuals: My friend, you seem to have lost this *Hands over brain*\nDefinition:\na cream or a piece of thin material that is left on the face for some time and then removed, in order to make the skin look and feel better:"
    },
    {
      id: 688,
      word: "moan",
      transcription: "məʊn",
      translation: "скаржитися",
      description: "Example:\nRapid eye movement is at all times detected, and occasionally the patient will moan , even scream during his rest.\nSo, Eskimoan languages are really extraordinary in their productive word-building capability, for any root you might pick.\nAt the edge of the wallow , a young brown and white steer was standing knee deep in the muck, calling to his mother, and she was moaning back at him.\nDefinition:\nA long, low sound made by a person expressing physical or mental suffering."
    },
    {
      id: 689,
      word: "facelift",
      transcription: "ˈfeɪslɪft",
      translation: "підтяжка обличчя",
      description: "Example:\nShe looks like she's had a facelift.\n1) To this day, each successive facelift continues to draw criticism from facebook users, who routinely join groups protesting the changes to the sites appearance.\n\n2) In it's most recent facelift, facebook introduce a news feed that notifies users of any recent activity by his or her facebook friends on the website.\nAfter someone's status, a poster replies, Hey, this is great. I want to re-post this as my status update, too. Mind if I facelift it?\nDefinition:\nmedical treatment that makes the skin of your face tighter so that you look younger"
    },
    {
      id: 690,
      word: "skin graft",
      transcription: "skɪn grɑːft",
      translation: "пересадка шкіри",
      description: "Example:\nThe local health trust has a specialist eye unit and a skin graft unit, which are doing marvellous work.\nDisgusted would-be client: That company totally SUX --- no expertise or caring whatsoever! Nothing but skin-graft in there!\nI've got this idea to bake a lasagna, and then perform a Popeyes Skin Graft to it. It's a dish that will make even Iron Chef Bobby Flay's jaw drop!\n\nI've been saving up fried chicken skins for a couple weeks now. I'm planning on sewing them together, and wrapping an entire ham. It'll be the world's largest Popeyes Skin Graft to date.\nDefinition:\na piece of skin taken from one part of the body and used to replace damaged skin in another part:"
    },
    {
      id: 691,
      word: "good complexion",
      transcription: "ɡud kəmˈplekʃən",
      translation: "гарний колір обличчя",
      description: "Example:\nYou look healthy yourself, with a good complexion.\nDefinition:\nthe natural appearance of the skin on a person's face, especially its color or quality:"
    },
    {
      id: 692,
      word: "long eyelashes",
      transcription: "lɒŋ ˈaɪlæʃɪz",
      translation: "довгі вії",
      description: "Example:\nThey sing beautifully, play their own instruments and have deep brown eyes and long eyelashes .\nPale rose-coloured lipstick covers her full lips and mascara on her long eyelashes frames her bright blue eyes.\nDefinition:\nAn eyelash is a hair that grows from your top or bottom eyelid. Eyelashes are small, usually dark and curved, and having plenty of long, lush eyelashes is considered attractive in everyone, male or female."
    },
    {
      id: 693,
      word: "get ears pierced",
      transcription: "gɛt ɪəz pɪəst",
      translation: "проколоти вуха",
      description: "Example:\nSo Melanie wanted to get her ears pierced, but of course, her mother said no.\nDefinition:\nThe making of a hole in the lobe of an ear, using a sterilized needle, so that an earring may be worn fastened in the hole."
    },
    {
      id: 694,
      word: "rejuvenate",
      transcription: "rɪˈdʒuːvəneɪt",
      translation: "омолоджувати",
      description: "Example:\nYou need to be tender, loving and caring to rejuvenate personal relationships.\nIn theory at least, this implies that adding telomerase to cells could rejuvenate them.\nZwei, by insinuating a steady pulse into its musical gymnastics, seems to slightly rejuvenate it.\nDefinition:\nMake someone or something look or feel better, younger, or more vital."
    },
    {
      id: 695,
      word: "pluck",
      transcription: "plʌk",
      translation: "вищипувати",
      description: "Example:\nSibyl watched as Lady Plymouth's private troubadour began to instinctively pluck strings of the viol .\nWorkers spray rose bushes, harvest stems, strip them of thorns and pluck the blemished petals.\nThese are songs built around a yearning violin , a plucky banjo riff or an accordion sigh.\nDefinition:\nPull some of the hairs from one's eyebrows to make them look neater."
    },
    {
      id: 696,
      word: "pinch",
      transcription: "pɪntʃ",
      translation: "щипати",
      description: "Example:\nWe both kept pinching ourselves to prove that it wasn't all a dream.\nSprinkle, as you go, with generous pinches of flaky sea salt and vigorous twists of freshly ground black pepper.\nHe does a weird pantomime suggesting a dance, his hands making pinching motions in the air.\nDefinition:\nGrip something, typically a person's flesh tightly and sharply between finger and thumb."
    },
    {
      id: 697,
      word: "eyelid",
      transcription: "ˈaɪlɪd",
      translation: "повіка",
      description: "Example:\nThey studied patients with moderately severe Graves' orbitopathy, defined as motility impairment causing diplopia , proptosis of at least 23 mm or severe eyelid swelling.\nI feel it come loose and, giddy with adrenaline, endorphins, and joy, I bring my hands up to my face and start threading the laces out of my eyelids, wincing when they scratch my eyes.\nMy antennae can smell, too, thin, blue cords above my silver eyebrows and blue eyelids.\nDefinition:\nEach of the upper and lower folds of skin which cover the eye when closed."
    },
    {
      id: 698,
      word: "earlobe",
      transcription: "ˈɪrloʊb",
      translation: "мочка",
      description: "Example:\nHelp the water run out of your ears by turning your head to each side and pulling the earlobe in different directions.\nWith a teasing nibble to Shanza's earlobe, he trailed feather soft kisses down her jaw-line.\nIn the New Kingdom of ancient Egypt a type of earring called an earplug became fashionable and these fitted snugly into a wide stretched hole in the earlobe.\nDefinition:\nA soft, rounded fleshy part hanging from the lower margin of the ear."
    },
    {
      id: 699,
      word: "armpit",
      transcription: "ˈɑːrmpɪt",
      translation: "пахва",
      description: "Example:\nIf you notice a red spot close to the tick bite or develop a rash around your armpit , groin and thighs or a flu-like illness after being bitten, see your GP.\nMay the fleas out 1000 camals infest your armpits!\nPhotographs of the belly and chest were taken while the dog was standing on its hind feet and two people held the front feet displaying the armpits.\nDefinition:\nA hollow under the arm at the shoulder."
    },
    {
      id: 700,
      word: "adorn",
      transcription: "əˈdɔːrn",
      translation: "прикрашати",
      description: "Example:\nThe text is fully bilingual , and portraits adorn nearly all entries.\nLike the bonbons that line gilded boxes of chocolates, their names adorn one storefront after another above displays of leather coats, designer purses and gold bracelets.\nThe Columbia's executive officer, the cuffs of his sleeves adorned with three solid yellow stripes of his rank, entered the foyer.\nDefinition:\nMake more beautiful or attractive."
    },
    {
      id: 701,
      word: "fragrance",
      transcription: "ˈfreɪgrənts",
      translation: "аромат",
      description: "Example:\nYo you know that cat J-Sin got that fragrance...\nYou may change you face, but Frag changes your mind.\nHey, did you get a whiff of that fragrance?\nDefinition:\na pleasingly sweet olfactory property"
    },
    {
      id: 702,
      word: "wink at",
      transcription: "wɪŋk ət",
      translation: "підморгувати",
      description: "Example:\nShe winked at him across the room.\nJames would only wink at him, a secretive smile gracing his handsome features…\nWink wink yes we know each other and yes we don't like each other fact is we know the stoners creed ur secrets are safe with me\nDefinition:\nTo close and open one eye quickly as a hint or signal."
    },
    {
      id: 703,
      word: "at first sight",
      transcription: "ət ˈfɜːst saɪt",
      translation: "з першого погляду",
      description: "Example:\nAt first sight this focus on the home might seem to impose a general standard of what is suitable for family viewing.\nAnti-discrimination laws might seem at first sight to not to affect this interplay of small corrections, but they do.\nAt first sight the most remarkable mineral of the vein is villiaumite.\nDefinition:\nwhen you see something for the first time:"
    },
    {
      id: 704,
      word: "lick",
      transcription: "lɪk",
      translation: "облизувати",
      description: "Example:\nthe cub licked the milk from its mother's breast\nI can't right now, let me just hit a lick and ill get you your money.\nYeah man, I'm tryna (trying to) catch a lick right now.\nDefinition:\ntake up with the tongue"
    },
    {
      id: 705,
      word: "child-bearing",
      transcription: " tʃaɪld ˈbeərɪŋ",
      translation: "вагітність",
      description: "Example:\nAt the same time, a belief in the social desirability of early marriage and early child-bearing continues to prevail in many countries.\nThough she was a shambles from face to life, those child bearing hips drew men like hounds on the trail of heat.\nWatch it dude, she's not of child-bearing age\nDefinition:\nThe act or process of carrying and giving birth to a child."
    },
    {
      id: 706,
      word: "curvaceous figure",
      transcription: "kɜːˈveɪʃəs ˈfɪgər",
      translation: "зваблива фігура",
      description: "Example:\nI understand why you amused yourself with that curvaceous figure.\nThat girl is so curvaceous and stacked.\nReal women have curves; anyone who says otherwise is a damn liar.\nDefinition:\nHaving or suggesting the curves of a well-proportioned feminine figure."
    },
    {
      id: 707,
      word: "beautician",
      transcription: "bjuːˈtɪʃən",
      translation: "косметолог",
      description: "Example:\nThe day I was there, the beautician started by cleaning the natural nail to remove the surface shine and oils and then applied disinfectant and primer.\nThis is a highly specialised treatment and should only be done by a qualified beautician .\nHairdressers and beauticians in Killaloe, Ballina, Limerick and Nenagh had a bumper day on Thursday last as over 100 young adults prepared for their Debs Dance.\nDefinition:\nA person whose job is to do beauty treatments."
    },
    {
      id: 708,
      word: "skin cream",
      transcription: "skɪn kri:m",
      translation: "крем для шкіри",
      description: "Example:\nDry, flaky skin that persists despite the use of hand lotion and skin creams could very well be a fungal infection.\nDifferent skin creams and lotions may be more effective on dry, oily or sensitive skin.\nIf you are concerned about caring for your skin you can buy skin cream, bug balm and wind balm - all made from only natural ingredients.\nDefinition:\nA cream is a preparation usually for application to the skin."
    },
    {
      id: 709,
      word: "tickle",
      transcription: "ˈtɪkl̩",
      translation: "лоскотати",
      description: "Example:\nIt was an odd, creeping feeling, that made her body tickle and itch at the same time.\nGeorge tickled the bottom of my feet so much that I started crying\nMen love to tickle themselves\nDefinition:\nLightly touch or prod a person or a part of the body in a way that causes mild discomfort or itching and often laughter."
    },
    {
      id: 710,
      word: "thigh",
      transcription: "θaɪ",
      translation: "Стегно",
      description: "Example:\nNo one really knows what causes these sudden, painful muscle spasms in the calf , the thigh or the arch of the foot.\nI am consistent with my eating habits and exercise routine but still cannot slim down my hips and thighs.\nShe suffered puncture wounds to both thighs and will be scarred for life .\nDefinition:\nThe part of the human leg between the hip and the knee."
    },
    {
      id: 711,
      word: "temple",
      transcription: "ˈtemp.əl",
      translation: "скроня",
      description: "Example:\nMany people visited the temple every day.\nThere were many statues inside the temple.\nThe temple had a peaceful garden.\nDefinition:\na building devoted to the worship, or regarded as the dwelling place, of a god or gods or other objects of religious reverence:"
    },
    {
      id: 712,
      word: "suck",
      transcription: "sʌk",
      translation: "висмоктувати",
      description: "Example:\nSuck on a piece of hard candy such as a peppermint stick.\nThere is a tradition of roasted suckling pig with a red egg in its snout.\nGalicians specialize in trencherman food: suckling pig , grilled skate, pulpy octopus speckled with sea salt and paprika.\nDefinition:\nDraw in a specified direction by creating a vacuum."
    },
    {
      id: 713,
      word: "stroke",
      transcription: "stroʊk",
      translation: "Інсульт",
      description: "Example:\nHe had a minor stroke in 1987, which left him partly paralysed.\nDo you know someone who’s had a stroke? Pay tribute to them\nDefinition:\nA sudden disabling attack or loss of consciousness caused by an interruption in the flow of blood to the brain, especially through thrombosis."
    },
    {
      id: 714,
      word: "spit",
      transcription: "spɪt",
      translation: "плювати",
      description: "Example:\nThe first time I hang out with this girl she's having shots of soy sauce to stimulate her salivary glands so her cheeks swell and spit shoots out of her mouth.\nThe veteran managed to go to the top of the leaderboard despite using her driver on only eight occasions.\nAs we have already seen, despite their races, regardless of their cultural differences, Mehuru and Frances do belong together.\nDefinition:\nForcibly eject food or liquid from one's mouth."
    },
    {
      id: 715,
      word: "rub",
      transcription: "rʌb",
      translation: "відтирати",
      description: "Example:\nFinally, rub down the wood to remove the splinters , give it a thin wash of acrylic paint and brush on the clear preservative.\nIn society, he was part of high society, and rubbed elbows with the beautiful people of the world.\nShe just loves the dramatic ruby red colour and the fresh raspberry taste.\nDefinition:\nMove one's hand, a cloth, or another object back and forth against a surface."
    },
    {
      id: 716,
      word: "rib",
      transcription: "rɪb",
      translation: "ребро",
      description: "Example:\nThis shows a longitudinal section of shoot apex and an orthostichy of leaf primordia that are forming a rib .\nOne of the youths is described as about 6ft tall with ginger hair and wearing a light blue top.\nA ribbed sweater\nDefinition:\nEach of a series of slender curved bones articulated in pairs to the spine twelve pairs in humans, protecting the thoracic cavity and its organs."
    },
    {
      id: 717,
      word: "suspicious",
      transcription: "səˈspɪʃ.əs",
      translation: "підозрілий",
      description: ""
    },
    {
      id: 718,
      word: "persistence",
      transcription: "pəˈsɪs.təns",
      translation: "наполегливість",
      description: ""
    },
    {
      id: 719,
      word: "occasion",
      transcription: "əˈkeɪ.ʒən",
      translation: "нагода",
      description: ""
    },
    {
      id: 720,
      word: "distract",
      transcription: "dɪˈstrækt",
      translation: "відволікати",
      description: ""
    },
    {
      id: 721,
      word: "obviously",
      transcription: "ˈɒb.vi.əs.li",
      translation: "очевидно",
      description: ""
    },
    { id: 722, word: "shy", transcription: "ʃaɪ", translation: "сором'язливий", description: "" },
    { id: 723, word: "snazzy", transcription: "ˈsnæz.i", translation: "шикарний", description: "" },
    { id: 724, word: "spin", transcription: "spɪn", translation: "спина", description: "" },
    { id: 725, word: "fin", transcription: "fɪn", translation: "плавець", description: "" },
    {
      id: 726,
      word: "foreigner",
      transcription: "ˈfɒr.ə.nər",
      translation: "іноземець",
      description: ""
    },
    {
      id: 727,
      word: "neighborhood",
      transcription: "ˈneɪ.bɚ.hʊd",
      translation: "околиці",
      description: ""
    },
    { id: 728, word: "attempt", transcription: "əˈtempt", translation: "спроба", description: "" },
    {
      id: 729,
      word: "supplement",
      transcription: "ˈsʌp.lɪ.mənt",
      translation: "додаток",
      description: ""
    },
    {
      id: 730,
      word: "polite",
      transcription: "pəˈlaɪt",
      translation: "ввічливий",
      description: ""
    },
    { id: 731, word: "enemy", transcription: "ˈen.ə.mi", translation: "ворог", description: "" },
    {
      id: 732,
      word: "delirium",
      transcription: "dɪˈlɪr.i.əm",
      translation: "марення",
      description: ""
    }
  ],
  setsWithWords: [
    { set_id: 27, word_id: 217, id: 697 },
    { set_id: 27, word_id: 239, id: 698 },
    { set_id: 27, word_id: 218, id: 699 },
    { set_id: 27, word_id: 219, id: 700 },
    { set_id: 27, word_id: 220, id: 701 },
    { set_id: 27, word_id: 221, id: 702 },
    { set_id: 27, word_id: 222, id: 703 },
    { set_id: 27, word_id: 223, id: 704 },
    { set_id: 27, word_id: 224, id: 705 },
    { set_id: 27, word_id: 225, id: 706 },
    { set_id: 27, word_id: 226, id: 707 },
    { set_id: 27, word_id: 227, id: 708 },
    { set_id: 27, word_id: 228, id: 709 },
    { set_id: 27, word_id: 229, id: 710 },
    { set_id: 27, word_id: 230, id: 711 },
    { set_id: 27, word_id: 231, id: 712 },
    { set_id: 27, word_id: 232, id: 713 },
    { set_id: 27, word_id: 233, id: 714 },
    { set_id: 27, word_id: 234, id: 715 },
    { set_id: 27, word_id: 235, id: 716 },
    { set_id: 27, word_id: 236, id: 717 },
    { set_id: 27, word_id: 237, id: 718 },
    { set_id: 27, word_id: 238, id: 719 },
    { set_id: 26, word_id: 199, id: 915 },
    { set_id: 26, word_id: 216, id: 916 },
    { set_id: 26, word_id: 200, id: 917 },
    { set_id: 26, word_id: 201, id: 918 },
    { set_id: 26, word_id: 202, id: 919 },
    { set_id: 26, word_id: 203, id: 920 },
    { set_id: 26, word_id: 204, id: 921 },
    { set_id: 26, word_id: 205, id: 922 },
    { set_id: 26, word_id: 206, id: 923 },
    { set_id: 26, word_id: 207, id: 924 },
    { set_id: 26, word_id: 208, id: 925 },
    { set_id: 26, word_id: 209, id: 926 },
    { set_id: 26, word_id: 210, id: 927 },
    { set_id: 26, word_id: 211, id: 928 },
    { set_id: 26, word_id: 212, id: 929 },
    { set_id: 26, word_id: 213, id: 930 },
    { set_id: 26, word_id: 214, id: 931 },
    { set_id: 26, word_id: 215, id: 932 },
    { set_id: 28, word_id: 240, id: 933 },
    { set_id: 28, word_id: 267, id: 934 },
    { set_id: 28, word_id: 241, id: 935 },
    { set_id: 28, word_id: 242, id: 936 },
    { set_id: 28, word_id: 243, id: 937 },
    { set_id: 28, word_id: 244, id: 938 },
    { set_id: 28, word_id: 245, id: 939 },
    { set_id: 28, word_id: 246, id: 940 },
    { set_id: 28, word_id: 247, id: 941 },
    { set_id: 28, word_id: 248, id: 942 },
    { set_id: 28, word_id: 249, id: 943 },
    { set_id: 28, word_id: 250, id: 944 },
    { set_id: 28, word_id: 251, id: 945 },
    { set_id: 28, word_id: 252, id: 946 },
    { set_id: 28, word_id: 253, id: 947 },
    { set_id: 28, word_id: 254, id: 948 },
    { set_id: 28, word_id: 255, id: 949 },
    { set_id: 28, word_id: 256, id: 950 },
    { set_id: 28, word_id: 257, id: 951 },
    { set_id: 28, word_id: 258, id: 952 },
    { set_id: 28, word_id: 259, id: 953 },
    { set_id: 28, word_id: 260, id: 954 },
    { set_id: 28, word_id: 261, id: 955 },
    { set_id: 28, word_id: 262, id: 956 },
    { set_id: 28, word_id: 263, id: 957 },
    { set_id: 28, word_id: 264, id: 958 },
    { set_id: 28, word_id: 265, id: 959 },
    { set_id: 28, word_id: 266, id: 960 },
    { set_id: 29, word_id: 268, id: 961 },
    { set_id: 29, word_id: 286, id: 962 },
    { set_id: 29, word_id: 269, id: 963 },
    { set_id: 29, word_id: 270, id: 964 },
    { set_id: 29, word_id: 271, id: 965 },
    { set_id: 29, word_id: 272, id: 966 },
    { set_id: 29, word_id: 273, id: 967 },
    { set_id: 29, word_id: 274, id: 968 },
    { set_id: 29, word_id: 275, id: 969 },
    { set_id: 29, word_id: 276, id: 970 },
    { set_id: 29, word_id: 277, id: 971 },
    { set_id: 29, word_id: 278, id: 972 },
    { set_id: 29, word_id: 279, id: 973 },
    { set_id: 29, word_id: 280, id: 974 },
    { set_id: 29, word_id: 281, id: 975 },
    { set_id: 29, word_id: 282, id: 976 },
    { set_id: 29, word_id: 283, id: 977 },
    { set_id: 29, word_id: 284, id: 978 },
    { set_id: 29, word_id: 285, id: 979 },
    { set_id: 30, word_id: 287, id: 980 },
    { set_id: 30, word_id: 311, id: 981 },
    { set_id: 30, word_id: 288, id: 982 },
    { set_id: 30, word_id: 289, id: 983 },
    { set_id: 30, word_id: 290, id: 984 },
    { set_id: 30, word_id: 291, id: 985 },
    { set_id: 30, word_id: 292, id: 986 },
    { set_id: 30, word_id: 293, id: 987 },
    { set_id: 30, word_id: 294, id: 988 },
    { set_id: 30, word_id: 295, id: 989 },
    { set_id: 30, word_id: 296, id: 990 },
    { set_id: 30, word_id: 297, id: 991 },
    { set_id: 30, word_id: 298, id: 992 },
    { set_id: 30, word_id: 299, id: 993 },
    { set_id: 30, word_id: 300, id: 994 },
    { set_id: 30, word_id: 301, id: 995 },
    { set_id: 30, word_id: 302, id: 996 },
    { set_id: 30, word_id: 303, id: 997 },
    { set_id: 30, word_id: 304, id: 998 },
    { set_id: 30, word_id: 305, id: 999 },
    { set_id: 30, word_id: 306, id: 1e3 },
    { set_id: 30, word_id: 307, id: 1001 },
    { set_id: 30, word_id: 308, id: 1002 },
    { set_id: 30, word_id: 309, id: 1003 },
    { set_id: 30, word_id: 310, id: 1004 },
    { set_id: 31, word_id: 312, id: 1005 },
    { set_id: 31, word_id: 328, id: 1006 },
    { set_id: 31, word_id: 313, id: 1007 },
    { set_id: 31, word_id: 314, id: 1008 },
    { set_id: 31, word_id: 315, id: 1009 },
    { set_id: 31, word_id: 316, id: 1010 },
    { set_id: 31, word_id: 317, id: 1011 },
    { set_id: 31, word_id: 318, id: 1012 },
    { set_id: 31, word_id: 319, id: 1013 },
    { set_id: 31, word_id: 320, id: 1014 },
    { set_id: 31, word_id: 321, id: 1015 },
    { set_id: 31, word_id: 322, id: 1016 },
    { set_id: 31, word_id: 323, id: 1017 },
    { set_id: 31, word_id: 324, id: 1018 },
    { set_id: 31, word_id: 325, id: 1019 },
    { set_id: 31, word_id: 326, id: 1020 },
    { set_id: 31, word_id: 327, id: 1021 },
    { set_id: 32, word_id: 329, id: 1022 },
    { set_id: 32, word_id: 367, id: 1023 },
    { set_id: 32, word_id: 330, id: 1024 },
    { set_id: 32, word_id: 331, id: 1025 },
    { set_id: 32, word_id: 332, id: 1026 },
    { set_id: 32, word_id: 334, id: 1027 },
    { set_id: 32, word_id: 333, id: 1028 },
    { set_id: 32, word_id: 335, id: 1029 },
    { set_id: 32, word_id: 336, id: 1030 },
    { set_id: 32, word_id: 337, id: 1031 },
    { set_id: 32, word_id: 338, id: 1032 },
    { set_id: 32, word_id: 339, id: 1033 },
    { set_id: 32, word_id: 340, id: 1034 },
    { set_id: 32, word_id: 341, id: 1035 },
    { set_id: 32, word_id: 342, id: 1036 },
    { set_id: 32, word_id: 343, id: 1037 },
    { set_id: 32, word_id: 344, id: 1038 },
    { set_id: 32, word_id: 345, id: 1039 },
    { set_id: 32, word_id: 346, id: 1040 },
    { set_id: 32, word_id: 347, id: 1041 },
    { set_id: 32, word_id: 348, id: 1042 },
    { set_id: 32, word_id: 349, id: 1043 },
    { set_id: 32, word_id: 351, id: 1044 },
    { set_id: 32, word_id: 350, id: 1045 },
    { set_id: 32, word_id: 352, id: 1046 },
    { set_id: 32, word_id: 353, id: 1047 },
    { set_id: 32, word_id: 354, id: 1048 },
    { set_id: 32, word_id: 355, id: 1049 },
    { set_id: 32, word_id: 356, id: 1050 },
    { set_id: 32, word_id: 357, id: 1051 },
    { set_id: 32, word_id: 358, id: 1052 },
    { set_id: 32, word_id: 359, id: 1053 },
    { set_id: 32, word_id: 360, id: 1054 },
    { set_id: 32, word_id: 361, id: 1055 },
    { set_id: 32, word_id: 362, id: 1056 },
    { set_id: 32, word_id: 363, id: 1057 },
    { set_id: 32, word_id: 364, id: 1058 },
    { set_id: 32, word_id: 365, id: 1059 },
    { set_id: 32, word_id: 366, id: 1060 },
    { set_id: 33, word_id: 368, id: 1061 },
    { set_id: 33, word_id: 385, id: 1062 },
    { set_id: 33, word_id: 369, id: 1063 },
    { set_id: 33, word_id: 370, id: 1064 },
    { set_id: 33, word_id: 371, id: 1065 },
    { set_id: 33, word_id: 372, id: 1066 },
    { set_id: 33, word_id: 373, id: 1067 },
    { set_id: 33, word_id: 374, id: 1068 },
    { set_id: 33, word_id: 375, id: 1069 },
    { set_id: 33, word_id: 376, id: 1070 },
    { set_id: 33, word_id: 377, id: 1071 },
    { set_id: 33, word_id: 378, id: 1072 },
    { set_id: 33, word_id: 379, id: 1073 },
    { set_id: 33, word_id: 380, id: 1074 },
    { set_id: 33, word_id: 381, id: 1075 },
    { set_id: 33, word_id: 382, id: 1076 },
    { set_id: 33, word_id: 383, id: 1077 },
    { set_id: 33, word_id: 384, id: 1078 },
    { set_id: 34, word_id: 386, id: 1079 },
    { set_id: 34, word_id: 387, id: 1080 },
    { set_id: 34, word_id: 388, id: 1081 },
    { set_id: 34, word_id: 389, id: 1082 },
    { set_id: 34, word_id: 390, id: 1083 },
    { set_id: 34, word_id: 391, id: 1084 },
    { set_id: 34, word_id: 392, id: 1085 },
    { set_id: 34, word_id: 393, id: 1086 },
    { set_id: 34, word_id: 394, id: 1087 },
    { set_id: 34, word_id: 395, id: 1088 },
    { set_id: 34, word_id: 396, id: 1089 },
    { set_id: 34, word_id: 397, id: 1090 },
    { set_id: 34, word_id: 398, id: 1091 },
    { set_id: 34, word_id: 399, id: 1092 },
    { set_id: 34, word_id: 400, id: 1093 },
    { set_id: 34, word_id: 401, id: 1094 },
    { set_id: 34, word_id: 402, id: 1095 },
    { set_id: 34, word_id: 403, id: 1096 },
    { set_id: 34, word_id: 404, id: 1097 },
    { set_id: 35, word_id: 405, id: 1098 },
    { set_id: 35, word_id: 423, id: 1099 },
    { set_id: 35, word_id: 406, id: 1100 },
    { set_id: 35, word_id: 407, id: 1101 },
    { set_id: 35, word_id: 408, id: 1102 },
    { set_id: 35, word_id: 409, id: 1103 },
    { set_id: 35, word_id: 410, id: 1104 },
    { set_id: 35, word_id: 411, id: 1105 },
    { set_id: 35, word_id: 412, id: 1106 },
    { set_id: 35, word_id: 413, id: 1107 },
    { set_id: 35, word_id: 414, id: 1108 },
    { set_id: 35, word_id: 415, id: 1109 },
    { set_id: 35, word_id: 416, id: 1110 },
    { set_id: 35, word_id: 417, id: 1111 },
    { set_id: 35, word_id: 418, id: 1112 },
    { set_id: 35, word_id: 419, id: 1113 },
    { set_id: 35, word_id: 420, id: 1114 },
    { set_id: 35, word_id: 421, id: 1115 },
    { set_id: 35, word_id: 422, id: 1116 },
    { set_id: 36, word_id: 424, id: 1117 },
    { set_id: 36, word_id: 442, id: 1118 },
    { set_id: 36, word_id: 425, id: 1119 },
    { set_id: 36, word_id: 426, id: 1120 },
    { set_id: 36, word_id: 427, id: 1121 },
    { set_id: 36, word_id: 428, id: 1122 },
    { set_id: 36, word_id: 429, id: 1123 },
    { set_id: 36, word_id: 430, id: 1124 },
    { set_id: 36, word_id: 431, id: 1125 },
    { set_id: 36, word_id: 432, id: 1126 },
    { set_id: 36, word_id: 433, id: 1127 },
    { set_id: 36, word_id: 434, id: 1128 },
    { set_id: 36, word_id: 435, id: 1129 },
    { set_id: 36, word_id: 436, id: 1130 },
    { set_id: 36, word_id: 437, id: 1131 },
    { set_id: 36, word_id: 438, id: 1132 },
    { set_id: 36, word_id: 439, id: 1133 },
    { set_id: 36, word_id: 440, id: 1134 },
    { set_id: 36, word_id: 441, id: 1135 },
    { set_id: 37, word_id: 443, id: 1136 },
    { set_id: 37, word_id: 461, id: 1137 },
    { set_id: 37, word_id: 444, id: 1138 },
    { set_id: 37, word_id: 445, id: 1139 },
    { set_id: 37, word_id: 446, id: 1140 },
    { set_id: 37, word_id: 447, id: 1141 },
    { set_id: 37, word_id: 448, id: 1142 },
    { set_id: 37, word_id: 449, id: 1143 },
    { set_id: 37, word_id: 450, id: 1144 },
    { set_id: 37, word_id: 451, id: 1145 },
    { set_id: 37, word_id: 452, id: 1146 },
    { set_id: 37, word_id: 453, id: 1147 },
    { set_id: 37, word_id: 454, id: 1148 },
    { set_id: 37, word_id: 455, id: 1149 },
    { set_id: 37, word_id: 456, id: 1150 },
    { set_id: 37, word_id: 457, id: 1151 },
    { set_id: 37, word_id: 458, id: 1152 },
    { set_id: 37, word_id: 459, id: 1153 },
    { set_id: 37, word_id: 460, id: 1154 },
    { set_id: 38, word_id: 462, id: 1155 },
    { set_id: 38, word_id: 493, id: 1156 },
    { set_id: 38, word_id: 463, id: 1157 },
    { set_id: 38, word_id: 464, id: 1158 },
    { set_id: 38, word_id: 465, id: 1159 },
    { set_id: 38, word_id: 466, id: 1160 },
    { set_id: 38, word_id: 467, id: 1161 },
    { set_id: 38, word_id: 468, id: 1162 },
    { set_id: 38, word_id: 469, id: 1163 },
    { set_id: 38, word_id: 470, id: 1164 },
    { set_id: 38, word_id: 471, id: 1165 },
    { set_id: 38, word_id: 472, id: 1166 },
    { set_id: 38, word_id: 473, id: 1167 },
    { set_id: 38, word_id: 474, id: 1168 },
    { set_id: 38, word_id: 475, id: 1169 },
    { set_id: 38, word_id: 476, id: 1170 },
    { set_id: 38, word_id: 477, id: 1171 },
    { set_id: 38, word_id: 478, id: 1172 },
    { set_id: 38, word_id: 479, id: 1173 },
    { set_id: 38, word_id: 480, id: 1174 },
    { set_id: 38, word_id: 481, id: 1175 },
    { set_id: 38, word_id: 482, id: 1176 },
    { set_id: 38, word_id: 483, id: 1177 },
    { set_id: 38, word_id: 484, id: 1178 },
    { set_id: 38, word_id: 485, id: 1179 },
    { set_id: 38, word_id: 486, id: 1180 },
    { set_id: 38, word_id: 487, id: 1181 },
    { set_id: 38, word_id: 488, id: 1182 },
    { set_id: 38, word_id: 489, id: 1183 },
    { set_id: 38, word_id: 490, id: 1184 },
    { set_id: 38, word_id: 491, id: 1185 },
    { set_id: 38, word_id: 492, id: 1186 },
    { set_id: 39, word_id: 494, id: 1187 },
    { set_id: 39, word_id: 509, id: 1188 },
    { set_id: 39, word_id: 495, id: 1189 },
    { set_id: 39, word_id: 496, id: 1190 },
    { set_id: 39, word_id: 497, id: 1191 },
    { set_id: 39, word_id: 498, id: 1192 },
    { set_id: 39, word_id: 499, id: 1193 },
    { set_id: 39, word_id: 500, id: 1194 },
    { set_id: 39, word_id: 501, id: 1195 },
    { set_id: 39, word_id: 502, id: 1196 },
    { set_id: 39, word_id: 503, id: 1197 },
    { set_id: 39, word_id: 504, id: 1198 },
    { set_id: 39, word_id: 505, id: 1199 },
    { set_id: 39, word_id: 506, id: 1200 },
    { set_id: 39, word_id: 507, id: 1201 },
    { set_id: 39, word_id: 508, id: 1202 },
    { set_id: 40, word_id: 510, id: 1203 },
    { set_id: 40, word_id: 528, id: 1204 },
    { set_id: 40, word_id: 511, id: 1205 },
    { set_id: 40, word_id: 512, id: 1206 },
    { set_id: 40, word_id: 513, id: 1207 },
    { set_id: 40, word_id: 514, id: 1208 },
    { set_id: 40, word_id: 515, id: 1209 },
    { set_id: 40, word_id: 516, id: 1210 },
    { set_id: 40, word_id: 517, id: 1211 },
    { set_id: 40, word_id: 518, id: 1212 },
    { set_id: 40, word_id: 519, id: 1213 },
    { set_id: 40, word_id: 520, id: 1214 },
    { set_id: 40, word_id: 521, id: 1215 },
    { set_id: 40, word_id: 522, id: 1216 },
    { set_id: 40, word_id: 523, id: 1217 },
    { set_id: 40, word_id: 524, id: 1218 },
    { set_id: 40, word_id: 525, id: 1219 },
    { set_id: 40, word_id: 526, id: 1220 },
    { set_id: 40, word_id: 527, id: 1221 },
    { set_id: 41, word_id: 529, id: 1222 },
    { set_id: 41, word_id: 530, id: 1223 },
    { set_id: 41, word_id: 531, id: 1224 },
    { set_id: 41, word_id: 546, id: 1225 },
    { set_id: 41, word_id: 532, id: 1226 },
    { set_id: 41, word_id: 533, id: 1227 },
    { set_id: 41, word_id: 534, id: 1228 },
    { set_id: 41, word_id: 535, id: 1229 },
    { set_id: 41, word_id: 536, id: 1230 },
    { set_id: 41, word_id: 537, id: 1231 },
    { set_id: 41, word_id: 538, id: 1232 },
    { set_id: 41, word_id: 539, id: 1233 },
    { set_id: 41, word_id: 540, id: 1234 },
    { set_id: 41, word_id: 541, id: 1235 },
    { set_id: 41, word_id: 542, id: 1236 },
    { set_id: 41, word_id: 543, id: 1237 },
    { set_id: 41, word_id: 544, id: 1238 },
    { set_id: 41, word_id: 545, id: 1239 },
    { set_id: 42, word_id: 547, id: 1240 },
    { set_id: 42, word_id: 577, id: 1241 },
    { set_id: 42, word_id: 548, id: 1242 },
    { set_id: 42, word_id: 549, id: 1243 },
    { set_id: 42, word_id: 550, id: 1244 },
    { set_id: 42, word_id: 551, id: 1245 },
    { set_id: 42, word_id: 552, id: 1246 },
    { set_id: 42, word_id: 553, id: 1247 },
    { set_id: 42, word_id: 554, id: 1248 },
    { set_id: 42, word_id: 555, id: 1249 },
    { set_id: 42, word_id: 556, id: 1250 },
    { set_id: 42, word_id: 557, id: 1251 },
    { set_id: 42, word_id: 558, id: 1252 },
    { set_id: 42, word_id: 559, id: 1253 },
    { set_id: 42, word_id: 560, id: 1254 },
    { set_id: 42, word_id: 561, id: 1255 },
    { set_id: 42, word_id: 562, id: 1256 },
    { set_id: 42, word_id: 563, id: 1257 },
    { set_id: 42, word_id: 564, id: 1258 },
    { set_id: 42, word_id: 565, id: 1259 },
    { set_id: 42, word_id: 566, id: 1260 },
    { set_id: 42, word_id: 567, id: 1261 },
    { set_id: 42, word_id: 568, id: 1262 },
    { set_id: 42, word_id: 569, id: 1263 },
    { set_id: 42, word_id: 570, id: 1264 },
    { set_id: 42, word_id: 571, id: 1265 },
    { set_id: 42, word_id: 572, id: 1266 },
    { set_id: 42, word_id: 573, id: 1267 },
    { set_id: 42, word_id: 574, id: 1268 },
    { set_id: 42, word_id: 575, id: 1269 },
    { set_id: 42, word_id: 576, id: 1270 },
    { set_id: 43, word_id: 578, id: 1271 },
    { set_id: 43, word_id: 602, id: 1272 },
    { set_id: 43, word_id: 579, id: 1273 },
    { set_id: 43, word_id: 580, id: 1274 },
    { set_id: 43, word_id: 581, id: 1275 },
    { set_id: 43, word_id: 582, id: 1276 },
    { set_id: 43, word_id: 583, id: 1277 },
    { set_id: 43, word_id: 584, id: 1278 },
    { set_id: 43, word_id: 585, id: 1279 },
    { set_id: 43, word_id: 586, id: 1280 },
    { set_id: 43, word_id: 587, id: 1281 },
    { set_id: 43, word_id: 588, id: 1282 },
    { set_id: 43, word_id: 589, id: 1283 },
    { set_id: 43, word_id: 590, id: 1284 },
    { set_id: 43, word_id: 591, id: 1285 },
    { set_id: 43, word_id: 592, id: 1286 },
    { set_id: 43, word_id: 593, id: 1287 },
    { set_id: 43, word_id: 594, id: 1288 },
    { set_id: 43, word_id: 595, id: 1289 },
    { set_id: 43, word_id: 596, id: 1290 },
    { set_id: 43, word_id: 597, id: 1291 },
    { set_id: 43, word_id: 598, id: 1292 },
    { set_id: 43, word_id: 599, id: 1293 },
    { set_id: 43, word_id: 600, id: 1294 },
    { set_id: 43, word_id: 601, id: 1295 },
    { set_id: 44, word_id: 603, id: 1296 },
    { set_id: 44, word_id: 621, id: 1297 },
    { set_id: 44, word_id: 604, id: 1298 },
    { set_id: 44, word_id: 605, id: 1299 },
    { set_id: 44, word_id: 606, id: 1300 },
    { set_id: 44, word_id: 607, id: 1301 },
    { set_id: 44, word_id: 608, id: 1302 },
    { set_id: 44, word_id: 609, id: 1303 },
    { set_id: 44, word_id: 610, id: 1304 },
    { set_id: 44, word_id: 611, id: 1305 },
    { set_id: 44, word_id: 612, id: 1306 },
    { set_id: 44, word_id: 613, id: 1307 },
    { set_id: 44, word_id: 614, id: 1308 },
    { set_id: 44, word_id: 615, id: 1309 },
    { set_id: 44, word_id: 616, id: 1310 },
    { set_id: 44, word_id: 617, id: 1311 },
    { set_id: 44, word_id: 618, id: 1312 },
    { set_id: 44, word_id: 619, id: 1313 },
    { set_id: 44, word_id: 620, id: 1314 },
    { set_id: 45, word_id: 622, id: 1315 },
    { set_id: 45, word_id: 640, id: 1316 },
    { set_id: 45, word_id: 623, id: 1317 },
    { set_id: 45, word_id: 624, id: 1318 },
    { set_id: 45, word_id: 626, id: 1319 },
    { set_id: 45, word_id: 625, id: 1320 },
    { set_id: 45, word_id: 627, id: 1321 },
    { set_id: 45, word_id: 628, id: 1322 },
    { set_id: 45, word_id: 629, id: 1323 },
    { set_id: 45, word_id: 630, id: 1324 },
    { set_id: 45, word_id: 631, id: 1325 },
    { set_id: 45, word_id: 632, id: 1326 },
    { set_id: 45, word_id: 633, id: 1327 },
    { set_id: 45, word_id: 634, id: 1328 },
    { set_id: 45, word_id: 635, id: 1329 },
    { set_id: 45, word_id: 636, id: 1330 },
    { set_id: 45, word_id: 637, id: 1331 },
    { set_id: 45, word_id: 638, id: 1332 },
    { set_id: 45, word_id: 639, id: 1333 },
    { set_id: 46, word_id: 641, id: 1334 },
    { set_id: 46, word_id: 665, id: 1335 },
    { set_id: 46, word_id: 642, id: 1336 },
    { set_id: 46, word_id: 643, id: 1337 },
    { set_id: 46, word_id: 644, id: 1338 },
    { set_id: 46, word_id: 645, id: 1339 },
    { set_id: 46, word_id: 646, id: 1340 },
    { set_id: 46, word_id: 647, id: 1341 },
    { set_id: 46, word_id: 648, id: 1342 },
    { set_id: 46, word_id: 649, id: 1343 },
    { set_id: 46, word_id: 650, id: 1344 },
    { set_id: 46, word_id: 651, id: 1345 },
    { set_id: 46, word_id: 652, id: 1346 },
    { set_id: 46, word_id: 653, id: 1347 },
    { set_id: 46, word_id: 654, id: 1348 },
    { set_id: 46, word_id: 655, id: 1349 },
    { set_id: 46, word_id: 656, id: 1350 },
    { set_id: 46, word_id: 657, id: 1351 },
    { set_id: 46, word_id: 658, id: 1352 },
    { set_id: 46, word_id: 659, id: 1353 },
    { set_id: 46, word_id: 660, id: 1354 },
    { set_id: 46, word_id: 661, id: 1355 },
    { set_id: 46, word_id: 662, id: 1356 },
    { set_id: 46, word_id: 663, id: 1357 },
    { set_id: 46, word_id: 664, id: 1358 },
    { set_id: 47, word_id: 666, id: 1359 },
    { set_id: 47, word_id: 667, id: 1360 },
    { set_id: 47, word_id: 668, id: 1361 },
    { set_id: 47, word_id: 669, id: 1362 },
    { set_id: 47, word_id: 670, id: 1363 },
    { set_id: 47, word_id: 671, id: 1364 },
    { set_id: 47, word_id: 672, id: 1365 },
    { set_id: 47, word_id: 673, id: 1366 },
    { set_id: 47, word_id: 674, id: 1367 },
    { set_id: 47, word_id: 675, id: 1368 },
    { set_id: 47, word_id: 676, id: 1369 },
    { set_id: 47, word_id: 677, id: 1370 },
    { set_id: 47, word_id: 678, id: 1371 },
    { set_id: 47, word_id: 679, id: 1372 },
    { set_id: 47, word_id: 680, id: 1373 },
    { set_id: 47, word_id: 681, id: 1374 },
    { set_id: 47, word_id: 682, id: 1375 },
    { set_id: 47, word_id: 683, id: 1376 },
    { set_id: 47, word_id: 684, id: 1377 },
    { set_id: 47, word_id: 685, id: 1378 },
    { set_id: 48, word_id: 686, id: 1379 },
    { set_id: 48, word_id: 701, id: 1380 },
    { set_id: 48, word_id: 687, id: 1381 },
    { set_id: 48, word_id: 688, id: 1382 },
    { set_id: 48, word_id: 689, id: 1383 },
    { set_id: 48, word_id: 690, id: 1384 },
    { set_id: 48, word_id: 691, id: 1385 },
    { set_id: 48, word_id: 692, id: 1386 },
    { set_id: 48, word_id: 693, id: 1387 },
    { set_id: 48, word_id: 694, id: 1388 },
    { set_id: 48, word_id: 695, id: 1389 },
    { set_id: 48, word_id: 696, id: 1390 },
    { set_id: 48, word_id: 697, id: 1391 },
    { set_id: 48, word_id: 698, id: 1392 },
    { set_id: 48, word_id: 699, id: 1393 },
    { set_id: 48, word_id: 700, id: 1394 },
    { set_id: 49, word_id: 702, id: 1395 },
    { set_id: 49, word_id: 703, id: 1396 },
    { set_id: 49, word_id: 704, id: 1397 },
    { set_id: 49, word_id: 705, id: 1398 },
    { set_id: 49, word_id: 706, id: 1399 },
    { set_id: 49, word_id: 707, id: 1400 },
    { set_id: 49, word_id: 708, id: 1401 },
    { set_id: 49, word_id: 709, id: 1402 },
    { set_id: 49, word_id: 711, id: 1403 },
    { set_id: 49, word_id: 710, id: 1404 },
    { set_id: 49, word_id: 712, id: 1405 },
    { set_id: 49, word_id: 713, id: 1406 },
    { set_id: 49, word_id: 714, id: 1407 },
    { set_id: 49, word_id: 715, id: 1408 },
    { set_id: 49, word_id: 716, id: 1409 },
    { set_id: 22, word_id: 84, id: 1545 },
    { set_id: 22, word_id: 85, id: 1546 },
    { set_id: 22, word_id: 86, id: 1547 },
    { set_id: 22, word_id: 87, id: 1548 },
    { set_id: 22, word_id: 88, id: 1549 },
    { set_id: 22, word_id: 89, id: 1550 },
    { set_id: 22, word_id: 90, id: 1551 },
    { set_id: 22, word_id: 91, id: 1552 },
    { set_id: 22, word_id: 92, id: 1553 },
    { set_id: 22, word_id: 93, id: 1554 },
    { set_id: 22, word_id: 94, id: 1555 },
    { set_id: 22, word_id: 95, id: 1556 },
    { set_id: 22, word_id: 96, id: 1557 },
    { set_id: 22, word_id: 97, id: 1558 },
    { set_id: 22, word_id: 98, id: 1559 },
    { set_id: 22, word_id: 99, id: 1560 },
    { set_id: 22, word_id: 100, id: 1561 },
    { set_id: 22, word_id: 101, id: 1562 },
    { set_id: 22, word_id: 102, id: 1563 },
    { set_id: 22, word_id: 103, id: 1564 },
    { set_id: 22, word_id: 104, id: 1565 },
    { set_id: 22, word_id: 105, id: 1566 },
    { set_id: 22, word_id: 106, id: 1567 },
    { set_id: 23, word_id: 107, id: 1568 },
    { set_id: 23, word_id: 127, id: 1569 },
    { set_id: 23, word_id: 108, id: 1570 },
    { set_id: 23, word_id: 109, id: 1571 },
    { set_id: 23, word_id: 110, id: 1572 },
    { set_id: 23, word_id: 111, id: 1573 },
    { set_id: 23, word_id: 112, id: 1574 },
    { set_id: 23, word_id: 113, id: 1575 },
    { set_id: 23, word_id: 114, id: 1576 },
    { set_id: 23, word_id: 115, id: 1577 },
    { set_id: 23, word_id: 116, id: 1578 },
    { set_id: 23, word_id: 117, id: 1579 },
    { set_id: 23, word_id: 118, id: 1580 },
    { set_id: 23, word_id: 119, id: 1581 },
    { set_id: 23, word_id: 120, id: 1582 },
    { set_id: 23, word_id: 122, id: 1583 },
    { set_id: 23, word_id: 121, id: 1584 },
    { set_id: 23, word_id: 123, id: 1585 },
    { set_id: 23, word_id: 124, id: 1586 },
    { set_id: 23, word_id: 125, id: 1587 },
    { set_id: 23, word_id: 126, id: 1588 },
    { set_id: 24, word_id: 128, id: 1589 },
    { set_id: 24, word_id: 170, id: 1590 },
    { set_id: 24, word_id: 129, id: 1591 },
    { set_id: 24, word_id: 130, id: 1592 },
    { set_id: 24, word_id: 132, id: 1593 },
    { set_id: 24, word_id: 131, id: 1594 },
    { set_id: 24, word_id: 133, id: 1595 },
    { set_id: 24, word_id: 134, id: 1596 },
    { set_id: 24, word_id: 135, id: 1597 },
    { set_id: 24, word_id: 136, id: 1598 },
    { set_id: 24, word_id: 137, id: 1599 },
    { set_id: 24, word_id: 138, id: 1600 },
    { set_id: 24, word_id: 139, id: 1601 },
    { set_id: 24, word_id: 140, id: 1602 },
    { set_id: 24, word_id: 141, id: 1603 },
    { set_id: 24, word_id: 142, id: 1604 },
    { set_id: 24, word_id: 143, id: 1605 },
    { set_id: 24, word_id: 144, id: 1606 },
    { set_id: 24, word_id: 145, id: 1607 },
    { set_id: 24, word_id: 146, id: 1608 },
    { set_id: 24, word_id: 147, id: 1609 },
    { set_id: 24, word_id: 148, id: 1610 },
    { set_id: 24, word_id: 149, id: 1611 },
    { set_id: 24, word_id: 150, id: 1612 },
    { set_id: 24, word_id: 151, id: 1613 },
    { set_id: 24, word_id: 152, id: 1614 },
    { set_id: 24, word_id: 153, id: 1615 },
    { set_id: 24, word_id: 154, id: 1616 },
    { set_id: 24, word_id: 155, id: 1617 },
    { set_id: 24, word_id: 156, id: 1618 },
    { set_id: 24, word_id: 157, id: 1619 },
    { set_id: 24, word_id: 158, id: 1620 },
    { set_id: 24, word_id: 159, id: 1621 },
    { set_id: 24, word_id: 160, id: 1622 },
    { set_id: 24, word_id: 161, id: 1623 },
    { set_id: 24, word_id: 162, id: 1624 },
    { set_id: 24, word_id: 163, id: 1625 },
    { set_id: 24, word_id: 164, id: 1626 },
    { set_id: 24, word_id: 165, id: 1627 },
    { set_id: 24, word_id: 166, id: 1628 },
    { set_id: 24, word_id: 167, id: 1629 },
    { set_id: 24, word_id: 168, id: 1630 },
    { set_id: 24, word_id: 169, id: 1631 },
    { set_id: 25, word_id: 171, id: 1632 },
    { set_id: 25, word_id: 172, id: 1633 },
    { set_id: 25, word_id: 174, id: 1634 },
    { set_id: 25, word_id: 173, id: 1635 },
    { set_id: 25, word_id: 175, id: 1636 },
    { set_id: 25, word_id: 176, id: 1637 },
    { set_id: 25, word_id: 177, id: 1638 },
    { set_id: 25, word_id: 178, id: 1639 },
    { set_id: 25, word_id: 179, id: 1640 },
    { set_id: 25, word_id: 180, id: 1641 },
    { set_id: 25, word_id: 181, id: 1642 },
    { set_id: 25, word_id: 182, id: 1643 },
    { set_id: 25, word_id: 183, id: 1644 },
    { set_id: 25, word_id: 185, id: 1645 },
    { set_id: 25, word_id: 184, id: 1646 },
    { set_id: 25, word_id: 186, id: 1647 },
    { set_id: 25, word_id: 187, id: 1648 },
    { set_id: 25, word_id: 188, id: 1649 },
    { set_id: 25, word_id: 189, id: 1650 },
    { set_id: 25, word_id: 190, id: 1651 },
    { set_id: 25, word_id: 191, id: 1652 },
    { set_id: 25, word_id: 192, id: 1653 },
    { set_id: 25, word_id: 193, id: 1654 },
    { set_id: 25, word_id: 194, id: 1655 },
    { set_id: 25, word_id: 195, id: 1656 },
    { set_id: 25, word_id: 196, id: 1657 },
    { set_id: 25, word_id: 197, id: 1658 },
    { set_id: 25, word_id: 198, id: 1659 },
    { set_id: 20, word_id: 4, id: 2668 },
    { set_id: 20, word_id: 5, id: 2669 },
    { set_id: 20, word_id: 6, id: 2670 },
    { set_id: 20, word_id: 7, id: 2671 },
    { set_id: 20, word_id: 8, id: 2672 },
    { set_id: 20, word_id: 9, id: 2673 },
    { set_id: 20, word_id: 10, id: 2674 },
    { set_id: 20, word_id: 11, id: 2675 },
    { set_id: 20, word_id: 12, id: 2676 },
    { set_id: 20, word_id: 13, id: 2677 },
    { set_id: 20, word_id: 14, id: 2678 },
    { set_id: 20, word_id: 15, id: 2679 },
    { set_id: 20, word_id: 16, id: 2680 },
    { set_id: 20, word_id: 17, id: 2681 },
    { set_id: 20, word_id: 18, id: 2682 },
    { set_id: 20, word_id: 19, id: 2683 },
    { set_id: 20, word_id: 20, id: 2684 },
    { set_id: 20, word_id: 21, id: 2685 },
    { set_id: 20, word_id: 22, id: 2686 },
    { set_id: 20, word_id: 23, id: 2687 },
    { set_id: 20, word_id: 24, id: 2688 },
    { set_id: 20, word_id: 25, id: 2689 },
    { set_id: 20, word_id: 26, id: 2690 },
    { set_id: 20, word_id: 27, id: 2691 },
    { set_id: 20, word_id: 28, id: 2692 },
    { set_id: 20, word_id: 29, id: 2693 },
    { set_id: 20, word_id: 30, id: 2694 },
    { set_id: 20, word_id: 31, id: 2695 },
    { set_id: 20, word_id: 32, id: 2696 },
    { set_id: 20, word_id: 33, id: 2697 },
    { set_id: 20, word_id: 34, id: 2698 },
    { set_id: 20, word_id: 35, id: 2699 },
    { set_id: 20, word_id: 36, id: 2700 },
    { set_id: 20, word_id: 37, id: 2701 },
    { set_id: 20, word_id: 38, id: 2702 },
    { set_id: 20, word_id: 39, id: 2703 },
    { set_id: 20, word_id: 40, id: 2704 },
    { set_id: 20, word_id: 41, id: 2705 },
    { set_id: 20, word_id: 42, id: 2706 },
    { set_id: 20, word_id: 43, id: 2707 },
    { set_id: 20, word_id: 44, id: 2708 },
    { set_id: 20, word_id: 45, id: 2709 },
    { set_id: 20, word_id: 46, id: 2710 },
    { set_id: 20, word_id: 47, id: 2711 },
    { set_id: 20, word_id: 48, id: 2712 },
    { set_id: 20, word_id: 49, id: 2713 },
    { set_id: 20, word_id: 50, id: 2714 },
    { set_id: 20, word_id: 51, id: 2715 },
    { set_id: 20, word_id: 52, id: 2716 },
    { set_id: 20, word_id: 53, id: 2717 },
    { set_id: 20, word_id: 54, id: 2718 },
    { set_id: 20, word_id: 55, id: 2719 },
    { set_id: 20, word_id: 56, id: 2720 },
    { set_id: 20, word_id: 57, id: 2721 },
    { set_id: 20, word_id: 58, id: 2722 },
    { set_id: 20, word_id: 59, id: 2723 },
    { set_id: 21, word_id: 60, id: 2724 },
    { set_id: 21, word_id: 61, id: 2725 },
    { set_id: 21, word_id: 62, id: 2726 },
    { set_id: 21, word_id: 63, id: 2727 },
    { set_id: 21, word_id: 64, id: 2728 },
    { set_id: 21, word_id: 65, id: 2729 },
    { set_id: 21, word_id: 66, id: 2730 },
    { set_id: 21, word_id: 67, id: 2731 },
    { set_id: 21, word_id: 68, id: 2732 },
    { set_id: 21, word_id: 69, id: 2733 },
    { set_id: 21, word_id: 70, id: 2734 },
    { set_id: 21, word_id: 71, id: 2735 },
    { set_id: 21, word_id: 72, id: 2736 },
    { set_id: 21, word_id: 73, id: 2737 },
    { set_id: 21, word_id: 74, id: 2738 },
    { set_id: 21, word_id: 75, id: 2739 },
    { set_id: 21, word_id: 76, id: 2740 },
    { set_id: 21, word_id: 77, id: 2741 },
    { set_id: 21, word_id: 78, id: 2742 },
    { set_id: 21, word_id: 79, id: 2743 },
    { set_id: 21, word_id: 80, id: 2744 },
    { set_id: 21, word_id: 81, id: 2745 },
    { set_id: 21, word_id: 82, id: 2746 },
    { set_id: 21, word_id: 83, id: 2747 }
  ]
};
async function createJSStoreDbContext() {
  const connection = new npm_exportExports.Connection();
  connection.addPlugin(workerInjector);
  try {
    const isDbCreated = await connection.initDb(initJSStoreDB());
    if (isDbCreated) {
      const commonRepository = new CommonJsStoreRepository(connection);
      commonRepository.importData(initialData);
    }
  } catch (error) {
    console.error(error);
  }
  return connection;
}
var dist = { exports: {} };
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(require$$0);
  })(commonjsGlobal, (__WEBPACK_EXTERNAL_MODULE__976__) => {
    return (
      /******/
      (() => {
        var __webpack_modules__ = {
          /***/
          657: (
            /***/
            (__unused_webpack_module, exports2) => {
              Object.defineProperty(exports2, "__esModule", { value: true });
              exports2["default"] = (sfc, props2) => {
                const target = sfc.__vccOpts || sfc;
                for (const [key, val] of props2) {
                  target[key] = val;
                }
                return target;
              };
            }
          ),
          /***/
          976: (
            /***/
            (module2) => {
              module2.exports = __WEBPACK_EXTERNAL_MODULE__976__;
            }
          )
          /******/
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        (() => {
          __webpack_require__.d = (exports2, definition) => {
            for (var key in definition) {
              if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
              }
            }
          };
        })();
        (() => {
          __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
        })();
        (() => {
          __webpack_require__.r = (exports2) => {
            if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
              Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
            }
            Object.defineProperty(exports2, "__esModule", { value: true });
          };
        })();
        var __webpack_exports__ = {};
        (() => {
          __webpack_require__.r(__webpack_exports__);
          __webpack_require__.d(__webpack_exports__, {
            "Component": () => (
              /* reexport */
              Component
            ),
            "LoadingPlugin": () => (
              /* binding */
              LoadingPlugin
            ),
            "default": () => (
              /* binding */
              src
            ),
            "useLoading": () => (
              /* reexport */
              useLoading
            )
          });
          var external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_ = __webpack_require__(976);
          function removeElement(el) {
            if (typeof el.remove !== "undefined") {
              el.remove();
            } else {
              el.parentNode?.removeChild(el);
            }
          }
          function createComponent(component, props2, parentContainer) {
            let slots = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            const vNode = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.h)(component, props2, slots);
            const container = document.createElement("div");
            container.classList.add("vld-container");
            parentContainer.appendChild(container);
            (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.render)(vNode, container);
            return vNode.component;
          }
          function hasWindow() {
            return typeof window !== "undefined";
          }
          const MayBeHTMLElement = hasWindow() ? window.HTMLElement : Object;
          const _hoisted_12 = ["aria-busy"];
          const _hoisted_22 = {
            class: "vl-icon"
          };
          function render2(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createBlock)(external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.Transition, {
              name: _ctx.transition
            }, {
              default: (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withCtx)(() => [(0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withDirectives)((0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementVNode)("div", {
                tabindex: "0",
                class: (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.normalizeClass)(["vl-overlay vl-active", {
                  "vl-full-page": _ctx.isFullPage
                }]),
                "aria-busy": _ctx.isActive,
                "aria-label": "Loading",
                style: (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.normalizeStyle)({
                  zIndex: _ctx.zIndex
                })
              }, [(0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementVNode)("div", {
                class: "vl-background",
                onClick: _cache[0] || (_cache[0] = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.withModifiers)(function() {
                  return _ctx.cancel && _ctx.cancel(...arguments);
                }, ["prevent"])),
                style: (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.normalizeStyle)(_ctx.bgStyle)
              }, null, 4), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementVNode)("div", _hoisted_22, [(0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.renderSlot)(_ctx.$slots, "before"), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.renderSlot)(_ctx.$slots, "default", {}, () => [((0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createBlock)((0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.resolveDynamicComponent)(_ctx.loader), {
                color: _ctx.color,
                width: _ctx.width,
                height: _ctx.height
              }, null, 8, ["color", "width", "height"]))]), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.renderSlot)(_ctx.$slots, "after")])], 14, _hoisted_12), [[external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.vShow, _ctx.isActive]])]),
              _: 3
            }, 8, ["name"]);
          }
          const trapFocusMixin = {
            mounted() {
              if (this.enforceFocus) {
                document.addEventListener("focusin", this.focusIn);
              }
            },
            methods: {
              focusIn(event) {
                if (!this.isActive)
                  return;
                if (
                  // Event target is the loading div element itself
                  event.target === this.$el || // Event target is inside the loading div
                  this.$el.contains(event.target)
                )
                  return;
                let parent = this.container ? this.container : this.isFullPage ? null : this.$el.parentElement;
                if (
                  // Always prevent when loading is full screen
                  this.isFullPage || // When a parent exist means loader is running inside a container
                  // When loading is NOT full screen and event target is inside the given container
                  parent && parent.contains(event.target)
                ) {
                  event.preventDefault();
                  this.$el.focus();
                }
              }
            },
            beforeUnmount() {
              document.removeEventListener("focusin", this.focusIn);
            }
          };
          const spinnervue_type_template_id_1ed0a811_hoisted_1 = ["width", "height", "stroke"];
          const spinnervue_type_template_id_1ed0a811_hoisted_2 = /* @__PURE__ */ (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createStaticVNode)('<g fill="none" fill-rule="evenodd"><g transform="translate(1 1)" stroke-width="2"><circle stroke-opacity=".25" cx="18" cy="18" r="18"></circle><path d="M36 18c0-9.94-8.06-18-18-18"><animateTransform attributeName="transform" type="rotate" from="0 18 18" to="360 18 18" dur="0.8s" repeatCount="indefinite"></animateTransform></path></g></g>', 1);
          const _hoisted_32 = [spinnervue_type_template_id_1ed0a811_hoisted_2];
          function spinnervue_type_template_id_1ed0a811_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementBlock)("svg", {
              viewBox: "0 0 38 38",
              xmlns: "http://www.w3.org/2000/svg",
              width: _ctx.width,
              height: _ctx.height,
              stroke: _ctx.color
            }, _hoisted_32, 8, spinnervue_type_template_id_1ed0a811_hoisted_1);
          }
          const spinnervue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
            name: "spinner",
            props: {
              color: {
                type: String,
                default: "#000"
              },
              height: {
                type: Number,
                default: 64
              },
              width: {
                type: Number,
                default: 64
              }
            }
          });
          var exportHelper = __webpack_require__(657);
          const __exports__ = /* @__PURE__ */ (0, exportHelper["default"])(spinnervue_type_script_lang_js, [["render", spinnervue_type_template_id_1ed0a811_render]]);
          const spinner = __exports__;
          const dotsvue_type_template_id_6ecfb4ba_hoisted_1 = ["fill", "width", "height"];
          const dotsvue_type_template_id_6ecfb4ba_hoisted_2 = /* @__PURE__ */ (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createStaticVNode)('<circle cx="15" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="60" cy="15" r="9" fill-opacity="0.3"><animate attributeName="r" from="9" to="9" begin="0s" dur="0.8s" values="9;15;9" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="0.5" to="0.5" begin="0s" dur="0.8s" values=".5;1;.5" calcMode="linear" repeatCount="indefinite"></animate></circle><circle cx="105" cy="15" r="15"><animate attributeName="r" from="15" to="15" begin="0s" dur="0.8s" values="15;9;15" calcMode="linear" repeatCount="indefinite"></animate><animate attributeName="fill-opacity" from="1" to="1" begin="0s" dur="0.8s" values="1;.5;1" calcMode="linear" repeatCount="indefinite"></animate></circle>', 3);
          const _hoisted_5 = [dotsvue_type_template_id_6ecfb4ba_hoisted_2];
          function dotsvue_type_template_id_6ecfb4ba_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementBlock)("svg", {
              viewBox: "0 0 120 30",
              xmlns: "http://www.w3.org/2000/svg",
              fill: _ctx.color,
              width: _ctx.width,
              height: _ctx.height
            }, _hoisted_5, 8, dotsvue_type_template_id_6ecfb4ba_hoisted_1);
          }
          const dotsvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
            name: "dots",
            props: {
              color: {
                type: String,
                default: "#000"
              },
              height: {
                type: Number,
                default: 240
              },
              width: {
                type: Number,
                default: 60
              }
            }
          });
          const dots_exports_ = /* @__PURE__ */ (0, exportHelper["default"])(dotsvue_type_script_lang_js, [["render", dotsvue_type_template_id_6ecfb4ba_render]]);
          const dots = dots_exports_;
          const barsvue_type_template_id_f81ac1c0_hoisted_1 = ["height", "width", "fill"];
          const barsvue_type_template_id_f81ac1c0_hoisted_2 = /* @__PURE__ */ (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createStaticVNode)('<rect x="0" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0s" dur="0.6s" repeatCount="indefinite"></animate><animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0s" dur="0.6s" repeatCount="indefinite"></animate></rect><rect x="10" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0.15s" dur="0.6s" repeatCount="indefinite"></animate><animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0.15s" dur="0.6s" repeatCount="indefinite"></animate></rect><rect x="20" y="13" width="4" height="5"><animate attributeName="height" attributeType="XML" values="5;21;5" begin="0.3s" dur="0.6s" repeatCount="indefinite"></animate><animate attributeName="y" attributeType="XML" values="13; 5; 13" begin="0.3s" dur="0.6s" repeatCount="indefinite"></animate></rect>', 3);
          const barsvue_type_template_id_f81ac1c0_hoisted_5 = [barsvue_type_template_id_f81ac1c0_hoisted_2];
          function barsvue_type_template_id_f81ac1c0_render(_ctx, _cache, $props, $setup, $data, $options) {
            return (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.createElementBlock)("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 30 30",
              height: _ctx.height,
              width: _ctx.width,
              fill: _ctx.color
            }, barsvue_type_template_id_f81ac1c0_hoisted_5, 8, barsvue_type_template_id_f81ac1c0_hoisted_1);
          }
          const barsvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
            name: "bars",
            props: {
              color: {
                type: String,
                default: "#000"
              },
              height: {
                type: Number,
                default: 40
              },
              width: {
                type: Number,
                default: 40
              }
            }
          });
          const bars_exports_ = /* @__PURE__ */ (0, exportHelper["default"])(barsvue_type_script_lang_js, [["render", barsvue_type_template_id_f81ac1c0_render]]);
          const bars = bars_exports_;
          const loaders = {
            Spinner: spinner,
            Dots: dots,
            Bars: bars
          };
          const Componentvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.defineComponent)({
            name: "VueLoading",
            mixins: [trapFocusMixin],
            props: {
              active: Boolean,
              programmatic: Boolean,
              container: [Object, Function, MayBeHTMLElement],
              isFullPage: {
                type: Boolean,
                default: true
              },
              enforceFocus: {
                type: Boolean,
                default: true
              },
              lockScroll: Boolean,
              transition: {
                type: String,
                default: "fade"
              },
              /**
               * Allow user to hide the loader
               */
              canCancel: Boolean,
              /**
               * Do something on cancel
               */
              onCancel: {
                type: Function,
                default: () => {
                }
              },
              color: String,
              backgroundColor: String,
              opacity: Number,
              width: Number,
              height: Number,
              zIndex: Number,
              loader: {
                type: String,
                default: "spinner"
              }
            },
            components: loaders,
            emits: ["hide", "update:active"],
            data() {
              return {
                // Don't mutate the prop
                isActive: this.active
              };
            },
            mounted() {
              document.addEventListener("keyup", this.keyPress);
            },
            methods: {
              /**
               * Proxy to hide() method.
               * Gets called by ESC button or when click outside
               */
              cancel() {
                if (!this.canCancel || !this.isActive)
                  return;
                this.hide();
                this.onCancel.apply(null, arguments);
              },
              /**
               * Hide and destroy component if it's programmatic.
               */
              hide() {
                this.$emit("hide");
                this.$emit("update:active", false);
                if (this.programmatic) {
                  this.isActive = false;
                  setTimeout(() => {
                    const parent = this.$el.parentElement;
                    (0, external_commonjs_vue_commonjs2_vue_amd_vue_root_Vue_.render)(null, parent);
                    removeElement(parent);
                  }, 150);
                }
              },
              disableScroll() {
                if (this.isFullPage && this.lockScroll) {
                  document.body.classList.add("vl-shown");
                }
              },
              enableScroll() {
                if (this.isFullPage && this.lockScroll) {
                  document.body.classList.remove("vl-shown");
                }
              },
              /**
               * Key press event to hide on ESC.
               */
              keyPress(event) {
                if (event.keyCode === 27)
                  this.cancel();
              }
            },
            watch: {
              active(value) {
                this.isActive = value;
              },
              isActive(value) {
                if (value) {
                  this.disableScroll();
                } else {
                  this.enableScroll();
                }
              }
            },
            computed: {
              bgStyle() {
                return {
                  background: this.backgroundColor,
                  opacity: this.opacity
                };
              }
            },
            beforeUnmount() {
              document.removeEventListener("keyup", this.keyPress);
            }
          });
          const Component_exports_ = /* @__PURE__ */ (0, exportHelper["default"])(Componentvue_type_script_lang_js, [["render", render2]]);
          const Component = Component_exports_;
          function useLoading() {
            let globalProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            let globalSlots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return {
              show() {
                let props2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : globalProps;
                let slots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : globalSlots;
                const forceProps = {
                  programmatic: true,
                  lockScroll: true,
                  isFullPage: false,
                  active: true
                };
                const propsData = {
                  ...globalProps,
                  ...props2,
                  ...forceProps
                };
                let container = propsData.container;
                if (!propsData.container) {
                  container = document.body;
                  propsData.isFullPage = true;
                }
                const mergedSlots = {
                  ...globalSlots,
                  ...slots
                };
                const instance = createComponent(Component, propsData, container, mergedSlots);
                return {
                  hide: instance.ctx.hide
                };
              }
            };
          }
          const LoadingPlugin = function(app2) {
            let props2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            let slots = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            const instance = useLoading(props2, slots);
            app2.config.globalProperties.$loading = instance;
            app2.provide("$loading", instance);
          };
          const src = Component;
        })();
        return __webpack_exports__;
      })()
    );
  });
})(dist);
var distExports = dist.exports;
const $loading = distExports.useLoading({
  color: "#1565C0",
  backgroundColor: "rgba(0,0,0,0)"
});
let loader = null;
const activeLoaders = [];
async function request(promise, hideLoader) {
  if (!hideLoader) {
    if (!loader)
      loader = $loading.show();
    activeLoaders.push(1);
  }
  return promise.finally(() => {
    activeLoaders.pop();
    if (!activeLoaders.length) {
      loader?.hide();
      loader = null;
    }
  });
}
class WordService {
  _repository;
  constructor(repository) {
    this._repository = repository;
  }
  addWord(word) {
    return request(this._repository.add(word));
  }
  updateWord(word) {
    return request(this._repository.edit(word));
  }
  deleteWord(id) {
    return request(this._repository.delete(id));
  }
  getWords() {
    return request(this._repository.getAll());
  }
  getExistingsWords(word) {
    return request(this._repository.getExistingsWords(word), true);
  }
  getWordById(id) {
    return request(this._repository.getById(id));
  }
  getWordsByIds(ids) {
    return request(this._repository.getWordsByIds(ids));
  }
  getDataForExport() {
    return request(this._repository.getDataForExport());
  }
}
window.existingByWordTransaction = async (ctx) => {
  ctx.start();
  const words = await ctx.select({
    from: "word",
    where: {
      word: ctx.data.word
    }
  });
  if (!words.length) {
    return ctx.setResult("data", []);
  }
  const wordsWithSets = await ctx.select({
    from: "word",
    where: {
      id: {
        in: words.map((w) => w.id)
      }
    },
    join: [
      {
        with: "sets",
        on: "word.id = sets.word_id",
        type: "left",
        as: {
          id: "sets_id"
        }
      },
      {
        with: "set",
        on: "sets.set_id = set.id",
        type: "left",
        as: {
          id: "set_id"
        }
      }
    ]
  });
  ctx.setResult("data", wordsWithSets);
};
window.existingWordsTransaction = async (ctx) => {
  ctx.start();
  const wordsWithSets = await ctx.select({
    from: "word",
    join: [
      {
        with: "sets",
        on: "word.id = sets.word_id",
        type: "left",
        as: {
          id: "sets_id"
        }
      },
      {
        with: "set",
        on: "sets.set_id = set.id",
        type: "left",
        as: {
          id: "set_id"
        }
      }
    ]
  });
  ctx.setResult("data", wordsWithSets);
};
class WordJsStoreRepository {
  _dbContext;
  constructor(dbContext) {
    this._dbContext = dbContext;
  }
  getWordsByIds(ids) {
    return this._dbContext.select({
      from: "word",
      where: {
        id: {
          in: ids
        }
      }
    });
  }
  getDataForExport() {
    return this._dbContext.select({
      from: "word"
    });
  }
  async getAll() {
    const result = await this._dbContext.transaction({
      tables: ["word", "sets", "set"],
      method: "existingWordsTransaction"
    });
    const groupedData = {};
    result.data.forEach((w) => {
      if (groupedData[w.id]) {
        groupedData[w.id].sets?.push({
          name: w.name,
          type_ids: w.type_ids,
          id: w.set_id
        });
      } else {
        groupedData[w.id] = w;
        groupedData[w.id].sets = [];
        if (w.set_id !== null) {
          groupedData[w.id].sets?.push({
            name: w.name,
            type_ids: w.type_ids,
            id: w.set_id
          });
        }
      }
    });
    return Object.values(groupedData).map((w) => {
      return {
        id: w.id,
        description: w.description,
        transcription: w.transcription,
        translation: w.translation,
        word: w.word,
        sets: w.sets
      };
    });
  }
  async getById(id) {
    const res = await this._dbContext.select({
      from: "word",
      where: {
        id
      },
      limit: 1
    });
    return res[0];
  }
  async getExistingsWords(word) {
    const result = await this._dbContext.transaction({
      tables: ["word", "sets", "set"],
      method: "existingByWordTransaction",
      data: { word }
    });
    return result.data.map((w) => {
      const existWord = {
        id: w.id,
        description: w.description,
        transcription: w.transcription,
        translation: w.translation,
        word: w.word,
        sets: []
      };
      if (w.set_id !== null)
        existWord.sets.push({
          name: w.name,
          id: w.set_id,
          type_ids: w.type_ids
        });
      return existWord;
    });
  }
  async add(data) {
    return this._dbContext.insert({
      into: "word",
      values: [data]
    }).then(() => void 0);
  }
  async delete(id) {
    return this._dbContext.remove({
      from: "word",
      where: {
        id
      }
    }).then(() => void 0);
  }
  async edit(data) {
    return this._dbContext.update({
      in: "word",
      set: {
        word: data.word,
        translation: data.translation,
        transcription: data.transcription,
        description: data.description
      },
      where: {
        id: data.id || ""
      }
    }).then(() => void 0);
  }
}
class SetService {
  _repository;
  constructor(repository) {
    this._repository = repository;
  }
  addSet(set2) {
    return request(this._repository.add(set2));
  }
  updateSet(set2) {
    return request(this._repository.edit(set2));
  }
  deleteSet(id) {
    return request(this._repository.delete(id));
  }
  getSets() {
    return request(this._repository.getAll());
  }
  getSet(id) {
    return request(this._repository.getById(id));
  }
  getDataForExport() {
    return request(this._repository.getDataForExport());
  }
}
class SetJsStoreRepository {
  _dbContext;
  constructor(dbContext) {
    this._dbContext = dbContext;
  }
  async getDataForExport() {
    return this._dbContext.select({
      from: "set"
    });
  }
  async getAll() {
    const res = await this._dbContext.select({
      from: "set",
      join: [
        {
          with: "sets",
          on: "set.id = sets.set_id",
          type: "left",
          as: {
            id: "set_sets_id"
          }
        }
      ],
      groupBy: ["set_id"],
      aggregate: {
        count: "word_id"
      }
    }).then((res2) => {
      return res2.map((s) => ({
        id: s.id,
        name: s.name,
        count: s["count(word_id)"]
      }));
    });
    return res;
  }
  async getById(id) {
    const [set2] = await this._dbContext.select({
      from: "set",
      where: {
        id
      },
      limit: 1
    });
    const words = await this._dbContext.select({
      from: "sets",
      where: {
        set_id: id
      },
      join: [
        {
          with: "word",
          on: "word.id = sets.word_id",
          type: "left",
          as: {
            id: "word_id"
          }
        }
      ]
    });
    set2.word_ids = words.map((w) => w.word_id);
    return set2;
  }
  async add(data) {
    const res = await this._dbContext.insert({
      into: "set",
      values: [
        {
          id: void 0,
          name: data.name,
          type_ids: data.type_ids
        }
      ],
      return: true
    });
    await this.addWordsToSet(res[0].id, data.word_ids);
  }
  async addWordsToSet(setId, word_ids) {
    const wordIds = word_ids?.map((word_id) => ({ set_id: setId, word_id })) || [];
    await this._dbContext.insert({
      into: "sets",
      values: wordIds
    });
  }
  async removeWordsFromSet(set_id) {
    await this._dbContext.remove({
      from: "sets",
      where: {
        set_id
      }
    });
  }
  async delete(id) {
    await this._dbContext.remove({
      from: "sets",
      where: {
        set_id: id
      }
    });
    await this._dbContext.remove({
      from: "set",
      where: {
        id
      }
    });
  }
  async edit(data) {
    await this._dbContext.update({
      in: "set",
      set: {
        name: data.name,
        type_ids: data.type_ids
      },
      where: {
        id: data.id
      }
    });
    await this.removeWordsFromSet(data.id);
    await this.addWordsToSet(data.id, data.word_ids);
  }
}
class SetsService {
  _repository;
  constructor(repository) {
    this._repository = repository;
  }
  getDataForExport() {
    return request(this._repository.getDataForExport());
  }
}
class SetsJsStoreRepository {
  _dbContext;
  constructor(dbContext) {
    this._dbContext = dbContext;
  }
  async getDataForExport() {
    return this._dbContext.select({
      from: "sets"
    });
  }
}
class CommonService {
  _repository;
  constructor(repository) {
    this._repository = repository;
  }
  importData(data) {
    return request(this._repository.importData(data));
  }
}
async function initStorage() {
  const dbContext = await createJSStoreDbContext();
  return {
    word: new WordService(new WordJsStoreRepository(dbContext)),
    set: new SetService(new SetJsStoreRepository(dbContext)),
    sets: new SetsService(new SetsJsStoreRepository(dbContext)),
    common: new CommonService(new CommonJsStoreRepository(dbContext))
  };
}
const storageKey = Symbol("storage");
const app = createApp(_sfc_main);
app.use(dt, {
  autoClose: 3e3,
  hideProgressBar: true,
  position: "top-center",
  transition: "flip"
});
app.use(vuetify);
app.use(router);
app.component("RecycleScroller", script$2);
app.provide(storageKey, await initStorage());
app.config.errorHandler = (err) => {
  if ("message" in err)
    l(err.message, { type: "error" });
};
app.mount("#app");
export {
  withDirectives as A,
  vShow as B,
  withKeys as C,
  VTextField as D,
  nextTick as E,
  Fragment as F,
  onBeforeUnmount as G,
  pushScopeId as H,
  popScopeId as I,
  onUnmounted as J,
  normalizeClass as K,
  VBtn as L,
  resolveDynamicComponent as M,
  VForm as V,
  createVNode as a,
  createBaseVNode as b,
  createElementBlock as c,
  createTextVNode as d,
  createBlock as e,
  createCommentVNode as f,
  defineComponent$1 as g,
  renderList as h,
  ref as i,
  inject$1 as j,
  useRouter as k,
  l,
  mergeProps as m,
  onMounted as n,
  openBlock as o,
  useRoute as p,
  toRaw as q,
  resolveComponent as r,
  storageKey as s,
  toDisplayString as t,
  unref as u,
  withModifiers as v,
  withCtx as w,
  renderSlot as x,
  computed as y,
  watch as z
};
